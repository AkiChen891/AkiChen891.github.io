[{"title":"Linux RTL8188EUS Wifi驱动调试","url":"/2025/04/17/LinuxWifi驱动调试/","content":"正点原子提供的RTL8188EUS只能用在低版本Kernel，高版本Kernel会出现编译错误，比如我用的6.6.52版本的Kernel就无法编译正点原子提供的那几个Realtek的驱动文件。\n\n尝试从网上找能够支持新版本Kernel的RTL8188EUS的驱动，Google出来第一位是这个：\nhttps://github.com/aircrack-ng/rtl8188eus\n\n看了一圈，这个仓库有1k的star，并且最新支持到了6.12版本的Kernel，看上去很不错，下载下来，准备在虚拟机里交叉编译成arm版本：\n```\nexport KDIR=~/linux/NXP_linux/linux-imx-lf-6.6.y\n\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KSRC=$KDIR\n```\n注意这里的KDIR要设置成自己的Linux Kernel源码目录，不能用默认的，否则编译出来的是x86架构，没法在板子上用。\n\n正常状况下编译会得到8188eu.ko这个模块：\n```\n8188eu.ko     BUILD_FOR_NETHUNTER.md  dkms-remove.sh  modules.order   ReleaseNotes.pdf\n8188eu.mod    built-in.a              hal             Module.symvers\n8188eu.mod.c  core                    include         os_dep\n8188eu.mod.o  dkms.conf               Kconfig         platform\n8188eu.o      dkms-install.sh         Makefile        README.md\n```\n把模块拷贝到根目录下/lib/modules/6.6.52中，重启开发板，尝试加载模块，Kernel报错：\n```\n[   77.296944] 8188eu: loading out-of-tree module taints kernel.\n[   77.306670] 8188eu: Unknown symbol __cfg80211_alloc_event_skb (err -2)\n[   77.316458] 8188eu: Unknown symbol wiphy_register (err -2)\n[   77.325178] 8188eu: Unknown symbol cfg80211_remain_on_channel_expired (err -2)\n[   77.335632] 8188eu: Unknown symbol cfg80211_vendor_cmd_reply (err -2)\n[   77.345288] 8188eu: Unknown symbol cfg80211_del_sta_sinfo (err -2)\n[   77.354656] 8188eu: Unknown symbol wiphy_unregister (err -2)\n[   77.363749] 8188eu: Unknown symbol cfg80211_ch_switch_notify (err -2)\n[   77.373440] 8188eu: Unknown symbol ieee80211_get_channel_khz (err -2)\n[   77.383033] 8188eu: Unknown symbol cfg80211_ready_on_channel (err -2)\n[   77.392592] 8188eu: Unknown symbol wiphy_free (err -2)\n[   77.400814] 8188eu: Unknown symbol wiphy_new_nm (err -2)\n[   77.409047] 8188eu: Unknown symbol cfg80211_get_bss (err -2)\n[   77.417488] 8188eu: Unknown symbol ieee80211_freq_khz_to_channel (err -2)\n[   77.427077] 8188eu: Unknown symbol __cfg80211_send_event_skb (err -2)\n[   77.436316] 8188eu: Unknown symbol cfg80211_disconnected (err -2)\n[   77.445217] 8188eu: Unknown symbol cfg80211_michael_mic_failure (err -2)\n[   77.454688] 8188eu: Unknown symbol cfg80211_ibss_joined (err -2)\n[   77.463463] 8188eu: Unknown symbol cfg80211_scan_done (err -2)\n[   77.471772] 8188eu: Unknown symbol cfg80211_roamed (err -2)\n[   77.479798] 8188eu: Unknown symbol cfg80211_put_bss (err -2)\n[   77.487786] 8188eu: Unknown symbol cfg80211_connect_done (err -2)\n[   77.496214] 8188eu: Unknown symbol cfg80211_unlink_bss (err -2)\n[   77.504461] 8188eu: Unknown symbol cfg80211_inform_bss_frame_data (err -2)\n[   77.513599] 8188eu: Unknown symbol cfg80211_new_sta (err -2)\n[   77.521513] 8188eu: Unknown symbol __cfg80211_alloc_reply_skb (err -2)\n[   77.530336] 8188eu: Unknown symbol cfg80211_rx_mgmt_ext (err -2)\n[   77.538526] 8188eu: Unknown symbol wiphy_apply_custom_regulatory (err -2)\n[   77.547557] 8188eu: Unknown symbol cfg80211_mgmt_tx_status_ext (err -2)\n[   77.656978] 8188eu: Unknown symbol __cfg80211_alloc_event_skb (err -2)\n[   77.665898] 8188eu: Unknown symbol wiphy_register (err -2)\n[   77.673436] 8188eu: Unknown symbol cfg80211_remain_on_channel_expired (err -2)\n[   77.682597] 8188eu: Unknown symbol cfg80211_vendor_cmd_reply (err -2)\n[   77.691051] 8188eu: Unknown symbol cfg80211_del_sta_sinfo (err -2)\n[   77.699152] 8188eu: Unknown symbol wiphy_unregister (err -2)\n[   77.706787] 8188eu: Unknown symbol cfg80211_ch_switch_notify (err -2)\n[   77.715234] 8188eu: Unknown symbol ieee80211_get_channel_khz (err -2)\n[   77.723608] 8188eu: Unknown symbol cfg80211_ready_on_channel (err -2)\n[   77.732000] 8188eu: Unknown symbol wiphy_free (err -2)\n[   77.739088] 8188eu: Unknown symbol wiphy_new_nm (err -2)\n[   77.746251] 8188eu: Unknown symbol cfg80211_get_bss (err -2)\n[   77.753799] 8188eu: Unknown symbol ieee80211_freq_khz_to_channel (err -2)\n[   77.762421] 8188eu: Unknown symbol __cfg80211_send_event_skb (err -2)\n[   77.770861] 8188eu: Unknown symbol cfg80211_disconnected (err -2)\n[   77.778911] 8188eu: Unknown symbol cfg80211_michael_mic_failure (err -2)\n[   77.787562] 8188eu: Unknown symbol cfg80211_ibss_joined (err -2)\n[   77.795674] 8188eu: Unknown symbol cfg80211_scan_done (err -2)\n[   77.803474] 8188eu: Unknown symbol cfg80211_roamed (err -2)\n[   77.810850] 8188eu: Unknown symbol cfg80211_put_bss (err -2)\n[   77.818533] 8188eu: Unknown symbol cfg80211_connect_done (err -2)\n[   77.826583] 8188eu: Unknown symbol cfg80211_unlink_bss (err -2)\n[   77.834431] 8188eu: Unknown symbol cfg80211_inform_bss_frame_data (err -2)\n[   77.843325] 8188eu: Unknown symbol cfg80211_new_sta (err -2)\n[   77.850940] 8188eu: Unknown symbol __cfg80211_alloc_reply_skb (err -2)\n[   77.859411] 8188eu: Unknown symbol cfg80211_rx_mgmt_ext (err -2)\n[   77.867403] 8188eu: Unknown symbol wiphy_apply_custom_regulatory (err -2)\n[   77.876210] 8188eu: Unknown symbol cfg80211_mgmt_tx_status_ext (err -2)\nmodprobe: can't load module 8188eu.ko (8188eu.ko): unknown symbol in module, or unknown parameter\n```\n这一看就是CFG80211编译报错了，跑了一下`dmesg | grep cfg80211`发现CFG80211根本没有加载，但是我之前明明配置好了开机自动加载的，不知道哪里把配置弄丢了，于是手动`depmod cfg80211`，然后再`depmod 8188eu.ko`：\n```\n/lib/modules/6.6.52 # modprobe  cfg80211.ko \n[   18.046491] cfg80211: Loading compiled-in X.509 certificates for regulatory database\n[   18.123855] Loaded X.509 cert 'sforshee: 00b28ddf47aef9cea7'\n[   18.138554] Loaded X.509 cert 'wens: 61c038651aabdcf94bd0ac7ff06c7248db18c600'\n/lib/modules/6.6.52 # modprobe 8188eu.ko \n[   25.931742] 8188eu: loading out-of-tree module taints kernel.\n[   25.959171] bFWReady == _FALSE call reset 8051...\n[   26.008887] usbcore: registered new interface driver 8188eu\n```\n再`ifconfig -a`，可以看到WLAN0信息，驱动工作成功。\n\n关于cfg80211，之前为了避免出现cfg80211: failed to load regulatory.db的报错信息，参考[文章1](https://blog.csdn.net/wangfei19841001/article/details/141023775?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-141023775-blog-140298343.235^v43^pc_blog_bottom_relevance_base3&spm=1001.2101.3001.4242.1&utm_relevant_index=2)和[文章2](https://blog.csdn.net/m0_61320035/article/details/140298343?spm=1001.2014.3001.5506)将CFG80211配置成了模块加载形式，也就是`CONFIG_CFG80211=m`，不随Kernel启动。但是Kernel编译时会正常编译cfg80211.ko，位于`./net/wireless/cfg80211.ko`，将它拷贝到`/lib/modules/6.6.52`里手动modprobe就可以。","categories":["嵌入式(Linux开发)"]},{"title":"Linux FlexCAN调试","url":"/2025/04/17/LinuxFlexCAN调试/","content":"## 设备树\n按照手册来即可，注意Alpha版上Flexcan2节点的引脚被ecspi3复用，节点中要屏蔽掉flexcan2:\n```\n/* Conflict with ECSPI3 */\n&can2 {\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_flexcan2>;\n\txceiver-supply = <&reg_can_3v3>;\n\tstatus = \"disabled\";\n};\n```\n原厂设备树节点中`xceiver-supply = <&reg_can_3v3>;`这个属性可能会导致deferred probing，让CANprobe不出来，屏蔽掉这个属性就可以，完成后的节点如下：\n```\n&can1 {\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_flexcan1>;\n\t//xceiver-supply = <&reg_can_3v3>;\n\tstatus = \"okay\";\n};\n```\n完成后`ifconfig -a`应该可以看得到CAN节点信息：\n```\n/ # ifconfig -a\ncan0      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  \n          NOARP  MTU:16  Metric:1\n          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:10 \n          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)\n          Interrupt:206 \n\neth0      Link encap:Ethernet  HWaddr EA:36:EF:87:91:0F  \n          inet addr:192.168.1.103  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fe80::e836:efff:fe87:910f/64 Scope:Link\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:3294 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:1444 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 \n          RX bytes:4472406 (4.2 MiB)  TX bytes:259612 (253.5 KiB)\n\neth1      Link encap:Ethernet  HWaddr C6:F2:80:26:D2:07  \n          BROADCAST MULTICAST  MTU:1500  Metric:1\n          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 \n          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)\n\nlo        Link encap:Local Loopback  \n          inet addr:127.0.0.1  Mask:255.0.0.0\n          inet6 addr: ::1/128 Scope:Host\n          UP LOOPBACK RUNNING  MTU:65536  Metric:1\n          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 \n          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)\n\nsit0      Link encap:IPv6-in-IPv4  \n          NOARP  MTU:1480  Metric:1\n          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 \n          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)\n```\n\n## iproute库编译\n经过试验，新版本的iproute确实会出现找不到诸如libelf头文件等奇怪的情况，暂未深究原因。\n\n编译时可能报错：\n> 错误： 对‘setns’的静态声明出现在非静态声明之后\n方法是打开iproute根目录/include/namespace.h文件，注释掉下面几行：\n```\n#ifndef HAVE_SETNS\nstatic inline int setns(int fd, int nstype)\n{\n#ifdef __NR_setns\n\treturn syscall(__NR_setns, fd, nstype);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}\n#endif /* HAVE_SETNS */\n```\n然后重新编译\n\n\n","categories":["嵌入式(Linux开发)"]},{"title":"LinuxWM8960和声卡驱动","url":"/2025/04/16/LinuxWM8960和声卡驱动/","content":"## 设备树\n6.6.52版本Kernel中NXP已经默认在imx6ul-14x14-evk.dtsi中配置好了wm8960的节点，但是是配置在i2c2下，而正点原子阿尔法开发板中wm8960接在i2c1下，所以要把节点从i2c2移到i2c1：\n```\n&i2c1 {\n\tclock-frequency = <100000>;\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_i2c1>;\n\tstatus = \"okay\";\n\n    /* 省略其他节点 */\n\n\tcodec: wm8960@1a {\n\t\t#sound-dai-cells = <0>;\n\t\tcompatible = \"wlf,wm8960\";\n\t\treg = <0x1a>;\n\t\twlf,shared-lrclk;\n\t\twlf,hp-cfg = <3 2 3>;\n\t\twlf,gpio-cfg = <1 3>;\n\t\tclocks = <&clks IMX6UL_CLK_SAI2>;\n\t\tclock-names = \"mclk\";\n\t};\n};\n```\n根节点下还需要创建一个sound节点，NXP默认也已经配置好了：\n```\n/ {\n    /* 省略其他节点 */\n\n    sound-wm8960 {\n\t\tcompatible = \"fsl,imx-audio-wm8960\";\n\t\tmodel = \"wm8960-audio\";\n\t\taudio-cpu = <&sai2>;\n\t\taudio-codec = <&codec>;\n\t\taudio-asrc = <&asrc>;\n\t\thp-det-gpio = <&gpio5 4 0>;\n\t\taudio-routing =\n\t\t\t\"Headphone Jack\", \"HP_L\",\n\t\t\t\"Headphone Jack\", \"HP_R\",\n\t\t\t\"Ext Spk\", \"SPK_LP\",\n\t\t\t\"Ext Spk\", \"SPK_LN\",\n\t\t\t\"Ext Spk\", \"SPK_RP\",\n\t\t\t\"Ext Spk\", \"SPK_RN\",\n\t\t\t\"LINPUT2\", \"Mic Jack\",\n\t\t\t\"LINPUT3\", \"Mic Jack\",\n\t\t\t\"RINPUT1\", \"AMIC\",\n\t\t\t\"RINPUT2\", \"AMIC\",\n\t\t\t\"Mic Jack\", \"MICB\",\n\t\t\t\"AMIC\", \"MICB\";\n\t\tstatus = \"okay\";\t\t/* must add this */\n\t};\n}\n```\n注意最后的`status = \"okay\"`必须要加，不然ALSA识别不到。\n\nMenuconfig里默认已经启用了wm8960在imx系列board上的区别，ALSA模拟OSS的API也已经关闭，保持默认即可。\n\n## alsa-lib & alsa-utils\n照着教程来做就可以，不一样的地方在于，65.4.2节移植alsa-utils时，makefile可能会报错：\n> mv: 无法获取\"t-ja.gmo\" 的文件状态(stat): 没有那个文件或目录\nmake[2]: *** [ja.gmo] 错误 1\n\n而且报错不止一个文件，都位于`alsaconf/po/`下，解决办法是自己创建一个空文件 `~/alsa-utils-xxx/alsaconf/po/t-ja.gmo`，缺什么就添加什么，反正alsaconf这个功能暂时用不到。\n\n## aplay报错\n按照教程执行aplay后kernel报错：\n> Playing WAVE 'RWR.wav' : Signed 16 bit Little Endian, Rate 48000 Hz, Stereo\n\n> imx-sdma 20ec000.dma-controller: sdma or sdma firmware not ready!\n\n> fsl-sai 202c000.sai: ASoC: error at soc_component_trigger on 202c000.sai: -12\n\n> aplay: pcm_write:2178: write error: Input/output error\n\n考虑到这四条消息是一起跳出来的，上网查了一圈ASoC错误很少有人提及，一般都是时钟配置有问题，要么就是硬件设计时的错误，但考虑到我直接用的是NXP原厂的设备树，并且板子是现成的开发板，基本可以排除硬件设计原因。因此我猜测问题是由sdma没初始化引起的，因为alsa会调用sdma来进行音频流的传输。\n\n参考这篇文章进行sdma的配置：[正点原子I.MAX6ULL kernel6.6移植遇到的问题](https://blog.csdn.net/m0_61320035/article/details/140298343?spm=1001.2014.3001.5506)\n\n配置完成后，重新编译kernel，下载，再调用aplay，就能够成功播放了。\n\n## alsactl 提示no such file or directory\n[参考文章](https://blog.csdn.net/JasonTD/article/details/131927546) \n制作根文件系统的时候没有/var/lock的目录，alsactl默认会在/var/lock目录操作，所以就会失败。解决办法是`mkdir -p /var/lock`","categories":["嵌入式(Linux开发)"]},{"title":"Linux下GT911驱动移植","url":"/2025/04/13/Linux下GT911驱动移植/","content":"Kernel版本：6.6.52\n\n开始前首先确认所用屏幕背面IC的丝印，到底是ft5426还是gt911，二者驱动不通用\n\n## 客制化驱动\n若使用正点原子提供的gt9147.c驱动:\n### 设备树\n```\n&i2c2 {\n\tgt911:gt911@14 {\n \t\tcompatible = \"goodix,gt911\", \"goodix,gt9xx\";\n \t\treg = <0x14>;\n \t\tpinctrl-names = \"default\";\n \t\tpinctrl-0 = <&pinctrl_gt911>;\n \t\tinterrupt-parent = <&gpio1>;\n \t\tinterrupts = <9 0>;\n \t\treset-gpios = <&gpio5 9 GPIO_ACTIVE_LOW>;\n\t\tinterrupt-gpios = <&gpio1 9 GPIO_ACTIVE_LOW>;\n \t\tstatus = \"okay\"; \n \t};\n};\n\n&iomuxc {\n\tpinctrl_gt911: gt911grp {\n\tfsl,pins = <\n\t\tMX6UL_PAD_GPIO1_IO09__GPIO1_IO09 \t0x79 /* TSC_INT */\n\t\tMX6UL_PAD_SNVS_TAMPER9__GPIO5_IO09  0x10B0\n\t\t>;\n\t};\n};\n```\n6.6.52版本的Kernel DT不需要把`MX6UL_PAD_SNVS_TAMPER9__GPIO5_IO09`单独移到`iomuxc_snvs`中\n\n### 驱动\n```\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_irq.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/gpio.h>\n#include <linux/of_gpio.h>\n#include <linux/of.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/i2c.h>\n#include <asm/unaligned.h>\n\n#define GT_CTRL_REG \t        0X8040  \n#define GT_MODSW_REG \t        0X804D  \n#define GT_9xx_CFGS_REG \t    0X8047  \n#define GT_1xx_CFGS_REG \t    0X8050  \n#define GT_CHECK_REG \t        0X80FF  \n#define GT_PID_REG \t\t        0X8140  \n\n#define GT_GSTID_REG \t        0X814E  \n#define GT_TP1_REG \t\t        0X814F  \n#define GT_TP2_REG \t\t        0X8157\t\n#define GT_TP3_REG \t\t        0X815F  \n#define GT_TP4_REG \t\t        0X8167  \n#define GT_TP5_REG \t\t        0X816F\t\n#define MAX_SUPPORT_POINTS      5       \n\nstruct gt911_dev {\n\tint irq_pin,reset_pin;\t\t\t\t\t\n\tint irqnum;\t\t\t\t\t\t\t\t\n\tint irqtype;\t\t\t\t\t\t\t\n\tint max_x;\t\t\t\t\t\t\t\t\n\tint max_y; \t\t\t\t\t\t\t\t\n\tvoid *private_data;\t\t\t\t\t\t\n\tstruct input_dev *input;\t\t\t\n\tstruct i2c_client *client;\t\t\t\n\n};\nstruct gt911_dev gt911;\n\nconst u8 irq_table[] = {IRQ_TYPE_EDGE_RISING, IRQ_TYPE_EDGE_FALLING, IRQ_TYPE_LEVEL_LOW, IRQ_TYPE_LEVEL_HIGH};  /* 触发方式 */\n\n/* reset gt911 */\nstatic int gt911_ts_reset(struct i2c_client *client, struct gt911_dev *dev)\n{\n\tint ret = 0;\n\n    /* request RESET gpio */\n\tif (gpio_is_valid(dev->reset_pin)) {  \t\t\n\t\tret = devm_gpio_request_one(&client->dev,\t\n\t\t\t\t\tdev->reset_pin, GPIOF_OUT_INIT_HIGH,\n\t\t\t\t\t\"gt911 reset\");\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n    /* request INT gpio */\n\tif (gpio_is_valid(dev->irq_pin)) {  \t\t\n\t\tret = devm_gpio_request_one(&client->dev,\t\n\t\t\t\t\tdev->irq_pin, GPIOF_OUT_INIT_HIGH,\n\t\t\t\t\t\"gt911 int\");\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n    /* initialize gt911 follow datasheet */\n    gpio_set_value(dev->reset_pin, 0);\n    msleep(10);\n    gpio_set_value(dev->reset_pin, 1); \n    msleep(10);\n    gpio_set_value(dev->irq_pin, 0);   \n    msleep(50);\n    gpio_direction_input(dev->irq_pin); \n\n\treturn 0;\n}\n\nstatic int gt911_read_regs(struct gt911_dev *dev, u16 reg, u8 *buf, int len)\n{\n\tint ret;\n    u8 regdata[2];\n\tstruct i2c_msg msg[2];\n\tstruct i2c_client *client = (struct i2c_client *)dev->client;\n    \n    regdata[0] = reg >> 8;\n    regdata[1] = reg & 0xFF;\n\n\tmsg[0].addr = client->addr;\t\t\t\n\tmsg[0].flags = !I2C_M_RD;\t\t\t\n\tmsg[0].buf = &regdata[0];\t\t\t\n\tmsg[0].len = 2;\t\t\t\t\t\t\n\n\tmsg[1].addr = client->addr;\t\t\t\n\tmsg[1].flags = I2C_M_RD;\t\t\t\n\tmsg[1].buf = buf;\t\t\t\t\t\n\tmsg[1].len = len;\t\t\t\t\t\n\n\tret = i2c_transfer(client->adapter, msg, 2);\n\tif(ret == 2) {\n\t\tret = 0;\n\t} else {\n\t\tret = -EREMOTEIO;\n\t}\n\treturn ret;\n}\n\nstatic s32 gt911_write_regs(struct gt911_dev *dev, u16 reg, u8 *buf, u8 len)\n{\n\tu8 b[256];\n\tstruct i2c_msg msg;\n\tstruct i2c_client *client = (struct i2c_client *)dev->client;\n\t\n\tb[0] = reg >> 8;\t\t\t\n    b[1] = reg & 0XFF;\t\t\t\n\tmemcpy(&b[2],buf,len);\t\t\n\n\tmsg.addr = client->addr;\t\n\tmsg.flags = 0;\t\t\t\t\n\n\tmsg.buf = b;\t\t\t\t\n\tmsg.len = len + 2;\t\t\t\n\n\treturn i2c_transfer(client->adapter, &msg, 1);\n}\n\nstatic irqreturn_t gt911_irq_handler(int irq, void *dev_id)\n{\n    int touch_num = 0;\n    int input_x, input_y;\n    int id = 0;\n    int ret = 0;\n    u8 data;\n    u8 touch_data[5];\n    struct gt911_dev *dev = dev_id;\n\n    ret = gt911_read_regs(dev, GT_GSTID_REG, &data, 1);\n    if (data == 0x00)  {     /* no touch data */\n        goto fail;\n    } else {                 /* calculate touch data */\n        touch_num = data & 0x0f;\n    }\n\n    if(touch_num) {         \n        gt911_read_regs(dev, GT_TP1_REG, touch_data, 5);\n        id = touch_data[0] & 0x0F;\n        if(id == 0) {\n            input_x  = touch_data[1] | (touch_data[2] << 8);\n            input_y  = touch_data[3] | (touch_data[4] << 8);\n\n            input_mt_slot(dev->input, id);\n\t\t    input_mt_report_slot_state(dev->input, MT_TOOL_FINGER, true);\n\t\t    input_report_abs(dev->input, ABS_MT_POSITION_X, input_x);\n\t\t    input_report_abs(dev->input, ABS_MT_POSITION_Y, input_y);\n        }\n    } else if(touch_num == 0){                \n        input_mt_slot(dev->input, id);\n        input_mt_report_slot_state(dev->input, MT_TOOL_FINGER, false);\n    }\n\n\tinput_mt_report_pointer_emulation(dev->input, true);\n    input_sync(dev->input);\n\n    data = 0x00;                \n    gt911_write_regs(dev, GT_GSTID_REG, &data, 1);\n\nfail:\n\treturn IRQ_HANDLED;\n}\n\n\nstatic int gt911_ts_irq(struct i2c_client *client, struct gt911_dev *dev)\n{\n\tint ret = 0;\n\t\n\t/* requeset IRQ */\n\tret = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\t\tgt911_irq_handler, irq_table[dev->irqtype] | IRQF_ONESHOT,\n\t\t\t\t\tclient->name, &gt911);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Unable to request touchscreen IRQ.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int gt911_read_firmware(struct i2c_client *client, struct gt911_dev *dev)\n{\n\tint ret = 0, version = 0;\n\tu16 id = 0;\n\tu8 data[7]={0};\n\tchar id_str[5];\n\tret = gt911_read_regs(dev, GT_PID_REG, data, 6);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Unable to read PID.\\n\");\n\t\treturn ret;\n\t}\n\tmemcpy(id_str, data, 4);\n\tid_str[4] = 0;\n    if (kstrtou16(id_str, 10, &id))\n        id = 0x1001;\n\tversion = get_unaligned_le16(&data[4]);\n\tdev_info(&client->dev, \"ID %d, version: %04x\\n\", id, version);\n\tswitch (id) {    \n    case 1151:\n    case 1158:\n    case 5663:\n    case 5688:    \n        ret = gt911_read_regs(dev, GT_1xx_CFGS_REG, data, 7);  \n\t\tbreak;\n    default:\n        ret = gt911_read_regs(dev, GT_9xx_CFGS_REG, data, 7);\n\t\tbreak;\n    }\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Unable to read Firmware.\\n\");\n\t\treturn ret;\n\t}\n\tdev->max_x = (data[2] << 8) + data[1];\n\tdev->max_y = (data[4] << 8) + data[3];\n\tdev->irqtype = data[6] & 0x3;\n\tprintk(\"X_MAX: %d, Y_MAX: %d, TRIGGER: 0x%02x\", dev->max_x, dev->max_y, dev->irqtype);\n\n\treturn 0;\n}\n\nstatic int gt911_probe(struct i2c_client *client)\n{\n    u8 data, ret;\n    gt911.client = client;\n\n\tgt911.irq_pin = of_get_named_gpio(client->dev.of_node, \"interrupt-gpios\", 0);\n\tgt911.reset_pin = of_get_named_gpio(client->dev.of_node, \"reset-gpios\", 0);\n\n\tret = gt911_ts_reset(client, &gt911);\n\tif(ret < 0) {\n\t\tgoto fail;\n    }\n\n    data = 0x02;\n    gt911_write_regs(&gt911, GT_CTRL_REG, &data, 1); \n    mdelay(100);\n    data = 0x0;\n    gt911_write_regs(&gt911, GT_CTRL_REG, &data, 1); \n    mdelay(100);\n\t\n    \n\tret = gt911_read_firmware(client, &gt911);\n\tif(ret != 0) {\n\t\tprintk(\"Fail !!! check !!\\r\\n\");\n\t\tgoto fail;\n    }\n\t\n\tgt911.input = devm_input_allocate_device(&client->dev);\n\tif (!gt911.input) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tgt911.input->name = client->name;\n\tgt911.input->id.bustype = BUS_I2C;\n\tgt911.input->dev.parent = &client->dev;\n\n\t__set_bit(EV_KEY, gt911.input->evbit);\n\t__set_bit(EV_ABS, gt911.input->evbit);\n\t__set_bit(BTN_TOUCH, gt911.input->keybit);\n\n\tinput_set_abs_params(gt911.input, ABS_X, 0, gt911.max_x, 0, 0);\n\tinput_set_abs_params(gt911.input, ABS_Y, 0, gt911.max_y, 0, 0);\n\tinput_set_abs_params(gt911.input, ABS_MT_POSITION_X,0, gt911.max_x, 0, 0);\n\tinput_set_abs_params(gt911.input, ABS_MT_POSITION_Y,0, gt911.max_y, 0, 0);\t     \n\tret = input_mt_init_slots(gt911.input, MAX_SUPPORT_POINTS, 0);\n\tif (ret) {\n\t\tgoto fail;\n\t}\n\n\tret = input_register_device(gt911.input);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = gt911_ts_irq(client, &gt911);\n\tif(ret < 0) {\n\t\tgoto fail;\n\t}\n\n\tdev_info(&client->dev, \"GT911 Probe OK\\r\\n\");\n\n    return 0;\n\nfail:\n\treturn ret;\n}\n\n\nstatic void gt911_remove(struct i2c_client *client)\n{\n    input_unregister_device(gt911.input);\n}\n\n\nconst struct of_device_id gt911_of_match_table[] = {\n    {.compatible = \"goodix,gt911\" },\n    { }\n};\n\t\nstruct i2c_driver gt911_i2c_driver = {\n    .driver = {\n        .name  = \"gt911\",\n        .owner = THIS_MODULE,\n        .of_match_table = gt911_of_match_table,\n    },\n    .probe  = gt911_probe,\n    .remove = gt911_remove,\n};\n\nmodule_i2c_driver(gt911_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"aki\");\n```\n\n## Kernel提供驱动\n驱动文件为`/drivers/input/touchscreen/goodix.c`\n### 设备树\n按照binding要求\n```\n# SPDX-License-Identifier: GPL-2.0\n%YAML 1.2\n---\n$id: http://devicetree.org/schemas/input/touchscreen/goodix.yaml#\n$schema: http://devicetree.org/meta-schemas/core.yaml#\n\ntitle: Goodix GT9xx series touchscreen controller\n\nmaintainers:\n  - Dmitry Torokhov <dmitry.torokhov@gmail.com>\n\nallOf:\n  - $ref: touchscreen.yaml#\n\nproperties:\n  compatible:\n    enum:\n      - goodix,gt1151\n      - goodix,gt1158\n      - goodix,gt5663\n      - goodix,gt5688\n      - goodix,gt911\n      - goodix,gt9110\n      - goodix,gt912\n      - goodix,gt9147\n      - goodix,gt917s\n      - goodix,gt927\n      - goodix,gt9271\n      - goodix,gt928\n      - goodix,gt9286\n      - goodix,gt967\n\n  reg:\n    enum: [ 0x5d, 0x14 ]\n\n  interrupts:\n    maxItems: 1\n\n  irq-gpios:\n    description: GPIO pin used for IRQ. The driver uses the interrupt gpio pin\n      as output to reset the device.\n    maxItems: 1\n\n  reset-gpios:\n    maxItems: 1\n\n  AVDD28-supply:\n    description: Analog power supply regulator on AVDD28 pin\n\n  VDDIO-supply:\n    description: GPIO power supply regulator on VDDIO pin\n\n  touchscreen-inverted-x: true\n  touchscreen-inverted-y: true\n  touchscreen-size-x: true\n  touchscreen-size-y: true\n  touchscreen-swapped-x-y: true\n\nadditionalProperties: false\n\nrequired:\n  - compatible\n  - reg\n  - interrupts\n\nexamples:\n  - |\n    i2c {\n      #address-cells = <1>;\n      #size-cells = <0>;\n      gt928@5d {\n        compatible = \"goodix,gt928\";\n        reg = <0x5d>;\n        interrupt-parent = <&gpio>;\n        interrupts = <0 0>;\n        irq-gpios = <&gpio1 0 0>;\n        reset-gpios = <&gpio1 1 0>;\n      };\n    };\n```\n`compatible`、`reg`和`interrupts`必须要有，其他的无所谓，修改设备树节点如下：\n```\n&i2c2 {\n\tgt911:gt911@14 {\n \t\tcompatible = \"goodix,gt911\", \"goodix,gt9xx\";\n \t\treg = <0x14>;\n \t\tinterrupt-parent = <&gpio1>;\n \t\tinterrupts = <9 0>;\n \t\treset-gpios = <&gpio5 9 GPIO_ACTIVE_HIGH>;\n\t\tirq-gpios = <&gpio1 9 GPIO_ACTIVE_HIGH>;\n \t\tstatus = \"okay\"; \n \t};\n};\n```\n*注意*：这里的reset-gpio和irq-gpio有效电平均为高电平，不能设置成低电平，虽然硬件设计时INT和RST为外部上拉低电平有效。原因未知。\n\n驱动由于找不到本地的xxx_cfg.bin文件导致长时间等待（一般为64s）后再进行input注册的问题可以通过在goodix.c中Probe函数中修改判断条件解决：\n```\n/* 注释掉本地cfg检索，防止找不到cfg.bin时长时间等待 */\n\t //if (ts->load_cfg_from_disk) {\n\t if (0){\n\t\t /* update device config */\n\t\t error = device_property_read_string(&client->dev,\n\t\t\t\t\t\t\t \"goodix,config-name\",\n\t\t\t\t\t\t\t &cfg_name);\n\t\t if (!error)\n\t\t\t snprintf(ts->cfg_name, sizeof(ts->cfg_name),\n\t\t\t\t  \"goodix/%s\", cfg_name);\n\t\t else\n\t\t\t snprintf(ts->cfg_name, sizeof(ts->cfg_name),\n\t\t\t\t  \"goodix_%s_cfg.bin\", ts->id);\n \n\t\t error = request_firmware_nowait(THIS_MODULE, true, ts->cfg_name,\n\t\t\t\t\t\t &client->dev, GFP_KERNEL, ts,\n\t\t\t\t\t\t goodix_config_cb);\n\t\t if (error) {\n\t\t\t dev_err(&client->dev,\n\t\t\t\t \"Failed to invoke firmware loader: %d\\n\",\n\t\t\t\t error);\n\t\t\t return error;\n\t\t }\n \n\t\t return 0;\n\t } else {\n\t\t......\n\t }\n```","categories":["嵌入式(Linux开发)"]},{"title":"Linux快速切换交叉编译器版本","url":"/2025/04/12/Linux快速切换交叉编译器版本/","content":"\n确保`/usr/local/arm`下有以下命令格式的交叉编译器文件夹：\n```\ngcc-版本号-arm-linux-gnueabihf\n```\n比如\n```\ngcc-7.5.0-arm-linux-gnueabihf\n```\n\nShell文件：\n```\n#!/bin/bash\n\n# 所有工具链的根目录\nTOOLCHAIN_ROOT=\"/usr/local/arm\"\n\n# 显示所有可用版本\nfunction list_versions() {\n    echo \"Available toolchain versions:\"\n    for dir in \"$TOOLCHAIN_ROOT\"/gcc-*; do\n        ver=$(basename \"$dir\" | sed 's/^gcc-\\(.*\\)-arm.*/\\1/')\n        echo \"  - $ver\"\n    done\n}\n\n# 显示当前交叉编译器版本\nfunction current_version() {\n    which arm-linux-gnueabihf-gcc >/dev/null 2>&1 || {\n        echo \"arm-linux-gnueabihf-gcc not found in PATH\"\n        return\n    }\n\n    echo -n \"Current compiler version: \"\n    arm-linux-gnueabihf-gcc -v 2>&1 | grep \"gcc 版本\" | awk '{print $3}'\n}\n\n# 切换工具链\nfunction switch_version() {\n    local version=$1\n    local match_dir=\"$TOOLCHAIN_ROOT/gcc-${version}-arm-linux-gnueabihf\"\n\n    if [ ! -d \"$match_dir\" ]; then\n        echo \"Error: Toolchain version $version not found in $TOOLCHAIN_ROOT\"\n        list_versions\n        return 1\n    fi\n\n    # 清除当前 PATH 中旧的 toolchain 目录\n    export PATH=$(echo \"$PATH\" | tr ':' '\\n' | grep -v \"$TOOLCHAIN_ROOT\" | paste -sd ':' -)\n    # 加入新版本路径\n    export PATH=\"$match_dir/bin:$PATH\"\n\n    echo \"Switched to toolchain version $version\"\n    current_version\n}\n\n# 参数处理\ncase \"$1\" in\n    list)\n        list_versions\n        ;;\n    current)\n        current_version\n        ;;\n    switch)\n        if [ -z \"$2\" ]; then\n            echo \"Usage: source toolchain-switcher.sh switch <version>\"\n        else\n            switch_version \"$2\"\n        fi\n        ;;\n    *)\n        echo \"Usage:\"\n        echo \"  source toolchain-switcher.sh list           # List available versions\"\n        echo \"  source toolchain-switcher.sh current        # Show current version\"\n        echo \"  source toolchain-switcher.sh switch 4.9.4   # Switch to version\"\n        ;;\nesac\n```\n仅在当前终端中一次性有效","categories":["嵌入式(Linux开发)"]},{"title":"FreeRTOS 任务、任务列表、任务切换和任务间通信","url":"/2025/04/02/RTOS任务基础/","content":"# 任务\n## 任务状态\n- 运行态(Running)\n    + 任务当前正在 CPU 上执行\n    + 在单核系统中，同时只有一个任务处于运行态\n    + 任务只有在调度器（Scheduler）选择它执行时，才会进入运行态\n- 就绪态（Ready）\n    + 任务已经具备执行条件，但由于 CPU 资源被其他更高优先级任务占用，它暂时无法运行\n    + 任务处于就绪列表（Ready List），等待 FreeRTOS 调度它运行\n    + 当更高优先级任务阻塞或时间片结束，调度器可能会让它进入运行态\n- 阻塞态（Blocked）\n    + 任务正在等待某个事件（如 `vTaskDelay`、信号量、消息队列、事件组等），暂时无法运行\n    + 任务在等待事件时会从就绪态转换到 阻塞态，避免占用 CPU 资源\n    + 当等待的事件发生后（如 信号量释放、消息到达、延时时间结束），任务会转换回 就绪态\n- 挂起态（Suspended）\n    + 任务被显式挂起（使用 `vTaskSuspend()`），不会被调度执行\n    + 任务不会自动恢复，必须调用 `vTaskResume()` 或 `vTaskResumeFromISR()` 才能恢复运行\n    + 与阻塞态不同，挂起任务不会因为外部事件自动恢复\n\n![task状态转换图](/images/rtos/task_1.png)\n\n## 任务优先级\nFreeRTOS 任务的优先级用一个整数表示，数值越大，优先级越高。默认情况下，FreeRTOS 的最低优先级是 0，最大优先级由 `configMAX_PRIORITIES` 定义（通常在 `FreeRTOSConfig.h` 中配置）。\n\n## 任务调度方式\n- 抢占式调度\n- 时间片调度\n- 协程式调度（已基本弃用）\n### 抢占式调度\n即高优先级任务抢占低优先级任务。当高优先级任务进入就绪态，调度器会立刻*抢占*低优先级任务，并切换到高优先级任务执行。只有当优先级高的任务发生阻塞或者被挂起，低优先级的任务才可以运行。\n\n### 时间片调度\n相同优先级的任务采用时间片轮转。若多个任务拥有相同优先级，FreeRTOS 默认使用时间片轮转调度，每个任务轮流执行一个时间片（依赖于 `configUSE_TIME_SLICING`），即调度器会在每一次时间片之后切换任务，CPU轮流运行优先级相同的任务。\n\n### 任务控制块（TCB，Task Control Block）\nTCB为一结构体：\n```\ntypedef struct tskTaskControlBlock {\n    volatile StackType_t *pxTopOfStack;  // 任务栈指针\n    ListItem_t xStateListItem;          // 任务在就绪、阻塞等列表中的位置\n    StackType_t *pxStack;               // 任务栈的起始地址\n    char pcTaskName[configMAX_TASK_NAME_LEN]; // 任务名称\n    UBaseType_t uxPriority;             // 任务优先级\n    ...\n} tskTCB;\n\n```\n\n### 任务栈\n动态方式创建任务时，系统会自动从系统heap中分配一块内存作为任务的栈空间：\n```\nBaseType_t xTaskCreate( TaskFunction_t pxTaskCode,\n                        const char * const pcName,\n                        const configSTACK_DEPTH_TYPE usStackDepth,\n                        void * const pvParameters,\n                        UBaseType_t uxPriority,\n                        TaskHandle_t * const pxCreatedTask)\n```\n`usStackDepth`即为栈大小，以字(32位)为单位（非字节）。\n\n## API函数\n- `xTaskCreate()`：动态创建任务\n- `xTaskCreateStatic()`： 静态创建任务\n- `xTaskCreateRestricted()`： 动态创建使用 MPU 限制的任务\n- `xTaskCreateRestrictedStatic()`： 静态创建使用 MPU 限制的任务\n- `vTaskDelete()`： 删除任务\n### xTaskCreate()\n`FreeRTOSConfig.h`中需要将`configSUPPORT_DYNAMIC_ALLOCATION`配置为`1`\n```\nBaseType_t xTaskCreate(\n            TaskFunction_t pxTaskCode,\n            const char * const pcName,\n            const configSTACK_DEPTH_TYPE usStackDepth,\n            void * const pvParameters,\n            UBaseType_t uxPriority,\n            TaskHandle_t * const pxCreatedTask);\n```\n- `pxTaskCode` 指向任务函数的指针\n- `pcName` 任务名，最大长度为 configMAX_TASK_NAME_LEN\n- `usStackDepth` 任务堆栈大小，单位：字（注意，单位不是字节）\n- `pvParameters` 传递给任务函数的参数\n- `uxPriority` 任务优先级，最大值为(configMAX_PRIORITIES-1)\n- `pxCreatedTask` 任务句柄，任务成功创建后，会返回任务句柄。任务句柄就\n是任务的任务控制块\n\n返回值：\n- `pdPASS` 任务创建成功\n- `errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY` 内存不足，任务创建失败\n\n### xTaskCreateStatic()\n`FreeRTOSConfig.h`中需要将`configSUPPORT_STATIC_ALLOCATION`配置为`1`\n```\nTaskHandle_t xTaskCreateStatic(\n           TaskFunction_t pxTaskCode,\n           const char * const pcName,\n           const uint32_t ulStackDepth,\n           void * const pvParameters,\n           UBaseType_t uxPriority,\n           StackType_t * const puxStackBuffer,\n           StaticTask_t * const pxTaskBuffer);\n ```\n 和动态分配基本一致，不同在于：\n- `puxStackBuffer` 任务栈指针，内存由用户分配提供\n- `pxTaskBuffer` 任务控制块指针，内存由用户分配提供\n\n返回值：\n- `NULL` 用户没有提供相应的内存，任务创建失败\n- `其他值` 任务句柄，任务创建成功\n\n### xTaskCreateRestricted()\n用于使用动态的方式创建受 MPU 保护的任务，任务的任务控制块以及任务的栈空\n间所需的内存，均由 FreeRTOS 从 FreeRTOS 管理的堆中分配，若使用此函数，需要将宏`configSUPPORT_DYNAMIC_ALLOCATION``和宏portUSING_MPU_WRAPPERS` 同时配置为 `1`。此函数创建的任务会立刻进入就绪态，由任务调度器调度运行。\n```\nBaseType_t xTaskCreateRestricted(\n            const TaskParameters_t * const pxTaskDefinition,\n            TaskHandle_t * pxCreatedTask);\n```\n- `pxTaskDefinition` 指向任务参数结构体的指针，建结构体中包含任务函数、任\n务名、任务优先级等任务参数\n- `pxCreadedTask` 任务句柄，任务成功创建后，会返回任务句柄。任务句柄就\n是任务的任务控制块\n\n### vTaskDelete()\n数用于删除已被创建的任务，被删除的任务将被从就绪态任务列表、阻塞态任务列表、挂起态任务列表和事件列表中移除.\n\n*注意*：空闲任务会负责释放被删除任务中由系统分配的内存，但是由用户在任务删除前申请的内存，则需要由用户在任务被删除前提前释放，否则将导致内存泄露。\n\n若使用此函数，需要在`FreeRTOSConfig.h`文件中将宏`INCLUDE_vTaskDelete`配置为 `1`。\n\n```\nvoid vTaskDelete(TaskHandle_t xTaskToDelete);\n```\n- `xTaskToDelete` 待删除任务的任务句柄\n\n### vTaskSuspend()\n挂起任务\n\n### vTaskResume()\n恢复被挂起的任务\n`vTaskResumeFromISR()`可用于在中断中恢复被挂起的任务。\n\n## 注意事项\n1. FreeRTOS 任务函数不允许返回，因此`void task1(void *pvParameters)`中`task`的具体实现必须包含在`while(1)`中，否则会触发异常（HardFault 或任务栈溢出）\n2. 任务中的延时不能用裸机时的`delay_ms`或`delay_us`，要用`vTaskDelay()`。该函数按照给定的滴答数延迟任务。任务保持阻塞的实际时间取决于滴答频率 。常量`portTICK_PERIOD_MS`可用于根据滴答频率计算实际时间：\n```\nvoid vTaskFunction( void * pvParameters )\n{\n    /* Block for 500ms. */\n    const TickType_t xDelay = 500 / portTICK_PERIOD_MS;\n\n    for( ;; )\n    {\n        /* Simply toggle the LED every 500ms, blocking between each toggle. */\n        vToggleLED();\n        vTaskDelay( xDelay );\n    }\n}\n```\n该函数通过阻塞的方式来进行延时，因此`vTaskDelay()`不能很好的控制周期性任务的频率，因为途径代码的路径和其他任务/中断会影响`vTaskDelay()`被调用的频率，久而久之会影响周期性任务的触发。请参阅 `vTaskDelayUntil()`，了解设计用于方便 固定频率执行的替代 API 函数。此函数指定调用任务应取消阻塞的绝对时间（而非相对时间）来实现这一点 。\n\n# 列表(List)\n## 定义\n列表（List） 是一个非常核心的数据结构，主要用于管理各种内核对象的状态和优先级排序，比如就绪任务、延时任务、阻塞任务等。FreeRTOS 的调度器、延时机制、同步机制（如信号量）都依赖于列表来实现。\n```\n/* 双向链表 */\ntypedef struct xLIST_ITEM\n{\n    TickType_t xItemValue;\n    struct xLIST_ITEM *pxNext;\n    struct xLIST_ITEM *pxPrevious;\n    void *pvOwner;\n    void *pvContainer;\n} ListItem_t;\n\ntypedef struct xLIST\n{\n    UBaseType_t uxNumberOfItems;\n    ListItem_t *pxIndex;\n    ListItem_t xListEnd;  // 哨兵节点，值最大\n} List_t;\n```\n\n## 作用\n1. 任务调度：就绪列表（Ready List）\n- FreeRTOS 会根据任务优先级把就绪任务插入对应的列表（每个优先级一个 List）。\n- 调度器从最高优先级的列表中选出第一个任务来运行。\n\n2. 任务延时：延时列表（Delay List）\n- 当任务调用 vTaskDelay() 等函数后，会被放入延时列表，列表按照时间排序（Tick 值）。\n- 每个系统节拍（tick）检查列表，时间到了就移回就绪列表。\n\n3. 阻塞管理：等待列表（例如队列、信号量）\n- 当任务在等待某些资源时（比如消息队列、信号量），会被挂入等待列表中。\n- 当资源可用时，从列表中唤醒一个或多个任务。\n\n## API\n- `vListInitialise()`: 初始化一个 List。\n- `vListInitialiseItem()`: 初始化一个 ListItem。\n- `vListInsert()`: 插入元素到列表中（按 xItemValue 排序）。\n- `vListInsertEnd()`: 插入到列表末尾。\n- `uxListRemove()`: 从列表中删除一个项。\n\n# 任务切换\n## 基本概念\nOS内核中的任务切换有两种触发方式：\n1. 应用程序通过SVC指令触发\n2. SysTick周期性中断\n但是如果有IRQ请求在SysTick中断前产生，SysTick就可能抢占IRQ，导致IRQ被延迟处理，影响RTOS的实时性并导致Usage Fault.\n## PendSV\nPendSV 全称是 \"Pendable Service Call\"，是 Cortex-M 系列处理器（比如 STM32）特有的一个系统异常，用于延迟处理的一种软件中断。\n- “Pend” 表示它是可以“挂起”的。\n- 它的优先级可以被设置为最低，确保只有当别的高优先级中断都处理完之后才会执行。\n\nPendSV 是 FreeRTOS 实现任务上下文切换（context switch）的关键机制，具体而言：\n1. 执行任务切换：当 FreeRTOS 决定要从一个任务切换到另一个任务时（比如发生了任务阻塞、任务优先级发生变化等），不会立即切换，而是设置一个“请求切换任务”的标志，让 PendSV 异常触发，延迟到安全时机再做真正的上下文切换。\n\n![PendSV中执行任务切换](/images/rtos/pendsv_1.png)\n\n2. 保护上下文切换不被打断：PendSV 的优先级设置为最低，意味着它执行的时候不会打断别的中断，保证了上下文切换过程是原子且稳定的。\n\n## 任务切换的本质\n保存->切换->恢复->跳转\n```\n__asm void xPortPendSVHandler( void )\n{\n    extern uxCriticalNesting;\n    extern pxCurrentTCB;\n    extern vTaskSwitchContext;\n\n/* *INDENT-OFF* */\n    PRESERVE8\n\n    /* 从 PSP（进程堆栈指针）获取当前任务的栈顶指针到 r0，即当前任务栈的位置 */\n    mrs r0, psp\n    isb     /* 清洗流水线，确保指令顺序执行完成 */\n    \n    /* 加载TCB地址到R3，再取出TCB到R2 */\n    ldr r3, =pxCurrentTCB\n    ldr r2, [ r3 ]\n\n    /* 检查是否启用了浮点协处理器（FPU） */\n    /* 如果启用，将高位VFQ寄存器压栈，防止浮点任务之间干扰 */\n    tst r14, #0x10\n    it eq\n    vstmdbeq r0!, {s16-s31}\n\n    /* 保存核心寄存器 */\n    stmdb r0!, {r4-r11, r14}\n\n    /* 将新栈顶保存至TCB，更新栈顶 */\n    str r0, [ r2 ]\n\n    /* 1. 暂存R0、R3 */\n    /* 2.设置basepri，屏蔽低优先级中断，防止上下文切换被打断 */\n    /* 3.调用vTaskSwitchContext(),即调度器，更新TCB至新任务 */\n    /* 4.取消中断屏蔽 */\n    stmdb sp!, {r0, r3}\n    mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY\n    msr basepri, r0\n    dsb\n    isb\n    bl vTaskSwitchContext\n    mov r0, #0\n    msr basepri, r0\n    ldmia sp!, {r0, r3}\n\n    /* 获取新任务的TCB至R1，再获取新任务的栈顶地址至R0 */\n    ldr r1, [ r3 ]\n    ldr r0, [ r1 ]\n\n    /* 恢复核心寄存器 */\n    ldmia r0!, {r4-r11, r14}\n\n    /* 检查是否启用了浮点协处理器（FPU） */\n    /* 如果启用，将高位VFQ寄存器出栈 */\n    tst r14, #0x10\n    it eq\n    vldmiaeq r0!, {s16-s31}\n\n    /* 设置新的堆栈指针 */\n    msr psp, r0\n    isb\n\n    #ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata */\n        #if WORKAROUND_PMU_CM001 == 1\n            push { r14 }\n            pop { pc }\n            nop\n        #endif\n    #endif\n\n    /* 返回新任务的执行地址 */\n    bx r14\n/* *INDENT-ON* */\n}\n```\n\n# 任务间通信\n## 队列(Queue)\n- FIFO（先进先出）\n- 既能同步（阻塞），又能传数据\n- 任务和中断都可以用\n- 可设长度 N，缓存多个元素\n\n常见用法：\n- 从中断向任务发送传感器数据\n- 一个任务给另一个任务派发命令\n- UART/ADC驱动中，任务读取缓冲区数据\n\n即“不仅要通知，还要带点东西”：\n```\ntypedef struct {\n    uint8_t cmd;\n    uint16_t value;\n} Message_t;\n\nxQueueSend(xQueue, &msg, portMAX_DELAY);\nxQueueReceive(xQueue, &msg, portMAX_DELAY);\n```\n\n## 队列集(Queue Set)\n多个队列的集合，用于处理单个队列只能传输同一类型数据的情况，可在多个队列/信号量之间选择哪个先有数据/事件发生，避免无效率的轮询。\n\n常见用法：\n- 一个任务等待多个外设的输入（例如：UART1 / UART2 / CAN 同时接收）\n- 管理多个任务发来的指令队列，集中处理\n\n即“有很多输入源，我想让一个任务来监听它们，并优先处理哪个先有数据”\n```\nxQueueSelectFromSet(xQueueSet, portMAX_DELAY); // 等哪个先来\n```\n\n## 信号量(Semaphore)\n普通信号量分为Binary Semaphore和Counting Semaphore，都用于任务同步和中断通知，本身并不传输数据，类似于一个信号灯。\n\n常见用法：\n- 中断服务程序用 `xSemaphoreGiveFromISR()` 通知任务去处理数据\n- 任务 A 通知任务 B 某件事完成\n- 控制允许 N 个任务并发访问某资源（计数型）\n\n中断通知任务下，二值信号量的工作机制为：\n1. 任务A等待某件事发生，于是它调用：\n```\nxSemaphoreTake(xSemaphore, portMAX_DELAY);\n```\n并且任务A状态变为**阻塞**，直到信号量更新或超时\n\n2. 某个中断发生后，ISR内调用\n```\nxSemaphoreGiveFromISR(xSemaphore, &xHigherPriorityTaskWoken);\n```\n通过信号量发出信号，告知任务A期所期望的事件已经到达\n\n3. FreeRTOS检测到信号到达，任务A由阻塞变为就绪\n\n把信号量看成门铃：\n1. 任务按下 `Take()` 就是“等门铃响”。\n2. 中断调用 `Give()` 就是“按门铃”。\n3. 门铃一响，任务就醒了，去执行它的事情。\n\n## 互斥信号量(Mutex Semaphore)\n保护共享资源，防止多个任务同时访问。互斥信号量基于信号量实现，但只能由拥有者释放，支持优先级继承（防止优先级反转）。\n\n常见用法：\n- 多任务访问串口、SPI、LCD等，避免同一硬件被多任务使用\n- 避免数据竞争\n\n即“我只想让一个任务进入临界区，并防止资源冲突”\n```\nxSemaphoreTake(xMutex, portMAX_DELAY);\nLCD_Print(\"Hello\");  // 临界区\nxSemaphoreGive(xMutex);\n```\n\n## 对比\n假设有个任务控制打印机，有多个任务要发打印请求：\n- 队列：多个任务传“打印任务结构体”给打印机任务\n- 队列集：多个来源（如 GUI、网络、中断）发任务 → 打印任务监听哪个先到\n- 信号量：中断来了发一个信号量通知任务“有数据了”\n- 互斥信号量：多个任务打印时共享串口 → 用互斥锁保护 printf()","categories":["嵌入式(RTOS开发)"]},{"title":"Linux SPI驱动通用框架和编写细节","url":"/2025/04/02/LinuxSPI/","content":"## 设备树\n1. 追加节点：\n需要确保UART2节点为`disabled`，因IO占用\n```\n/* Note: to enable ecspi3, uart2 node in imx6ul-14x14-evk.dtsi must be disabled */\n&ecspi3 {\n\tfsl,spi-num-chipselects = <1>;\n\tcs-gpios = <&gpio1 20 GPIO_ACTIVE_LOW>;\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_ecspi3>;\n\tstatus = \"okay\";\n\n\tspidev: icm20608@0 {\n\t\tcompatible = \"alientek,icm20608\";\n\t\tspi-max-frequency = <8000000>;\n\t\treg = <0>;\n\t};\n};\n```\n## 驱动\n1. 创建of_match_table，匹配设备树\n```\nstatic const struct of_device_id icm20608_of_match[] = {\n    { .compatible = \"alientek,icm20608\" },\n    { /* Sential */ }\n};\n```\n2. 创建`spi_driver`\n```\nstatic struct spi_driver icm20608_driver = {\n    .driver = {\n        .owner = THIS_MODULE,\n        .name = \"icm20608\",\n        .of_match_table = icm20608_of_match,\n    },\n    .probe = icm20608_probe,\n    .remove = icm20608_remove,\n};\n```\n3. 填充`probe`和`remove`：\n```\nstatic int icm20608_probe(struct spi_device *spi)\n{\n    printk(\"SPI driver and DTS match OK\\r\\n\");\n\n    if (icm20608dev.major){\n        icm20608dev.devid = MKDEV(icm20608dev.major, 0);\n        register_chrdev_region(icm20608dev.devid, ICM20608_CNT, ICM20608_NAME);\n    } else {\n        alloc_chrdev_region(&icm20608dev.devid, 0, ICM20608_CNT, ICM20608_NAME);\n        icm20608dev.major = MAJOR(icm20608dev.devid);\n    }\n    printk(\"device reg ok, major = %d\\r\\n\", icm20608dev.major);\n\n    icm20608dev.cdev.owner = THIS_MODULE;\n    cdev_init(&icm20608dev.cdev, &icm20608_fops);\n    cdev_add(&icm20608dev.cdev, icm20608dev.devid, ICM20608_CNT);\n\n    icm20608dev.class = class_create(ICM20608_NAME);\n\n    icm20608dev.device = device_create(icm20608dev.class, NULL, icm20608dev.devid, NULL, ICM20608_NAME);\n\n    /* SPI初始化 */\n    spi->mode = SPI_MODE_0; /* MODE0:CPOL = 0, CPHA = 0 */\n    spi_setup(spi);\n    icm20608dev.private_data = spi;     /* 保存spi_driver至结构体 */\n\n    icm20608_reginit();\n    return 0;\n}\n```\n```\nstatic void icm20608_remove(struct spi_device *spi)\n{\n    cdev_del(&icm20608dev.cdev);\n    unregister_chrdev_region(icm20608dev.devid, ICM20608_CNT);\n\n    device_destroy(icm20608dev.class, icm20608dev.devid);\n    class_destroy(icm20608dev.class);\n}\n```\n\n4. 完善接收和发送函数\n```\nstatic int icm20608_read_regs(struct icm20608_dev *dev, u8 reg, void *buf, int len)\n{\n    int ret = -1;\n    struct spi_device *spi = (struct spi_device *)dev->private_data;\n\n    /* tx buffer */\n    unsigned char *txdata = kmalloc(1, GFP_KERNEL);\n    if (!txdata)\n        return -ENOMEM;\n    txdata[0] = reg | 0x80;\n\n    /* rx buffer */\n    /* 待接收数据长度为len，但SPI为全双工，第一次向从机发送准备读取消息时从机返回空数据，所以需要加一 */\n    unsigned char *rxdata = kmalloc(len + 1, GFP_KERNEL);\n\n    struct spi_transfer t = {\n        .tx_buf = txdata,\n        .rx_buf = rxdata,\n        .len = len + 1,\n    };\n\n    struct spi_message m;\n    spi_message_init(&m);\n    spi_message_add_tail(&t, &m);    \n\n    ret = spi_sync(spi, &m);\n    if (ret){\n        return ret;\n    }\n    \n    memcpy(buf, &rxdata[1], len);\n\n    return 0;\n}\n\nstatic s32 icm20608_write_regs(struct icm20608_dev *dev, u8 reg, u8 *buf, u8 len)\n{\n    int ret = -1;\n    struct spi_device *spi = (struct spi_device *)dev->private_data;\n\n    unsigned char *txdata = kmalloc(len + 1, GFP_KERNEL);\n    txdata[0] = reg & 0x7F;\n    memcpy(&txdata[1], buf, len);\n\n    struct spi_transfer t = {\n        .tx_buf = txdata,\n        .len = len + 1,\n    };\n\n    struct spi_message m;\n\n    spi_message_init(&m);\n    spi_message_add_tail(&t, &m);    \n\n    ret = spi_sync(spi, &m);\n    if (ret){\n        return ret;\n    }\n    return 0;\n}\n```\n*注意*：读取寄存器消息时不能将两条消息分开发送，因为ICM20608要求在读取数据时连续发送数据，即发送读取命令后立即接收从机返回的消息，CS片选信号在这期间始终拉低。如果分开两条信息发送，比如：\n```\n    struct spi_transfer t[2] = {\n        {\n            .tx_buf = txdata,\n            .len = 1,\n        },\n        {\n            .rx_buf = rxdata,\n            .len = len,\n        },\n    };\n\n    ...\n\n    spi_message_add_tail(&t[0], &m);\n    spi_message_add_tail(&t[1], &m);\n```\n这么做会导致SPI在发送`t[0]`和`t[1]`时在两条消息中间短暂拉高CS，导致SPI丢失数据。\n\n## 完整驱动\n```\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/libata.h>   /* 新版kernel不再支持ide.h */\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/gpio.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/of_gpio.h>\n#include <linux/semaphore.h>\n#include <linux/timer.h>\n#include <linux/i2c.h>\n#include <linux/spi/spi.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_gpio.h>\n#include <linux/platform_device.h>\n#include <asm/mach/map.h>\n#include <asm/uaccess.h>\n#include <asm/io.h>\n#include \"icm20608reg.h\"\n\n#define ICM20608_CNT    1\n#define ICM20608_NAME   \"icm20608\"\n\nstruct icm20608_dev {\n    dev_t devid;\n    struct cdev cdev;\n    struct class *class;\n    struct device *device;\n    struct device_node *nd;\n    int major;\n    void *private_data;\n    int cs_gpio;\n\tsigned int gyro_x_adc;\t\t/* 陀螺仪X轴原始值 \t */\n\tsigned int gyro_y_adc;\t\t/* 陀螺仪Y轴原始值\t\t*/\n\tsigned int gyro_z_adc;\t\t/* 陀螺仪Z轴原始值 \t\t*/\n\tsigned int accel_x_adc;\t\t/* 加速度计X轴原始值 \t*/\n\tsigned int accel_y_adc;\t\t/* 加速度计Y轴原始值\t*/\n\tsigned int accel_z_adc;\t\t/* 加速度计Z轴原始值 \t*/\n\tsigned int temp_adc;\t\t/* 温度原始值 \t\t\t*/\n};\n\nstruct icm20608_dev icm20608dev;\n\nstatic int icm20608_open(struct inode *inode, struct file *filp);\nstatic ssize_t icm20608_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt);\nstatic int icm20608_release(struct inode *inode, struct file *filp);\nstatic int icm20608_read_regs(struct icm20608_dev *dev, u8 reg, void *buf, int len);\nstatic s32 icm20608_write_regs(struct icm20608_dev *dev, u8 reg, u8 *buf, u8 len);\nstatic unsigned char icm20608_read_onereg(struct icm20608_dev *dev, u8 reg);\nstatic void icm20608_write_onereg(struct icm20608_dev *dev, u8 reg, u8 value);\nvoid icm20608_readdata(struct icm20608_dev *dev);\nvoid icm20608_reginit(void);\nstatic int icm20608_probe(struct spi_device *spi);\nstatic void icm20608_remove(struct spi_device *spi);\n\n\nstatic int icm20608_open(struct inode *inode, struct file *filp)\n{\n    filp->private_data = &icm20608dev;\n    return 0;\n}\n\nstatic ssize_t icm20608_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)\n{\n    signed int data[7];\n    long err = 0;\n    struct icm20608_dev *dev = filp->private_data;\n\n\ticm20608_readdata(dev);\n\tdata[0] = dev->gyro_x_adc;\n\tdata[1] = dev->gyro_y_adc;\n\tdata[2] = dev->gyro_z_adc;\n\tdata[3] = dev->accel_x_adc;\n\tdata[4] = dev->accel_y_adc;\n\tdata[5] = dev->accel_z_adc;\n\tdata[6] = dev->temp_adc;\n\terr = copy_to_user(buf, data, sizeof(data));\n\treturn 0;\n}\n\nstatic int icm20608_release(struct inode *inode, struct file *filp)\n{\n    return 0;\n}\n\nstatic int icm20608_read_regs(struct icm20608_dev *dev, u8 reg, void *buf, int len)\n{\n    int ret = -1;\n    struct spi_device *spi = (struct spi_device *)dev->private_data;\n\n    /* tx buffer */\n    unsigned char *txdata = kmalloc(1, GFP_KERNEL);\n    if (!txdata)\n        return -ENOMEM;\n    txdata[0] = reg | 0x80;\n\n    /* rx buffer */\n    /* 待接收数据长度为len，但SPI为全双工，第一次向从机发送准备读取消息时从机返回空数据，所以需要加一 */\n    unsigned char *rxdata = kmalloc(len + 1, GFP_KERNEL);\n\n    struct spi_transfer t = {\n        .tx_buf = txdata,\n        .rx_buf = rxdata,\n        .len = len + 1,\n    };\n\n    struct spi_message m;\n    spi_message_init(&m);\n    spi_message_add_tail(&t, &m);    \n\n    ret = spi_sync(spi, &m);\n    if (ret){\n        return ret;\n    }\n    \n    memcpy(buf, &rxdata[1], len);\n\n    return 0;\n}\n\nstatic s32 icm20608_write_regs(struct icm20608_dev *dev, u8 reg, u8 *buf, u8 len)\n{\n    int ret = -1;\n    struct spi_device *spi = (struct spi_device *)dev->private_data;\n\n    unsigned char *txdata = kmalloc(len + 1, GFP_KERNEL);\n    txdata[0] = reg & 0x7F;\n    memcpy(&txdata[1], buf, len);\n\n    struct spi_transfer t = {\n        .tx_buf = txdata,\n        .len = len + 1,\n    };\n\n    struct spi_message m;\n\n    spi_message_init(&m);\n    spi_message_add_tail(&t, &m);    \n\n    ret = spi_sync(spi, &m);\n    if (ret){\n        return ret;\n    }\n    return 0;\n}\n\nstatic unsigned char icm20608_read_onereg(struct icm20608_dev *dev, u8 reg)\n{\n    u8 data = 0;\n    icm20608_read_regs(dev, reg, &data, 1);\n    return data;\n}\n\nstatic void icm20608_write_onereg(struct icm20608_dev *dev, u8 reg, u8 value)\n{\n    u8 buf = value;\n    icm20608_write_regs(dev, reg, &buf, 1);\n}\n\nvoid icm20608_readdata(struct icm20608_dev *dev)\n{\n\tunsigned char data[14] = { 0 };\n\ticm20608_read_regs(dev, ICM20_ACCEL_XOUT_H, data, 14);\n\n\tdev->accel_x_adc = (signed short)((data[0] << 8) | data[1]); \n\tdev->accel_y_adc = (signed short)((data[2] << 8) | data[3]); \n\tdev->accel_z_adc = (signed short)((data[4] << 8) | data[5]); \n\tdev->temp_adc    = (signed short)((data[6] << 8) | data[7]); \n\tdev->gyro_x_adc  = (signed short)((data[8] << 8) | data[9]); \n\tdev->gyro_y_adc  = (signed short)((data[10] << 8) | data[11]);\n\tdev->gyro_z_adc  = (signed short)((data[12] << 8) | data[13]);\n}\n\nvoid icm20608_reginit(void)\n{\n\tu8 value = 0;\n\t\n\ticm20608_write_onereg(&icm20608dev, ICM20_PWR_MGMT_1, 0x80);\n\tmdelay(50);\n\ticm20608_write_onereg(&icm20608dev, ICM20_PWR_MGMT_1, 0x01);\n\tmdelay(50);\n\n\tvalue = icm20608_read_onereg(&icm20608dev, ICM20_WHO_AM_I);\n\tprintk(\"ICM20608 ID = %#X\\r\\n\", value);\t\n\n\ticm20608_write_onereg(&icm20608dev, ICM20_SMPLRT_DIV, 0x00); \t/* 输出速率是内部采样率\t\t\t\t\t*/\n\ticm20608_write_onereg(&icm20608dev, ICM20_GYRO_CONFIG, 0x18); \t/* 陀螺仪±2000dps量程 \t\t\t\t*/\n\ticm20608_write_onereg(&icm20608dev, ICM20_ACCEL_CONFIG, 0x18); \t/* 加速度计±16G量程 \t\t\t\t\t*/\n\ticm20608_write_onereg(&icm20608dev, ICM20_CONFIG, 0x04); \t\t/* 陀螺仪低通滤波BW=20Hz \t\t\t\t*/\n\ticm20608_write_onereg(&icm20608dev, ICM20_ACCEL_CONFIG2, 0x04); /* 加速度计低通滤波BW=21.2Hz \t\t\t*/\n\ticm20608_write_onereg(&icm20608dev, ICM20_PWR_MGMT_2, 0x00); \t/* 打开加速度计和陀螺仪所有轴 \t\t\t\t*/\n\ticm20608_write_onereg(&icm20608dev, ICM20_LP_MODE_CFG, 0x00); \t/* 关闭低功耗 \t\t\t\t\t\t*/\n\ticm20608_write_onereg(&icm20608dev, ICM20_FIFO_EN, 0x00);\t\t/* 关闭FIFO\t\t\t\t\t\t*/\n}\n\nstatic const struct of_device_id icm20608_of_match[] = {\n    { .compatible = \"alientek,icm20608\" },\n    { /* Sential */ }\n};\n\nstatic struct file_operations icm20608_fops = {\n    .owner = THIS_MODULE,\n    .open = icm20608_open,\n    .read = icm20608_read,\n    .release = icm20608_release,\n};\n\nstatic int icm20608_probe(struct spi_device *spi)\n{\n    printk(\"SPI driver and DTS match OK\\r\\n\");\n\n    if (icm20608dev.major){\n        icm20608dev.devid = MKDEV(icm20608dev.major, 0);\n        register_chrdev_region(icm20608dev.devid, ICM20608_CNT, ICM20608_NAME);\n    } else {\n        alloc_chrdev_region(&icm20608dev.devid, 0, ICM20608_CNT, ICM20608_NAME);\n        icm20608dev.major = MAJOR(icm20608dev.devid);\n    }\n    printk(\"device reg ok, major = %d\\r\\n\", icm20608dev.major);\n\n    icm20608dev.cdev.owner = THIS_MODULE;\n    cdev_init(&icm20608dev.cdev, &icm20608_fops);\n    cdev_add(&icm20608dev.cdev, icm20608dev.devid, ICM20608_CNT);\n\n    icm20608dev.class = class_create(ICM20608_NAME);\n\n    icm20608dev.device = device_create(icm20608dev.class, NULL, icm20608dev.devid, NULL, ICM20608_NAME);\n\n    spi->mode = SPI_MODE_0; /* MODE0:CPOL = 0, CPHA = 0 */\n    spi_setup(spi);\n    icm20608dev.private_data = spi;\n\n    icm20608_reginit();\n    return 0;\n}\n\nstatic void icm20608_remove(struct spi_device *spi)\n{\n    cdev_del(&icm20608dev.cdev);\n    unregister_chrdev_region(icm20608dev.devid, ICM20608_CNT);\n\n    device_destroy(icm20608dev.class, icm20608dev.devid);\n    class_destroy(icm20608dev.class);\n}\n\nstatic struct spi_driver icm20608_driver = {\n    .driver = {\n        .owner = THIS_MODULE,\n        .name = \"icm20608\",\n        .of_match_table = icm20608_of_match,\n    },\n    .probe = icm20608_probe,\n    .remove = icm20608_remove,\n};\n\nmodule_spi_driver(icm20608_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"aki\");\n```","categories":["嵌入式(Linux开发)"]},{"title":"Linux I2C驱动通用框架和编写细节","url":"/2025/04/01/LinuxI2C/","content":"## I2C子系统架构\nI2C子系统采用分层设计：\n- I2C核心层\n    + 提供总线协议实现、设备注册/注销、总线通信接口（如`i2c_transfer`）\n    + `struct i2c_adapter`：抽象化的I2C控制器\n    + `struct i2c_client`：连接到总线的I2C从机\n    + 管理适配器和设备，提供用户空间接口(`/dev/i2c-*`)\n- I2C总线驱动\n    + 控制物理I2C控制器硬件，实现底层时序和寄存器控制\n    + 填充`struct i2c_algorithm`，底层数据收发\n    + 注册适配器(`i2c_add_adapter`)，通常和平台设备驱动结合，依赖设备树\n- I2C设备驱动\n    + 驱动特定的I2C设备\n    + `struct i2c_driver`：定义驱动名称、设备ID表、`probe`和`remove`方法\n    + `struct i2c_client`：保存设备地址、适配器指针等\n\n## 设备树配置\n1. 定义I2C控制器节点，通常由SoC厂商提供\n2. 在节点下添加I2C从设备，需保证一个从机地址只有一个设备，不能复用\n```\n&i2c1 {\n\tclock-frequency = <100000>;\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_i2c1>;\n\tstatus = \"okay\";\n\n\tmagnetometer@e {\n\t\tcompatible = \"fsl,mag3110\";\n\t\treg = <0x0e>;\n\t\tvdd-supply = <&reg_peri_3v3>;\n\t\tvddio-supply = <&reg_peri_3v3>;\n\t\tposition = <2>;\n\t};\n\n/*\n\tfxls8471@1e {\n\t\tcompatible = \"fsl,fxls8471\";\n\t\treg = <0x1e>;\n\t\tposition = <0>;\n\t\tinterrupt-parent = <&gpio5>;\n\t\tinterrupts = <0 8>;\n\t}; */\n\n    /* I2C从设备 */\n\tap3216c@1e {\n\t\tcompatible = \"alientek,ap3216c\";\n\t\treg = <0x1e>;\n\t};\n};\n```\n\n## 设备驱动\n1. 定义驱动结构体`i2c_driver`\n```\nstatic struct i2c_driver ap3216c_driver = {\n    .probe = ap3216c_probe,\n    .remove = ap3216c_remove,\n    .driver = {\n        .owner = THIS_MODULE,\n        .name = \"ap3216c\",\n        .of_match_table = ap3216c_of_match,\n    },\n};\n```\n2. 实现匹配表（兼容设备树），`{ /* Sential */ }`必须添加\n```\nstatic const struct of_device_id ap3216c_of_match[] = {\n    {.compatible = \"alientek,ap3216c\"},\n    { /* Sential */ }\n};\n```\n3. 实现`probe`函数\n```\nstatic int ap3216c_probe(struct i2c_client *client)\n{\n    printk(\"driver and device has been matched!\\r\\n\");\n    \n    if (ap3216cdev.major){\n        ap3216cdev.devid = MKDEV(ap3216cdev.major, 0);\n        register_chrdev_region(ap3216cdev.devid, AP3216C_CNT, AP3216C_NAME);\n    }else{\n        alloc_chrdev_region(&ap3216cdev.devid, 0, 1, AP3216C_NAME);\n        ap3216cdev.major = MAJOR(ap3216cdev.devid);\n    }\n    printk(\"reg ok, major = %d, minor = %d\\r\\n\", ap3216cdev.major, 0);\n\n    cdev_init(&ap3216cdev.cdev, &ap3216c_fops);\n    cdev_add(&ap3216cdev.cdev, ap3216cdev.devid, AP3216C_CNT);\n\n    ap3216cdev.class = class_create(AP3216C_NAME);\n\n    ap3216cdev.device = device_create(ap3216cdev.class, NULL, ap3216cdev.devid, NULL, AP3216C_NAME);\n\n    ap3216cdev.private_data = client;\n    return 0;\n}\n```\n4. 实现数据传输\ni2c的数据传输采用类似于“填充”的形式，具体为定义一个`i2c_msg`类型的待发送消息`msg`，然后填充`msg`中的`addr`(从机地址)、`flags`(发送/接收标志位)、`buf`(发送/接收缓冲区)和`len`(数据长度)这四个成员变量，最后使用`i2c_transfer()`函数进行发送。\n\n以接收数据为例，先发送目标寄存器地址，然后读取数据：\n```\nstatic int ap3216c_read_regs(struct ap3216c_dev *dev, u8 reg, void *val, int len)\n{\n    int ret;\n    struct i2c_msg msg[2];\n    struct i2c_client *client = (struct i2c_client *)dev->private_data;\n\n    /* fill msg1, send addr signal */\n    msg[0].addr = client->addr;\n    msg[0].flags = 0;   /* send data */\n    msg[0].buf = &reg;  /* TX buffer */\n    msg[0].len = 1;     \n\n    /* fill msg2, read len byte data to val */\n    msg[1].addr = client->addr;\n    msg[1].flags = I2C_M_RD;    /* read data */\n    msg[1].buf = val;\n    msg[1].len = len;\n\n    /* send msg */\n    ret = i2c_transfer(client->adapter, msg, 2);\n    if (ret == 2){\n        ret = 0;\n    }else{\n        printk(\"i2c RD failed = %d reg = %06x led = %d\\r\\n\", ret ,reg, len);\n        ret = -EREMOTEIO;\n    }\n    return ret;\n}\n```\n*注意*：AP3216C要求写数据的时序为：\n![AP3216C Read Protocal](/images/linux/i2c_1.png)\n即发送从机设备地址->发送待读取寄存器地址->重新发送从机设备地址->从机输出待读取寄存器值。但是很显然上面的代码里面没有发送从机设备地址的这条`msg`，这是因为linux底层会根据`msg.addr`来自动处理发送设备地址的这一步操作，我们只需要处理*发送待读取寄存器地址*和*从机输出待读取寄存器值*这两步。\n\n写操作也是类似的：\n![AP3216C Write Protocal](/images/linux/i2c_2.png)\n```\nstatic s32 ap3216c_write_regs(struct ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)\n{\n    u8 b[256];\n    struct i2c_msg msg;\n    struct i2c_client *client = (struct i2c_client *)dev->private_data;\n\n    b[0] = reg;     /* reg addr */\n    memcpy(&b[1], buf, len);    /* copy tx data to b[1] */\n\n    /* fill msg */\n    msg.addr = client->addr;\n    msg.flags = 0;  /* send data */\n    msg.buf = b;    /* tx buffer */\n    msg.len = len + 1;\n\n    /* transfer data */\n    return i2c_transfer(client->adapter, &msg, 1);\n}\n```\nLinux kernel会自动处理发送时序，而且发送数据时不需要再停下来重新发送一遍寄存器地址再等待读取，而是可以连着发送，因此代码把待发送的数据接到了设备地址`b[0]`的后面，也就是`b[1]`里。实际发送时把设备地址和待发送数据合到一条`msg`里发送，长度也就是`len + 1`，即发送数据长度（`len`字节） + 寄存器地址长度（1字节）\n\n5. 注册驱动模块\n```\nmodule_i2c_driver(ap3216c_driver);\n```\n\n## 完整代码\n```\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/libata.h>   /* 新版kernel不再支持ide.h */\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/gpio.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/of_address.h>\n#include <linux/of_gpio.h>\n#include <asm/mach/map.h>\n#include <asm/uaccess.h>\n#include <asm/io.h>\n#include <linux/semaphore.h>\n#include <linux/timer.h>\n#include <linux/of_irq.h>\n#include <linux/irq.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/platform_device.h>\n#include <linux/miscdevice.h>\n#include <linux/input.h>\n#include <linux/i2c.h>\n#include \"ap3216creg.h\"\n\n#define AP3216C_CNT     1\n#define AP3216C_NAME    \"ap3216c\"\n\n/* device dev */\nstruct ap3216c_dev {\n    dev_t devid;\n    struct cdev cdev;\n    struct class *class;\n    struct device *device;\n    struct device_node *nd;\n    int major;\n    void *private_data;\n    unsigned short ir, als, ps;  /* ap3216c reg */\n};\n\nstatic struct ap3216c_dev ap3216cdev;\n\n/* ap3216c read from multipy regs */\nstatic int ap3216c_read_regs(struct ap3216c_dev *dev, u8 reg, void *val, int len)\n{\n    int ret;\n    struct i2c_msg msg[2];\n    struct i2c_client *client = (struct i2c_client *)dev->private_data;\n\n    /* fill msg1, send addr signal */\n    msg[0].addr = client->addr;\n    msg[0].flags = 0;   /* send data */\n    msg[0].buf = &reg;  /* TX buffer */\n    msg[0].len = 1;     \n\n    /* fill msg2, read len byte data to val */\n    msg[1].addr = client->addr;\n    msg[1].flags = I2C_M_RD;    /* read data */\n    msg[1].buf = val;\n    msg[1].len = len;\n\n    /* send msg */\n    ret = i2c_transfer(client->adapter, msg, 2);\n    if (ret == 2){\n        ret = 0;\n    }else{\n        printk(\"i2c RD failed = %d reg = %06x led = %d\\r\\n\", ret ,reg, len);\n        ret = -EREMOTEIO;\n    }\n    return ret;\n}\n\n/* ap3216c write data to reg */\nstatic s32 ap3216c_write_regs(struct ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)\n{\n    u8 b[256];\n    struct i2c_msg msg;\n    struct i2c_client *client = (struct i2c_client *)dev->private_data;\n\n    b[0] = reg;     /* reg addr */\n    memcpy(&b[1], buf, len);    /* copy tx data to b[1] */\n\n    /* fill msg */\n    msg.addr = client->addr;\n    msg.flags = 0;  /* send data */\n    msg.buf = b;    /* tx buffer */\n    msg.len = len + 1;\n\n    /* transfer data */\n    return i2c_transfer(client->adapter, &msg, 1);\n}\n\n/* ap3216c read data from one reg */\nstatic unsigned char ap3216c_read_reg(struct ap3216c_dev *dev, u8 reg)\n{\n    u8 data = 0;\n\n    ap3216c_read_regs(dev, reg, &data, 1);\n    return data;\n}\n\n/* ap3216c write data to one reg */\nstatic void ap3216c_write_reg(struct ap3216c_dev *dev, u8 reg, u8 data)\n{\n    u8 buf = 0;\n    buf = data;\n    ap3216c_write_regs(dev, reg, &buf, 1);\n}\n\n/* read data from ap3216c reg */\nvoid ap3216c_readdata(struct ap3216c_dev *dev)\n{\n    unsigned char i = 0;\n    unsigned char buf[6];\n\n    /* read six regs in cycle */\n    for (i = 0; i < 6; i++)\n    {\n        buf[i] = ap3216c_read_reg(dev, AP3216C_IRDATALOW + i);\n    }\n\n    /* read IR */\n    if ((buf[0] >> 7) == 0x1){  /* IR is invalid */\n        dev->ir = 0;\n    }else{  /* read ir */\n        dev->ir = ((unsigned short)buf[1] << 2) | (buf[0] & 0x03); /* IR*/\n    }\n    /* read ALS */\n    dev->als = ((unsigned short)buf[3] << 8) | buf[2];\n\n    /* read PS */\n    if ((buf[4] >> 6) == 1){\n        dev->ps = 0;\n    }else{\n        dev->ps = (((unsigned short)buf[5] & 0x3F) << 4) | (buf[4] & 0x0F);\n    }\n}\n\n/* ap3216c initialization */\nstatic int ap3216c_open(struct inode *inode, struct file *filp)\n{\n    filp->private_data = &ap3216cdev;\n\n    ap3216c_write_reg(&ap3216cdev, AP3216C_SYSTEMCONG, 0x04);\n    mdelay(50);\n    ap3216c_write_reg(&ap3216cdev, AP3216C_SYSTEMCONG, 0x03);\n\n    return 0;\n}\n\nstatic ssize_t ap3216c_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)\n{\n    short data[3];\n    long err = 0;\n\n    struct ap3216c_dev *dev = (struct ap3216c_dev *)filp->private_data;\n\n    ap3216c_readdata(dev);\n\n    data[0] = dev->ir;\n    data[1] = dev->als;\n    data[2] = dev->ps;\n    err = copy_to_user(buf, data, sizeof(data));\n    return 0;\n} \n\nstatic int ap3216c_release(struct inode *inode, struct file *filp)\n{\n    return 0;\n}\n\nstatic const struct file_operations ap3216c_fops = {\n    .owner = THIS_MODULE,\n    .open = ap3216c_open,\n    .read = ap3216c_read,\n    .release = ap3216c_release,\n};\n\nstatic int ap3216c_probe(struct i2c_client *client)\n{\n    printk(\"driver and device has been matched!\\r\\n\");\n    \n    if (ap3216cdev.major){\n        ap3216cdev.devid = MKDEV(ap3216cdev.major, 0);\n        register_chrdev_region(ap3216cdev.devid, AP3216C_CNT, AP3216C_NAME);\n    }else{\n        alloc_chrdev_region(&ap3216cdev.devid, 0, 1, AP3216C_NAME);\n        ap3216cdev.major = MAJOR(ap3216cdev.devid);\n    }\n    printk(\"reg ok, major = %d, minor = %d\\r\\n\", ap3216cdev.major, 0);\n\n    cdev_init(&ap3216cdev.cdev, &ap3216c_fops);\n    cdev_add(&ap3216cdev.cdev, ap3216cdev.devid, AP3216C_CNT);\n\n    ap3216cdev.class = class_create(AP3216C_NAME);\n\n    ap3216cdev.device = device_create(ap3216cdev.class, NULL, ap3216cdev.devid, NULL, AP3216C_NAME);\n\n    ap3216cdev.private_data = client;\n    return 0;\n}\n\nstatic void ap3216c_remove(struct i2c_client *client)\n{\n    cdev_del(&ap3216cdev.cdev);\n    unregister_chrdev_region(ap3216cdev.devid, AP3216C_CNT);\n\n    device_destroy(ap3216cdev.class, ap3216cdev.devid);\n    class_destroy(ap3216cdev.class);\n}\n\nstatic const struct of_device_id ap3216c_of_match[] = {\n    {.compatible = \"alientek,ap3216c\"},\n    { /* Sential */ }\n};\n\nstatic struct i2c_driver ap3216c_driver = {\n    .probe = ap3216c_probe,\n    .remove = ap3216c_remove,\n    .driver = {\n        .owner = THIS_MODULE,\n        .name = \"ap3216c\",\n        .of_match_table = ap3216c_of_match,\n    },\n};\n\nmodule_i2c_driver(ap3216c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"aki\");\n```","categories":["嵌入式(Linux开发)"]},{"title":"Linux Input设备通用驱动框架","url":"/2025/03/31/LinuxInput设备/","content":"## Input子系统架构\n```\n          +-----------------------+\n          |    用户空间         |\n          |-----------------------|\n          | /dev/input/eventX      |  <-  应用程序通过读取这些设备文件获取输入事件\n          +-----------------------+\n                    ↑\n          +-----------------------+\n          |  Input 子系统      |  <-  提供统一的输入接口\n          +-----------------------+\n                    ↑\n          +-----------------------+\n          |  Input 驱动         |  <-  负责具体输入设备（如键盘、触摸屏）\n          +-----------------------+\n                    ↑\n          +-----------------------+\n          |  硬件（键盘/鼠标等）  |\n          +-----------------------+\n```\n## Input驱动核心数据结构\n### struct input_dev (输入设备)\n```\nstruct input_dev {\n    const char *name;        // 设备名称\n    unsigned long evbit[EV_MAX];  // 支持的事件类型 (如键盘按键、鼠标移动)\n    unsigned long keybit[KEY_MAX];  // 支持的按键\n    unsigned long relbit[REL_MAX];  // 相对坐标事件（鼠标）\n    unsigned long absbit[ABS_MAX];  // 绝对坐标事件（触摸屏）\n    struct input_mt *mt;  // 多点触控支持\n    int (*open)(struct input_dev *dev);   // 设备打开回调\n    int (*close)(struct input_dev *dev);  // 设备关闭回调\n};\n```\n### struct input_event (输入事件)\n```\nstruct input_event {\n    struct timeval time;  // 时间戳\n    __u16 type;          // 事件类型 (EV_KEY, EV_REL, EV_ABS)\n    __u16 code;          // 事件代码 (键值或坐标轴)\n    __s32 value;         // 事件值 (按键按下/释放，坐标值等)\n};\n```\n### struct input_handler (输入处理程序)\n#### input_report_key\n用于向kernel报告按键事件\n```\nvoid input_report_key(struct input_dev *dev, unsigned int code, int value);\n\ncode:按键的键值，如KEY_A表示A键\nvalue: 1:按下，0:释放，2:保持按下\n```\n键值在`include/uapi/linux/input-event-codes.h`中定义\n\n#### input_sync()\n用于同步事件，告知input子系统当前一批输入事件已经结束，可以传递给用户空间\n```\nvoid input_sync(struct input_dev *dev);\n```\n\n## Input设备注册\n### 注册输入设备\n1. 声明`input_dev`\n一般在设备结构体中设置\n```\nstruct xxx_dev {\n    ...\n    struct input_dev *inputdev;\n}\n```\n2. 申请设备\n```\nkeyinputdev.inputdev = input_allocate_device();\nkeyinputdev.inputdev->name = KEYINPUT_NAME;\n```\n`input_allocate_device()`用于申请并初始化一个`input_dev`结构体\n\n3. 设置事件类型\n```\nkeyinputdev.inputdev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\n```\n`evbit`代表设备支持的事件类型：\n- `BIT_MASK(EV_KEY)`：支持按键事件\n- `BIT_MASK(EV_REP)`：支持按键重复，长按时不断触发\n\n\n4. 绑定按键\n告知input子系统这个设备支持某个按键\n```\ninput_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);\n```\n函数原型：\n```\nvoid input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code);\n\ntype：事件类型\ncode：具体的按键/轴/开关代码，包括：\n    EV_KEY 按键事件\n    EV_REL 相对轴事件（鼠标移动、滚轮）\n    EV_ABS 绝对轴事件（触摸屏、操纵杆）\n    EV_SW  开关事件（外设插入检测） \n```\n\n5. 注册设备\n```\n    ret = input_register_device(keyinputdev.inputdev);\n    if (ret) {\n        printk(\"reg input device failed\\r\\n\");\n        return ret;\n    }\n```\n函数原型：\n```\nint input_register_device(struct input_dev *dev);\n```\n卸载时使用`input_unregister_device(keyinputdev.inputdev)`和`input_free_device(keyinputdev.inputdev)`释放input设备\n\n### 触发输入事件\n\n","categories":["嵌入式(Linux开发)"]},{"title":"Linux线程（一）基本概念","url":"/2025/03/31/Linux线程1/","content":"## 基本概念\n- 进程：资源管理的最小单位\n- 线程：程序执行的最小单位\n\n每个进程拥有自己的数据段、代码段和堆栈段。\n\n线程通常叫做轻型的进程，包含独立的栈和CPU寄存器状态。线程是进程的一条执行路径，每个线程共享其所附属进程的所有资源。\n\n线程和进程比起来很小，相对来说线程花费更少的CPU资源。\n\n更形象一点：\n- 进程是资源的管理单位\n    + 进程就像一个工厂，里面有自己的设备（CPU、内存、文件、网络连接等）\n    + 每个工厂（进程）都是独立的，工厂之间不能直接共享设备（但可以通过通信合作）\n- 线程是执行的基本单位\n    + 线程就像工人，他们在工厂（进程）里面工作，负责具体的任务\n    + 一个工厂（进程）可以有多个工人（线程），他们一起工作，提高效率\n- 线程共享进程资源\n    + 工厂里的工人（线程）共用工厂的资源，比如机器（内存、文件、网络等）\n    + 但工人们有自己的工作台（栈），不会互相干扰自己的操作步骤\n- 进程之间是隔离的，线程之间是共享的\n    + 两个工厂（进程）不能随便使用对方的设备（资源隔离）\n    + 但同一个工厂里的工人（线程）可以直接使用工厂的设备（共享资源）\n\n多线程适合任务紧密相关，共享数据的场景；多进程适合任务独立，互不干扰的场景。\n\n## ULT和KLT\n- 用户级线程（User-Level Thread, ULT）\n- 内核级线程（Kernel-Level Thread, KLT）\n\n用户级线程是完全由用户态的线程库管理，操作系统内核并不知道这些线程的存在。\n- 线程管理由用户程序自己负责（就像选手自己决定何时跑、休息）\n- 切换线程时不需要内核介入，上下文切换更快\n- 如果一个线程阻塞，整个进程都会挂起（一个选手倒下，整个队伍都停下）\n- 适合轻量级任务，但不适合I/O密集型任务\n\n内核级线程是由操作系统内核管理的线程，切换线程由内核调度器负责。\n- 内核知道所有线程的存在，并负责调度（裁判决定选手何时跑）\n- 一个线程阻塞不会影响整个进程（一个选手休息，其他人还能继续跑）\n- 线程切换涉及内核态和用户态切换，开销较大\n- 适合多核CPU调度、多线程并发任务，如 I/O 密集型任务","categories":["Linux 线程"]},{"title":"Linux Platform驱动通用框架","url":"/2025/03/28/LinuxPlatform驱动通用框架/","content":"## 设备树\nPlatform驱动需要读取设备树中的`compatible`信息用于`of_match_table`进行匹配：\n```\n/* Custom LED pinctrl */\ngpioled {\n\t#address-cells = <1>;\n\t#size-cells = <1>;\n\tcompatible = \"custom-gpioled\";\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_led>;\n\tled-gpio = <&gpio1 3 GPIO_ACTIVE_LOW>;\n\tstatus = \"okay\";\n};\n```\n\n## Platform驱动\nPlatform驱动本质还是传统的字符设备驱动、块设备驱动或网络设备驱动，只是套上了一张\"platform\"的皮，目的是使用驱动->总线->设备这个驱动框架来实现驱动的分离和分层\n### Platform设备声明和注册\n需要手动定义一个`platform_driver`类型的结构体变量，然后实现结构体中的各个成员变量，主要是匹配方法和probe函数。然后，在驱动文件的`xxx_open()`函数中调用`platform_driver_register`函数以注册该Platform设备：\n```\nstatic struct platform_driver led_driver = {\n    .driver = {\n        .name = \"imx6ul-led\",   //Platform设备名称\n        .of_match_table = led_of_match, //Platform匹配表\n    },\n    .probe = led_probe,     //Probe函数\n    .remove = led_remove,   //驱动卸载函数\n};\n```\n\n```\nstatic int __init leddriver_init(void)\n{\n    return platform_driver_register(&led_driver);   //初始化设备时注册Platform设备\n}\n\nstatic void __exit leddriver_exit(void)\n{\n    platform_driver_unregister(&led_driver);        //关闭设备时卸载Platform设备\n}\n```\nLinux官方会使用`module_platform_driver(gpio_led_driver)`来向Kernel注册Platform设备，这个宏展开之后为：\n```\nstatic int __init gpio_led_driver_init(void) \n{ \n    return platform_driver_register (&(gpio_led_driver)); \n} \nmodule_init(gpio_led_driver_init); \n\nstatic void __exit gpio_led_driver_exit(void) \n{ \n    platform_driver_unregister (&(gpio_led_driver)); \n} \nmodule_exit(gpio_led_driver_exit);\n```\n这实际上就是标准的注册和删除Platform驱动的步骤，使用这个宏可以大大简化Platform设备的驱动代码。\n\n### 设备匹配表\n驱动中需要声明一个`of_device_id`类别的匹配表，用于Platform从设备树查找对应设备：\n```\nstruct of_device_id {\n    char    name[32];\n    char    type[32];\n    char    compatible[128];\n    const void  *data;\n}\n```\n通常都是使用`compatible`属性和设备树节点中的`compatible`值进行比对以进行匹配：\n```\n/* Platform匹配设备树 */\nstatic const struct of_device_id led_of_match[] = {\n    {.compatible = \"custom-gpioled\"},\n};\n```\n\n### probe函数\nprobe函数在驱动和设备匹配完成后执行，对于字符设备而言，原先在`xxx_open`中的代码可以移到`probe`函数中执行，即只在Platform驱动和设备匹配完成后执行，而不是在打开文件后就执行。probe函数的形参为已经声明并且注册过的`platform_device`类型的结构体\n```\n/* platfrom函数的probe驱动，匹配后此函数执行 */\nstatic int led_probe (struct platform_device *dev)\n{\n    printk(\"LED driver and device has beem matched!\\r\\n\");\n\n    if (leddev.major){\n        leddev.devid = MKDEV(leddev.major, 0);\n        register_chrdev_region(leddev.devid, LEDDEV_CNT, LEDDEV_NAME);\n    }else{\n        alloc_chrdev_region(&leddev.devid, 0, LEDDEV_CNT, LEDDEV_NAME);\n        leddev.major = MAJOR(leddev.devid);\n        leddev.minor = MINOR(leddev.devid);\n    }\n    printk(\"Device reg ok, major = %d, minor = %d\\r\\n\", leddev.major, leddev.minor);\n\n    leddev.cdev.owner = THIS_MODULE;\n    cdev_init(&leddev.cdev, &led_fops);\n    cdev_add(&leddev.cdev, leddev.devid, LEDDEV_CNT);\n\n    leddev.class = class_create(LEDDEV_NAME);\n    if (IS_ERR(leddev.class)){\n        return PTR_ERR(leddev.class);\n    }\n\n    leddev.device = device_create(leddev.class, NULL, leddev.devid, NULL, LEDDEV_NAME);\n    if (IS_ERR(leddev.device)){\n        return PTR_ERR(leddev.device);\n    }\n\n    leddev.nd = of_find_node_by_path(\"/gpioled\");\n    if (leddev.nd == NULL){\n        printk(\"Unable find node\\r\\n\");\n        return -EINVAL;\n    }\n\n    leddev.led0_gpio = of_get_named_gpio(leddev.nd, \"led-gpio\", 0);\n    if (leddev.led0_gpio < 0){\n        printk(\"unable find gpio\\r\\n\");\n        return -EINVAL;\n    }\n\n    gpio_request(leddev.led0_gpio, \"led0\");\n    gpio_direction_output(leddev.led0_gpio, 1);\n\n    return 0;\n}\n```\n\n## 完整代码示例\n### 驱动\n```\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/libata.h>   /* 新版kernel不再支持ide.h */\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/gpio.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/of_address.h>\n#include <linux/of_gpio.h>\n#include <asm/mach/map.h>\n#include <asm/uaccess.h>\n#include <asm/io.h>\n#include <linux/semaphore.h>\n#include <linux/timer.h>\n#include <linux/of_irq.h>\n#include <linux/irq.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/platform_device.h>\n\n#define LEDDEV_CNT      1\n#define LEDDEV_NAME     \"dtsplatled\"\n#define LEDOFF          0\n#define LEDON           1\n\nstruct leddev_dev {\n    dev_t   devid;\n    struct cdev cdev;\n    struct class *class;\n    struct device *device;\n    int major;\n    int minor;\n    struct device_node *nd;\n    int led0_gpio;\n};\n\nstruct leddev_dev   leddev;\n\nvoid led0_switch(u8 sta)\n{\n    switch (sta)\n    {\n    case LEDON:\n        gpio_set_value(leddev.led0_gpio, 0);\n        break;\n    \n    case LEDOFF:\n        gpio_set_value(leddev.led0_gpio, 1);\n        break;\n    }\n}\n\nstatic int led_open(struct inode *inode, struct file *filp)\n{\n    filp->private_data = (struct leddev_dev *)&leddev;\n    return 0;\n}\n\nstatic ssize_t led_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)\n{\n    int ret;\n    unsigned char databuf[2];\n    unsigned char led_sta;\n\n    ret = copy_from_user(databuf, buf, cnt);\n    if (ret < 0){\n        printk(\"copy from user failed\\r\\n\");\n        return -EFAULT;\n    }\n\n    led_sta = databuf[0];\n    switch (led_sta)\n    {\n    case LEDON:\n        led0_switch(LEDON);\n        break;\n    \n    case LEDOFF:\n        led0_switch(LEDOFF);\n        break;\n    }\n    return 0;\n}\n\nstatic struct file_operations led_fops = {\n    .owner = THIS_MODULE,\n    .open = led_open,\n    .write = led_write,\n};\n\n/* platfrom函数的probe驱动，匹配后此函数执行 */\nstatic int led_probe (struct platform_device *dev)\n{\n    printk(\"LED driver and device has beem matched!\\r\\n\");\n\n    if (leddev.major){\n        leddev.devid = MKDEV(leddev.major, 0);\n        register_chrdev_region(leddev.devid, LEDDEV_CNT, LEDDEV_NAME);\n    }else{\n        alloc_chrdev_region(&leddev.devid, 0, LEDDEV_CNT, LEDDEV_NAME);\n        leddev.major = MAJOR(leddev.devid);\n        leddev.minor = MINOR(leddev.devid);\n    }\n    printk(\"Device reg ok, major = %d, minor = %d\\r\\n\", leddev.major, leddev.minor);\n\n    leddev.cdev.owner = THIS_MODULE;\n    cdev_init(&leddev.cdev, &led_fops);\n    cdev_add(&leddev.cdev, leddev.devid, LEDDEV_CNT);\n\n    leddev.class = class_create(LEDDEV_NAME);\n    if (IS_ERR(leddev.class)){\n        return PTR_ERR(leddev.class);\n    }\n\n    leddev.device = device_create(leddev.class, NULL, leddev.devid, NULL, LEDDEV_NAME);\n    if (IS_ERR(leddev.device)){\n        return PTR_ERR(leddev.device);\n    }\n\n    leddev.nd = of_find_node_by_path(\"/gpioled\");\n    if (leddev.nd == NULL){\n        printk(\"Unable find node\\r\\n\");\n        return -EINVAL;\n    }\n\n    leddev.led0_gpio = of_get_named_gpio(leddev.nd, \"led-gpio\", 0);\n    if (leddev.led0_gpio < 0){\n        printk(\"unable find gpio\\r\\n\");\n        return -EINVAL;\n    }\n\n    gpio_request(leddev.led0_gpio, \"led0\");\n    gpio_direction_output(leddev.led0_gpio, 1);\n\n    return 0;\n}\n\n/* Platform驱动被移除时执行此函数 */\nstatic int led_remove(struct platform_device *dev)\n{\n    gpio_set_value(leddev.led0_gpio, 1);\n\n    cdev_del(&leddev.cdev);\n    unregister_chrdev_region(leddev.devid, LEDDEV_CNT);\n    device_destroy(leddev.class, leddev.devid);\n    class_destroy(leddev.class);\n\n    return 0;\n}\n\n/* Platform匹配设备树 */\nstatic const struct of_device_id led_of_match[] = {\n    {.compatible = \"custom-gpioled\"},\n};\n\nstatic struct platform_driver led_driver = {\n    .driver = {\n        .name = \"imx6ul-led\",\n        .of_match_table = led_of_match,\n    },\n    .probe = led_probe,\n    .remove = led_remove,\n};\n\nstatic int __init leddriver_init(void)\n{\n    return platform_driver_register(&led_driver);\n}\n\nstatic void __exit leddriver_exit(void)\n{\n    platform_driver_unregister(&led_driver);\n}\n\nmodule_init(leddriver_init);\nmodule_exit(leddriver_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"aki\");\n```\n### 应用程序\n```\n#include \"stdio.h\"\n#include \"unistd.h\"\n#include \"sys/types.h\"\n#include \"sys/stat.h\"\n#include \"fcntl.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n#include \"errno.h\"\n#include \"linux/ioctl.h\"\n#include \"sys/select.h\"\n#include \"sys/time.h\"\n#include \"sys/poll.h\"\n#include \"signal.h\"\n\n#define LEDOFF  0\n#define LEDON   1\n\nint main(int argc, char *argv[])\n{  \n    int fd, ret;\n    char *filename;\n    unsigned char databuf[2];\n\n    if (argc != 3){\n        printf(\"error usage\\r\\n\");\n\n        return -1;\n    }\n\n    filename = argv[1];\n    fd = open(filename, O_RDWR);\n    if (fd < 0){\n        printf(\"unable open file %s\\r\\n\", argv[1]);\n        return -1;\n    }\n\n    databuf[0] = atoi(argv[2]);\n    ret = write(fd, databuf, sizeof(databuf));\n    if (ret < 0){\n        printf(\"LED control failed\\r\\n\");\n        close(fd);\n        return -1;\n    }\n\n    ret = close(fd);\n    if (ret < 0){\n        printf(\"file %s unable close\\r\\n\", filename);\n        return -1;\n    }\n    \n    return 0;\n}\n```\n\n## 使用Linux原生LED驱动\nLinux原生支持了通过GPIO控制LED的驱动，位于`/drivers/leds`下。通常LED会作为系统运行指示灯（呼吸灯）或者硬盘工作指示灯进行工作。6.6.52版本Kernel下原生LED驱动支持默认是打开的，仅需要手动修改设备树。设备树的节点编写规则位于`/Documentation/devicetree/bindings/leds/leds-gpio.txt`。添加以下节点：\n```\n\t\tdtsleds {   /* LED设备 */\n\t\t\tcompatible = \"gpio-leds\";\n\n\t\t\tled0 {\n\t\t\t\tlabel = \"red\";  /* label属性，一般为LED灯的名字，用颜色区分 */\n\t\t\t\tgpios = <&gpio1 3 GPIO_ACTIVE_LOW>;\n\t\t\t\tdefault-state = \"on\";  /* 默认打开 */\n                linux,default-trigger = \"heartbeat\";    /* 作为系统呼吸灯 */\n\t\t\t};\n\t\t};\n```\n编译设备树，LED即作为系统呼吸灯运行。","categories":["嵌入式(Linux开发)"]},{"title":"Linux文件描述符","url":"/2025/03/26/Linux文件描述符/","content":"## 文件描述符(file descriptor)\n我们知道在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。在操作这些所谓的文件的时候，我们每操作一次就找一次名字，这会耗费大量的时间和效率。所以Linux中规定每一个文件对应一个索引，这样要操作文件的时候，我们直接找到索引就可以对其进行操作了。\n\n文件描述符（file descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符来实现。同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这意味着如果此时去打开一个新的文件，它的文件描述符会是3，再打开一个文件文件描述符就是4……\n\nLinux内核对所有打开的文件有一个文件描述符表格，里面存储了每个文件描述符作为索引与一个打开文件相对应的关系，简单理解就是下图这样一个数组，文件描述符（索引）就是文件描述符表这个数组的下标，数组的内容就是指向一个个打开的文件的指针。\n\n![文件指针](/images/linux/file_1.png)\n\n上面只是简单理解，实际上关于文件描述符，Linux内核维护了3个数据结构：\n\n- 进程级的文件描述符表\n- 系统级的打开文件描述符表\n- 文件系统的i-node表\n\n一个 Linux 进程启动后，会在内核空间中创建一个 PCB 控制块，PCB 内部有一个文件描述符表（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。进程级的描述符表的每一条记录了单个进程所使用的文件描述符的相关信息，进程之间相互独立，一个进程使用了文件描述符3，另一个进程也可以用3。除了进程级的文件描述符表，系统还需要维护另外两张表：打开文件表、i-node 表。这两张表存储了每个打开文件的打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息。\n\n系统级的打开文件描述符表：\n\n- 当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）\n- 打开文件时的标识（open()的flags参数）\n- 文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）\n- 与信号驱动相关的设置\n- 对该文件i-node对象的引用，即i-node 表指针\n\n文件系统的i-node表：\n\n- 文件类型（例如：常规文件、套接字或FIFO）和访问权限\n- 一个指针，指向该文件所持有的锁列表\n- 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳\n\n![文件描述符、打开的文件句柄以及i-node之间的关系](/images/linux/file_1.gif)\n- 在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的。\n- 进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。\n- 进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况。\n\n这就说明：同一个进程的不同文件描述符可以指向同一个文件；不同进程可以拥有相同的文件描述符；不同进程的同一个文件描述符可以指向不同的文件（一般也是这样，除了 0、1、2 这三个特殊的文件）；不同进程的不同文件描述符也可以指向同一个文件。","categories":["嵌入式(Linux开发)"]},{"title":"Linux阻塞、非阻塞与异步通知","url":"/2025/03/26/Linux阻塞、非阻塞与异步通知/","content":"## 阻塞IO\n阻塞状态下应用程序从驱动读取函数时，若kernel回报设备不可用，应用程序对应的线程将会进入睡眠，等待设备可用后由设备通知应用程序并将其唤醒以继续执行。\n\nLinux依靠等待队列(wait queue)来进行进程同步，其允许进程在某个条件满足前进入睡眠，并在条件满足时由驱动进行唤醒，避免CPU忙等。\n\n### 等待队列\n基本的等待队列包括：\n- 事件(event)：通常是 硬件中断、数据可用 或 资源释放 等\n- 等待队列头（`wait_queue_head_t`）：每个等待队列都有一个队列头，用于管理在此等待的进程\n- 等待队列项（`wait_queue_t`）：表示等待队列中的一个进程，它包含进程的状态信息\n\n等待队列头结构体：\n```\ntypedef struct __wait_queue_head {\n    spinlock_t lock;         // 保护等待队列的自旋锁\n    struct list_head task_list; \n} wait_queue_head_t;\n```\n显然这是一个链表结构，`task_list`为所有等待某事件发生的进程链表。等待队列头维护等待该事件的所有进程，通过自旋锁来保护对`task_list`的访问以防止竞争条件。\n\n等待队列项：\n```\ntypedef struct wait_queue_entry {\n    unsigned int flags;\n    struct task_struct *task;  // 进程的task_struct\n    struct list_head entry;    // 连接到等待队列\n} wait_queue_entry_t;\n```\n等待队列项代表正在等待事件的进程，进程会被挂载至`task_list`，进入睡眠。\n\n这里结构体中的`task_struct`是Linux的进程描述符，该结构体会管理所有的进程，这是一个非常长而且很复杂的结构体。其中有一个重要的量`volatile long state`，用于表示进程当前的状态，包括：\n- `TASK_RUNNING`：正在运行或准备运行\n- `TASK_INTERRUPTIBLE`：处于可被中断的睡眠状态，等待某个事件发生。此过程下进程可被信号唤醒\n- `TASK_UNINTERRUPTIBLE`：处于不可被中断的睡眠状态，等待某个事件发生。此过程下进程不可被信号唤醒，只能等待事件发生\n- `TASK_STOPPED`：进程停止执行\n- `TASK_TRACED`：进程正在被调试器追踪\n- `TASK_DEAD`：进程已终止，等待被释放\n- `TASK_WAKEKILL`：进程处于可被杀死的睡眠状态，即使在不可中断的睡眠中，也能被特定信号唤醒或终止\n- `TASK_WAKING`：进程正在从睡眠状态中被唤醒，尚未进入可运行队列\n- `TASK_NOLOAD`：进程不应影响负载计算，通常用于内核线程\n\n对于等待队列，前三种状态比较常见。\n\n### 等待队列的使用方式\n1. 定义和初始化等待队列头\n```\nstruct xxx_dev {\n    .......\n    wait_queue_head_t r_wait;\n}\n```\n2. 设定等待条件和事件（以按键为例）\n```\n    DECLARE_WAITQUEUE(wait, current);   /* 创建等待队列 */\n    if (atomic_read(&dev->releasekey) == 0){    /* 如果按键未按下 */\n        add_wait_queue(&dev->r_wait, &wait);    /* 添加当前线程至等待队列 */\n        __set_current_state(TASK_INTERRUPTIBLE);    /* 切换进程模式至可中断睡眠状态 */\n        schedule(); /* 让出CPU，等待被唤醒 */\n        if (signal_pending(current)){   /* 如果有信号打断睡眠，退出 */\n            ret = -ERESTARTSYS;\n            goto wait_error;\n        }\n        __set_current_state(TASK_RUNNING);  /* 进程恢复运行 */\n        remove_wait_queue(&dev->r_wait, &wait); /* 从等待队列中移除当前线程 */\n    }\n```\n其中：\n- `DECLARE_WAITQUEUE(name, tsk)`：用于创建等待队列，`name`为队列名称，`tsk`为队列所对应的进程，一般使用`current`，表示当前线程\n- `add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)`：`q`为等待队列要加入的等待队列头，`wait`为要加入的等待队列项\n\n3. 设定唤醒条件（以按键为例）\n```\n    /* 唤醒进程 */\n    if(atomic_read(&dev->releasekey)){  /* 完成一次按键过程 */\n        wake_up_interruptible(&dev->r_wait);\n    }\n```\n此处可选`wake_up()`和`wake_up_interruptible()`：\n- `wake_up()`会唤醒所有在`r_wait`所属队列中等待的进程\n- `wake_up_interruptible`仅唤醒一个处于`TASK_INTERRUPTIBLE`状态的进程\n\n唤醒后，进程将在被调度器选择后从`schedule()`位置开始继续执行。\n\n### “信号”\n上节提到在`wake_up_interruptible()`下睡眠中的进程会被信号唤醒。信号是Linux的异步进程间通信机制，用于通知进程发生了某种事件，比如用户按下 Ctrl + C 终止进程，或者进程试图访问非法内存地址导致段错误（SIGSEGV）。\n\n| 信号编号 | 信号名称  | 描述                         | 默认处理方式 |\n|---------|---------|----------------------------|------------|\n| `1`     | `SIGHUP`  | 终端挂起（用户退出 shell）    | 终止       |\n| `2`     | `SIGINT`  | 用户终止进程（Ctrl + C）     | 终止       |\n| `9`     | `SIGKILL` | 立即终止进程（不能被捕获或忽略） | 终止       |\n| `11`    | `SIGSEGV` | 段错误（非法访问内存）       | 终止       |\n| `15`    | `SIGTERM` | 终止进程（默认 `kill` 发送） | 终止       |\n| `17`    | `SIGCHLD` | 子进程结束                  | 忽略       |\n\n如果处于`TASK_INTERRUPTIBLE`状态下的进程接收到信号，其会提前返回并唤醒睡眠中的进程。在睡眠状态被信号中断的进程通常会检查是否有信号需要处理，如果有，则提前返回，避免无限等待。\n\n## 非阻塞IO\n非阻塞模式下若设备不可用或数据未准备好时，设备会向kernel返回错误码。应用程序会重新读取数据（或执行其他操作），如此循环，直到数据读取成功。\n\n非阻塞模式下读取数据时，需要修改打开文件的方式：\n```\nfd = open(\"/dev/xxx_dev\", O_RDWR | O_NONBLOCK);\n```\n`O_NONBLOCK`表示使用非阻塞模式。\n\n### 轮询\n#### Select\n```\nint select(int nfds, \n           fd_set *readfds, \n           fd_set *writefds,\n           fd_set *exceptfds, \n           struct timeval *timeout)\n```\n- `nfds`：监视的文件描述符的数量。它是所有文件描述符中最大值加 1。即，nfds = max(fd1, fd2, ..., fdN) + 1。\n- `readfds`：待检测是否可读的文件描述符集合。用 FD_SET() 宏添加文件描述符，FD_ZERO() 初始化为空。\n- `writefds`：待检测是否可写的文件描述符集合\n- `exceptfds`：待检测是否发生异常的文件描述符集合\n- `timeout`：指定等待时间的结构体。如果为 NULL，则会一直等待直到有事件发生；如果为零（timeout = {0, 0}），则非阻塞地返回\n- 返回值：可操作文件描述符个数\n\n`readfds`、`writefds`和`exceptfds`都为`fd_set`类型，指向描述符集合，用于指明关心哪些描述符，以及描述符需要满足的条件。`readfds`负责监视指定描述符集的读变化，即监视这些文件是否可读取，只要这些集合中有一个文件可以被读取，select就会返回大于0的值表示文件可读取。若没有文件可读取，则根据`timeout`判断是否超时。`readfds`可以设置为NULL，表示不关心文件的可读性变化。`writefds`和`exceptfds`的用法也类似。\n\n如果要从一个设备文件中读取数据，可以定义一个`fd_set`变量，用于传递给`readfds`。`fd_set`可以通过这几个宏进行操作：\n```\nvoid FD_ZERO(fd_set *set)           /* 清零fd_set的所有位 */\nvoid FD_SET(int fd, fd_set *set)    /* 将fd_set某个位置1 */\nvoid FD_CLR(int fd, fd_set *set)    /* 将fd_set某个位置0（删除某个文件描述符） */\nint FD_ISSET(int fd, fd_set *set)   /* 测试一个文件是否属于某个集合 */\n```\n\n使用select对某个设备驱动文件进行非阻塞访问的示例：\n```\nvoid main(void)\n{\n    int ret, fd;            //要监视的文件描述符\n    fd_set readfds;         //读操作文件描述符集\n    struct timeval timeout; //超时结构体\n\n    fd = open(\"dev_xxx\", O_RDWR | O_NONBLOCK);  //非阻塞访问\n\n    FD_ZERO(&readfds);      //清除readfs\n    FD_SET(fd, &readfds);   //将fd添加至readfds\n\n    timeout.tv_sec = 0\n    timeout.tv_usec = 500000;\n\n    ret = select(fd + 1, &readfds, NULL, NULL, &timeout);   //仅监测文件是否可读\n    switch (ret)\n    {\n        case 0:                     //超时\n            printf(\"timeout\\r\\n\");\n            break;\n        case -1:                    //错误\n            printf(\"error\\r\\n\");\n            break;\n        default:                    //可读取数据\n            if (FD_ISSET(fd, &readfds)){    //判断是否为fd文件描述符\n                //用read函数读取数据\n            }\n            break;\n    }\n}\n```\n\n#### poll\n```\nint poll(struct pollfd *fds, \n         nfds_t nfds, \n         int timeout)\n```\n`fds`：待监视的文件描述符集合以及要监视的事件，数组元素为`pollfd`类型：\n```\nstruct pollfd {\n    int     fd;         //文件描述符\n    short   events;     //请求的事件\n    short   revents;    //返回的事件\n}\n```\nevents为待监视事件，包含：\n```\nPOLLIN 有数据可以读取。\nPOLLPRI 有紧急的数据需要读取。\nPOLLOUT 可以写数据。\nPOLLERR 指定的文件描述符发生错误。\nPOLLHUP 指定的文件描述符挂起。\nPOLLNVAL 无效的请求。\nPOLLRDNORM 等同于 POLLIN\n```\n`nfds`：poll函数要监视的文件描述符数量\n`timeout`：超时时间\n\npoll函数使用示例:\n```\nvoid main(void)\n{\n    int ret, fd;            //要监视的文件描述符\n    struct pollfd fds;\n\n    fd = open(\"dev_xxx\", O_RDWR | O_NONBLOCK);  //非阻塞访问\n\n    fds.fd = fd;\n    fds.event = POLLIN;     //监视文件是否可以读取\n\n    ret = poll(&fds, 1, 500);   //轮询文件是否可操作，超时时间500ms\n    if (ret){               //可读取\n        ...\n    }else if (ret == 0){    //超时\n        ...\n    }else if (ret < 0){     //错误\n        ...\n    }\n}\n```\n驱动程序：\n```\nunsigned int imx6uirq_poll(struct file *filp, struct poll_table_struct *wait)\n{\n    unsigned int mask = 0;\n    struct imx6uirq_dev *dev = (struct imx6uirq_dev *)filp->private_data;\n\n    poll_wait(filp, &dev->r_wait, wait);    //挂载驱动至等待队列\n\n    if (atomic_read(&dev->releasekey)){\n        mask = POLLIN | POLLRDNORM;         //返回，告知有数据可读\n    }\n\n    return mask;\n}\n\nstatic struct file_operations imx6uirq_fops = {\n    .owner = THIS_MODULE,\n    .open = imx6uirq_open,\n    .read = imx6uirq_read,\n    .poll = imx6uirq_poll,      //绑定poll至fops\n};\n```\n\n#### epoll\nepoll主要解决大并发问题，用于解决传统的select和poll会随着监听fd数量增加而出现效率低下的问题。\n\n使用epoll前应用程序要先用`epoll_create`创建一个epoll句柄：\n```\nint epoll_create(int size)\n\nreturn:\nepoll句柄，-1表示创建失败\n```\n句柄创建完成后，用`epoll_ctl`向其中要监视的文件描述符以及监视的事件：\n```\nint epoll_ctl(int   epfd,\n              int   op,\n              int   fd,\n              struct epoll_event *event)\n\nepfd：要操作的 epoll 句柄\n\nop：表示要对 epfd(epoll 句柄)进行的操作，可以设置为：\nEPOLL_CTL_ADD 向 epfd 添加文件参数 fd 表示的描述符。\nEPOLL_CTL_MOD 修改参数 fd 的 event 事件。\nEPOLL_CTL_DEL 从 epfd 中删除 fd 描述符。\n\nfd：要监视的文件描述符。\n\nevent：要监视的事件类型，为 epoll_event 结构体类型指针：\n\nstruct epoll_event {\n        uint32_t events;   /* epoll 事件 */\n        epoll_data_t data; /* 用户数据 */\n};\n\nevents表示要监视的事件，可选：\nEPOLLIN 有数据可以读取。\nEPOLLOUT 可以写数据。\nEPOLLPRI 有紧急的数据需要读取。\nEPOLLERR 指定的文件描述符发生错误。\nEPOLLHUP 指定的文件描述符挂起。\nEPOLLET 设置 epoll 为边沿触发，默认触发模式为水平触发。\nEPOLLONESHOT 一次性的监视，当监视完成以后还需要再次监视某个 fd，那么就需要将\nfd 重新添加到 epoll 里面。\n```\n设置完成后，调用`epoll_wait()`等待事件发生：\n```\nint epoll_wait(int epfd,                    //要等待的poll\n               struct epoll_event *events,  //指向epoll_event结构体的数组\n               int maxevents,               //events数组大小\n               int timeout)                 //超时时间，ms\n```\n\n## 异步通知\n异步通知通过信号用类似于软中断的方式，由驱动程序自行通知应用程序令其响应。Linux的信号类型在`arch/xtebsa/include/uapi/asm/signal/h`中定义。\n\n信号同样有回调函数（接收到信号后要执行的内容）：\n```\nsighandler_t signal(int signum, sighandler_t handler)\n```\n- `signum`：信号类别\n- `handler`：信号处理函数\n\n### 驱动处理信号\n1. 定义一个`fasync_struct`类型的结构体指针：\n```\nstruct fasync_struct {\n    dev_t devid;\n    ......\n    struct fasync_struct *async_queue;  /* 异步结构体 */\n}\n```\n\n2. 初始化结构体指针：\n```\nint fasync_helper(int fd, struct file *filp, int on, struct fasync_struct **fapp)\n```\n\n3. 新建`xxx_fasync`回调函数以处理FASYNC标志，并绑定至`fops`\n\n4. 满足信号发送条件时，调用`kill_fasync`向应用程序发送信号：\n```\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n```\n- `sig`：待发送信号类型\n- `band`：可读时为`POLL_IN`，可写时为`POLL_OUT`\n\n5. 驱动文件关闭时释放`fasync_struct`：\n```\nxxx_fasync(-1 ,filp, 0);\n```\n\n`xxx_fasync`参考示例：\n```\nstatic int xxx_fasync(int fd, struct file *filp, int on)\n{\n    struct xxx_dev *dev = (struct xxx_dev *)filp->private_data;\n\n    if (fasync_helper(fd, filp, on, &dev->async_queue) < 0)\n        return -EIO;\n    return 0;\n}\n\n/* 满足条件时 */\nvoid xxx()\n{\n    ....\n    kill_fasync(&dev->async_queue, SIGIO, POLL_IN); /* 向应用程序发送SIGIO（表示文件描述符准备就绪, 可以开始进行输入/输出操作）信号 */\n}\n```\n\n### 应用程序处理信号\n应用程序首先绑定处理函数至某个特定的信号量，然后调用`fcntl`(操作文件描述符的属性)进行初始化：\n```\nint fcntl (int __fd, int __cmd, ...);\n```\n```\n    fcntl(fd, F_SETOWN, getpid());  /* 通知kernel当前进程的进程号 */\n```\n-`F_SETOWN`：设置`fd`的所有者，此处为当前进程(`getpid()`返回当前进程的ID)\n```\n    flags = fcntl(fd, F_GETFD);     /* 获取进程状态 */\n    fcntl(fd, F_SETFL, flags | FASYNC); /* 为进程启用异步通知功能 */\n```\n- `F_GETFD`：获取当前`fd`的标志位，返回整型值，描述`fd`属性信息（如文件描述符是否关闭，是否是异步 I/O 等）\n- `F_SETFL`：设置`fd`的文件状态标志\n- `flags | FASYNC`：将`FASYNC`标志添加进入现有的文件描述符标志，启用文件描述符的异步IO功能。\n\n完整过程：\n```\nstatic int fd = 0;  /* 文件描述符 */\n\n/* 信号处理函数 */\nstatic void sigio_signal_func(int signum)\n{\n    int err = 0;\n    unsigned int keyvalue = 0;\n\n    err = read(fd, &keyvalue, sizeof(keyvalue));\n    if (err < 0){\n        printf(\"sigio error\\r\\n\");\n    }else{\n        printf(\"sigio signal, key value = %d\\r\\n\", keyvalue);\n    }\n}\n\nint main(int argc, char *argv[])\n{  \n    .......\n\n    /* 绑定信号处理函数至SIGIO信号 */\n    signal(SIGIO, sigio_signal_func);   \n\n    fcntl(fd, F_SETOWN, getpid());  /* 通知kernel当前进程的进程号 */\n    flags = fcntl(fd, F_GETFD);     /* 获取进程状态 */\n    fcntl(fd, F_SETFL, flags | FASYNC); /* 为进程启用异步通知功能 */\n\n    while (1){\n        sleep(2);\n    }\n\n    close(fd);\n    return 0;\n}\n\n```\n","categories":["嵌入式(Linux开发)"]},{"title":"Linux中断机制","url":"/2025/03/26/Linux中断机制/","content":"## 设备树中断信息节点\nIMX6ULL和IMX6UL的中断控制器呈兼容关系，即IMX6ULL继承IMX6UL的GIC节点信息。在`imx6ul.dtsi`中有：\n```\n\tintc: interrupt-controller@a01000 {\n\t\tcompatible = \"arm,gic-400\", \"arm,cortex-a7-gic\";\n        /* GIC_PPI：私有外设中断，非共享\n           9:中断号为9\n           GIC_CPU_MASK_SIMPLE(1):PPI只发送给CPU0处理\n           IRQ_TYPE_LEVEL_HIGH：电平触发，高电平有效 */\n\t\tinterrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_HIGH)>;\n        /* 中断描述需3个单元 */\n\t\t#interrupt-cells = <3>;\n        /* 声明节点为中断控制器 */\n\t\tinterrupt-controller;\n        /* 父类为自身，说明是顶级GIC */\n\t\tinterrupt-parent = <&intc>;\n        /* GIC寄存器基地址和大小 */\n\t\treg = <0x00a01000 0x1000>,  /* GIC分发器基地址 */\n\t\t\t  <0x00a02000 0x2000>,  /* GIC CPU接口基地址 */\n\t\t\t  <0x00a04000 0x2000>,  /* GIC虚拟CPU接口 */\n\t\t\t  <0x00a06000 0x2000>;  /* GIC虚拟分发器 */\n\t};\n```\n这里的`interrupt-cells`通常格式为`<中断类型 中断号 标志位>`或`<中断号 标志位>`，其中\n- 中断类型：\n    + `0`：SPI，共享外设中断\n    + `1`：PPI，私有外设中断\n- 中断号：设备中断ID，SPI中断号范围为0~987，PPI中断号范围为0~15\n- 标志位：\n    + `IRQ_TYPE_NONE`：Kernel不参与设置，跟随uboot\n\t+ `IRQ_TYPE_EDGE_RISING`：上升沿触发\n\t+ `IRQ_TYPE_EDGE_FALLING`：下降沿触发\n\t+ `IRQ_TYPE_EDGE_BOTH `：双边沿触发\n\t+ `IRQ_TYPE_LEVEL_HIGH`：高电平触发\n\t+ `IRQ_TYPE_LEVEL_LOW`：低电平触发\n\nGPIO也可以作为GIC：\n```\ngpio5: gpio@20ac000 {\n\t\tcompatible = \"fsl,imx6ul-gpio\", \"fsl,imx35-gpio\";\n\t\treg = <0x020ac000 0x4000>;\n        /* 共享中断，中断号74，高电平触发\n           共享中断，中断号75，高电平触发 */\n\t\tinterrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>,\n\t\t\t\t\t <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;\n\t\tclocks = <&clks IMX6UL_CLK_GPIO5>;\n\t\tgpio-controller;\n\t\t#gpio-cells = <2>;\n\t\tinterrupt-controller;   /* 声明为中断控制器 */\n\t\tgpio-ranges = <&iomuxc 0 7 10>, <&iomuxc 10 5 2>;\n}\n```\n\n中断需要在节点中配置，如`imx6ul-14x14-evk.dtsi`中`i2c1`节点下的：\n```\n\tfxls8471@1e {\n\t\tcompatible = \"fsl,fxls8471\";\n\t\treg = <0x1e>;\n\t\tposition = <0>;\n\t\tinterrupt-parent = <&gpio5>;    /* GIC为GPIO5 */\n\t\tinterrupts = <0 8>; /* 中断号为0，低电平触发 */\n\t};\n```\n\n简单来说，设备树节点中描述中断的信息有：\n- `#interrupt-cells`：中断源cell个数\n- `interrupt-controller`：声明当前节点为中断控制器\n- `interrupts`：指定中断号和中断触发模式\n- `interrupt-parent`：父中断(GIC)\n\n## 用法\n1. 修改设备树\n2. 设备结构体中声明`irqreturn_t (*handler)(int, void *)`(也可以不声明)和`int irqnum`(存放中断号)\n3. 通过`irq_of_parse_and_map`向设备树申请中断信息\n```\nunsigned int irq_of_parse_and_map(struct device_node *node, int index);\n```\n该函数返回申请到的中断号。\n4. 初始化时向kernel申请中断：\n```\nrequest_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,\n\t    const char *name, void *dev)\n```\n- `irq`：中断号\n- `handler`：中断服务函数\n- `flags`：标志位，可选：\n```\n#define IRQF_TRIGGER_NONE\t0x00000000\n#define IRQF_TRIGGER_RISING\t0x00000001\n#define IRQF_TRIGGER_FALLING\t0x00000002\n#define IRQF_TRIGGER_HIGH\t0x00000004\n#define IRQF_TRIGGER_LOW\t0x00000008\n#define IRQF_TRIGGER_MASK\t(IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW | \\\n\t\t\t\t IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)\n#define IRQF_TRIGGER_PROBE\t0x00000010\n```\n- `*name`：生成中断的设备名\n- `*dev`：Cookie，传递设备结构体地址\n5. 设备注销时释放中断：\n```\nvoid *free_irq(unsigned int irq, void *dev);\n```\n- `irq`：中断号\n- `*dev`：Cookie，传递设备结构体地址\n\n## 例程\n```\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/libata.h>   /* 新版kernel不再支持ide.h */\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/gpio.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_gpio.h>\n#include <asm/mach/map.h>\n#include <asm/uaccess.h>\n#include <asm/io.h>\n#include <linux/semaphore.h>\n#include <linux/timer.h>\n#include <linux/of_irq.h>\n#include <linux/irq.h>\n\n#define IMX6UIRQ_CNT         1\n#define IMX6UIRQ_NAME   \"imx6uirq\"\n#define KEY0VALUE       0x01\n#define INVAKEY         0xFF\n#define KEY_NUM         1\n\nstruct irq_keydesc {\n    int gpio;\n    int irqnum;             /* 中断号 */\n    unsigned char value;    /* 按键对应的键值 */\n    char name[10];          \n    irqreturn_t (*handler)(int, void *);    /* 中断服务函数 */\n};\n\nstruct irq_led {\n    int gpio;\n};\n\nstruct imx6uirq_dev {\n    dev_t devid;\n    struct cdev cdev;\n    struct class *class;\n    struct device *device;\n    int major;\n    int minor;\n    struct device_node *nd;\n    atomic_t keyvalue;      /* 有效按键键值 */\n    atomic_t releasekey;    /* 标记是否完成一次按键 */\n    struct timer_list timer;\n    struct irq_keydesc irqkeydesc; /* 按键描述结构体 */\n    struct irq_led irqled;\n};\n\nstruct imx6uirq_dev imx6uirq;\n\n/* IRQ服务函数，延时10ms，消抖 */\nstatic irqreturn_t key0_handler(int irq, void *dev_id)\n{\n    struct imx6uirq_dev *dev = (struct imx6uirq_dev *)dev_id;\n\n    mod_timer(&dev->timer, jiffies + msecs_to_jiffies(10)); /* 延时10ms，消抖 */\n    return IRQ_RETVAL(IRQ_HANDLED);\n}\n\n/* 定时器服务函数，到期后再次读取按键值，如果还是按下表示按键有效 */\nvoid timer_function(struct timer_list *t)\n{\n    unsigned char value;\n    struct irq_keydesc *keydesc;\n    struct imx6uirq_dev *dev = from_timer(dev, t, timer);\n\n    keydesc = &dev->irqkeydesc;\n\n    value = gpio_get_value(keydesc->gpio);  /* 读取IO电平 */\n    if (value == 0){    /* 如果按下 */\n        int sta = gpio_get_value(dev->irqled.gpio);\n        gpio_set_value(dev->irqled.gpio, !sta);\n        atomic_set(&dev->keyvalue, keydesc->value);\n    }else{      /* 如果松开 */\n        atomic_set(&dev->keyvalue, 0x80 | keydesc->value);\n        atomic_set(&dev->releasekey, 1);    /* 标记松开按键 */\n    }\n}\n\nstatic int keyio_init(void)\n{\n    int ret = 0;\n\n    imx6uirq.nd = of_find_node_by_path(\"/key\");\n    if (imx6uirq.nd == NULL){\n        printk(\"find node failed\\r\\n\");\n        return -EINVAL;\n    }\n\n    imx6uirq.irqkeydesc.gpio = of_get_named_gpio(imx6uirq.nd, \"key-gpio\", 0);\n    if (imx6uirq.irqkeydesc.gpio < 0){\n        printk(\"unable get key gpio\\r\\n\");\n        return -EINVAL;\n    }\n\n    imx6uirq.irqled.gpio = of_get_named_gpio(imx6uirq.nd, \"led-gpio\", 0);\n    if (imx6uirq.irqled.gpio < 0){\n        printk(\"unable get led gpio\\r\\n\");\n        return -EINVAL;\n    }\n\n    sprintf(imx6uirq.irqkeydesc.name, \"KEY0\");\n    gpio_request(imx6uirq.irqkeydesc.gpio, imx6uirq.irqkeydesc.name);\n    ret = gpio_direction_input(imx6uirq.irqkeydesc.gpio);\n    if (ret < 0){\n        printk(\"unable set key pin level\\r\\n\");\n        return ret;\n    }\n    imx6uirq.irqkeydesc.irqnum = irq_of_parse_and_map(imx6uirq.nd, 0);\n    printk(\"key0: gpio = %d, irqnum = %d\\r\\n\", imx6uirq.irqkeydesc.gpio, imx6uirq.irqkeydesc.irqnum);\n\n    gpio_request(imx6uirq.irqled.gpio, \"LED\");\n    ret = gpio_direction_output(imx6uirq.irqled.gpio, 1);\n    if (ret < 0){\n        printk(\"unable set led pin level\\r\\n\");\n        return ret;\n    }\n\n    imx6uirq.irqkeydesc.handler = key0_handler;\n    imx6uirq.irqkeydesc.value = KEY0VALUE;\n\n    ret = request_irq(imx6uirq.irqkeydesc.irqnum, imx6uirq.irqkeydesc.handler, IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING, imx6uirq.irqkeydesc.name, &imx6uirq);\n\n    if (ret < 0){\n        printk(\"IRQ request failed, error code: %d\\r\\n\", ret);\n    }\n\n    timer_setup(&imx6uirq.timer, timer_function, 0);\n\n    return 0;\n}\n\nstatic int imx6uirq_open(struct inode *inode, struct file *filp)\n{\n    filp->private_data = &imx6uirq;\n    return 0;\n}\n\nstatic ssize_t imx6uirq_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)\n{\n    int ret = 0;\n    unsigned char keyvalue = 0;\n    unsigned char releasekey = 0;\n    struct imx6uirq_dev *dev = (struct imx6uirq_dev *)filp->private_data;\n\n    keyvalue = atomic_read(&dev->keyvalue);\n    releasekey = atomic_read(&dev->releasekey);\n\n    if (releasekey){\n        if (keyvalue & 0x80){\n            keyvalue &= ~(0x80);\n            ret = copy_to_user(buf, &keyvalue, sizeof(keyvalue));\n        }else{\n            goto data_error;\n        }\n        atomic_set(&dev->releasekey, 0);\n    }else{\n        goto data_error;\n    }\n    return 0;\n\ndata_error:\n    return -EINVAL;\n}\n\nstatic struct file_operations imx6uirq_fops = {\n    .owner = THIS_MODULE,\n    .open = imx6uirq_open,\n    .read = imx6uirq_read,\n};\n\nstatic int __init imx6uirq_init(void)\n{\n    if (imx6uirq.major){\n        imx6uirq.devid = MKDEV(imx6uirq.major, 0);\n        register_chrdev_region(imx6uirq.devid, IMX6UIRQ_CNT, IMX6UIRQ_NAME);\n    }else{\n        alloc_chrdev_region(&imx6uirq.devid, 0, IMX6UIRQ_CNT, IMX6UIRQ_NAME);\n        imx6uirq.major = MAJOR(imx6uirq.devid);\n        imx6uirq.minor = MINOR(imx6uirq.devid);\n    }\n    printk(\"KEY reg ok, major = %d, minor = %d\\r\\n\", imx6uirq.major, imx6uirq.minor);\n\n    cdev_init(&imx6uirq.cdev, &imx6uirq_fops);\n    cdev_add(&imx6uirq.cdev, imx6uirq.devid, IMX6UIRQ_CNT);\n\n    imx6uirq.class = class_create(IMX6UIRQ_NAME);\n    if (IS_ERR(imx6uirq.class)){\n        return PTR_ERR(imx6uirq.class);\n    }\n\n    imx6uirq.device = device_create(imx6uirq.class, NULL, imx6uirq.devid, NULL, IMX6UIRQ_NAME);\n    if (IS_ERR(imx6uirq.device)){\n        return PTR_ERR(imx6uirq.device);\n    }\n\n    atomic_set(&imx6uirq.keyvalue, INVAKEY);\n    atomic_set(&imx6uirq.releasekey, 0);\n    keyio_init();\n\n    return 0;\n}\n\nstatic void __exit imx6uirq_exit(void)\n{\n    del_timer_sync(&imx6uirq.timer);\n\n    free_irq(imx6uirq.irqkeydesc.irqnum, &imx6uirq);\n    gpio_free(imx6uirq.irqkeydesc.gpio);\n\n    cdev_del(&imx6uirq.cdev);\n    unregister_chrdev_region(imx6uirq.devid, IMX6UIRQ_CNT);\n    device_destroy(imx6uirq.class, imx6uirq.devid);\n    class_destroy(imx6uirq.class);\n}\n\nmodule_init(imx6uirq_init);\nmodule_exit(imx6uirq_exit);\nMODULE_LICENSE(\"GPL\");\n```\n\n","categories":["嵌入式(Linux开发)"]},{"title":"Linux内核定时器","url":"/2025/03/26/Linux内核定时器/","content":"新版本Kernel下定时器API得到了比较好的优化，以正点原子阿尔法基于4.4版本kernel的旧版API为例做对比：\n## 定时器回调函数：\n### 旧版：\n```\nvoid timer_function(unsigned long arg)\n {\n struct timer_dev *dev = (struct timer_dev *)arg;\n static int sta = 1;\n\n /* ....... */\n\n }\n```\n### 新版：\n```\nvoid timer_function(struct timer_list *t)\n{\n\tstruct timer_dev *dev = from_timer(dev, t, timer);\t/* 从定时器实例获取父级结构体 */\n\tstatic int sta = 1;\n\n /* ....... */\n}\n```\n新版定时器回调函数形参直接为timer_list实例，而定时器父级结构体不再通过`arg`获取，kernel提供了`from_timer`函数：\n```\n#define from_timer(var, callback_timer, timer_fieldname) \\\n\tcontainer_of(callback_timer, typeof(*var), timer_fieldname)\n```\n这个宏自`container_of()`扩展而来：\n```\n/**\n * container_of - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n * WARNING: any const qualifier of @ptr is lost.\n */\n#define container_of(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tstatic_assert(__same_type(*(ptr), ((type *)0)->member) ||\t\\\n\t\t      __same_type(*(ptr), void),\t\t\t\\\n\t\t      \"pointer type mismatch in container_of()\");\t\\\n\t((type *)(__mptr - offsetof(type, member))); })\n```\n`container_of`能从结构体成员指针推导出其父级结构体的指针：\n- `ptr`：指向结构体 `member` 成员的指针。\n- `type`：包含 `member` 成员的结构体类型。\n- `member`：`type` 结构体中的成员变量名。\n\n扩展后，`from_timer`能根据以下形参计算出其所属的父级结构体(这里为`timer_dev`)的指针：\n- `var`：目标结构体的变量（不是指针，而是变量名）。\n- `callback_timer`：指向 `timer_list` 结构体的指针（定时器回调传入的参数）。\n- `timer_fieldname`：`timer_list` 在 `var` 结构体中的字段名。\n\n## 定时器初始化函数\n### 旧版\n旧版API比较复杂，还要手动设置结构体成员：\n```\ninit_timer(&timerdev.timer);\ntimerdev.timer.function = timer_function;\ntimerdev.timer.data = (unsigned long)&timerdev;\n```\n### 新版\nKernel提供`timer_setup()`，这个宏实际上由`init_timer_key()`函数扩展而来：\n```\n#define timer_setup(timer, callback, flags)\t\t\t\\\n\t__init_timer((timer), (callback), (flags))\n```\n```\n#define __init_timer(_timer, _fn, _flags)\t\t\t\t\\\n\tinit_timer_key((_timer), (_fn), (_flags), NULL, NULL)\n```\n```\nvoid init_timer_key(struct timer_list *timer, void (*func)(struct timer_list*), unsigned int flags, const char *name, struct lock_class_key *key)\n\nusage: initialize a timer\n\nParameters:\n\nstruct timer_list *timer\nthe timer to be initialized\n\nvoid (*func)(struct timer_list *)\ntimer callback function\n\nunsigned int flags\ntimer flags\n\nconst char *name\nname of the timer\n\nstruct lock_class_key *key\nlockdep class key of the fake lock used for tracking timer sync lock dependencies\n\nDescription:\n\ninit_timer_key() must be done to a timer prior to calling any of the other timer functions.\n```\n实际上`timer_setup(&timerdev.timer, timer_function, 0)`就等于：\n```\ninit_timer_key(&timerdev.timer, timer_function, 0, NULL, NULL);\n```\n注意这里的`timer_function`必须使用`timer_list*`类型作为形参，不能用旧版的`arg`去传递。\n\n## 从正点原子阿尔法第五十章示例代码修改而来的新代码\n```\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/libata.h>   /* 新版kernel不再支持ide.h */\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/gpio.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_gpio.h>\n#include <asm/mach/map.h>\n#include <asm/uaccess.h>\n#include <asm/io.h>\n#include <linux/semaphore.h>\n#include <linux/timer.h>\n\n#define \tTIMER_CNT     \t1\n#define \tTIMER_NAME      \"timer\"\n#define \tCLOSE_CMD     \t(_IO(0xEF, 0x1))\n#define \tOPEN_CMD \t    (_IO(0xEF, 0x2))\n#define \tSETPERIOD_CMD  \t(_IO(0xEF, 0x3))\n#define \tLED_ON \t      \t1\n#define \tLED_OFF        \t0\n\n/* Timer device struct */\nstruct timer_dev{\n dev_t devid;\t\t\t\n struct cdev cdev;\t\t\n struct class *class;\t\n struct device *device;\t\n int major;\t\t\t\t\n int minor;\t\t\t\t\n struct device_node *nd;\t\n int led_gpio;\n int timeperiod;\t\t\t/* 定时器周期(ms) */\n struct timer_list timer;\t/* 定时器 */\n spinlock_t lock;\t\t\t/* 自旋锁 */\n};\n\nstruct timer_dev timerdev;\t/* 声明定时器实例 */\n\nstatic int led_init(void)\n{\n\tint ret = 0;\n\n\t/* 从设备树查找led节点 */\n\ttimerdev.nd = of_find_node_by_path(\"/gpioled\");\n\tif (timerdev.nd == NULL){\n\t\treturn -EINVAL;\n\t}\n\n\t/* 从节点查找gpiopin */\n\ttimerdev.led_gpio = of_get_named_gpio(timerdev.nd, \"led-gpio\", 0);\n\tif (timerdev.led_gpio < 0){\n\t\tprintk(\"Unable get led gpio\\r\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* 申请GPIO */\n\tgpio_request(timerdev.led_gpio, \"led\");\n\n\t/* 上拉输出 */\n\tret = gpio_direction_output(timerdev.led_gpio, 1);\t\n\tif (ret < 0){\n\t\tprintk(\"cannot set gpio\\r\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int timer_open(struct inode *inode, struct file *filp)\n{\n\tint ret = 0;\n\tfilp->private_data = &timerdev;\t/* 设置私有变量以保存结构体 */\n\n\ttimerdev.timeperiod = 1000;\t/* 默认定时器周期1000ms */\n\n\t/* 初始化LED */\n\tret = led_init();\n\tif (ret < 0){\n\t\tprintk(\"led initialize failed\\r\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic long timer_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct timer_dev *dev = (struct timer_dev *)filp->private_data;\t/* 从fops获取保存的timerdev */\n\tint timerperiod;\n\tunsigned long flags;\n\n\tswitch (cmd) {\n\t\t/* 关闭定时器 */\n\t\tcase CLOSE_CMD:\n\t\t\tdel_timer_sync(&dev->timer);\n\t\t\tbreak;\n\n\t\t/* 打开定时器 */\n\t\tcase OPEN_CMD:\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\t/* 上锁 */\n\t\t\ttimerperiod = dev->timeperiod;\t/* 保护状态下修改timerperiod为默认定时器周期 */\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\t/* 解锁 */\n\t\t\tmod_timer(&dev->timer, jiffies + msecs_to_jiffies(timerperiod));\t/* 重启定时器 */\n\t\t\tbreak;\n\n\t\t/* 修改定时器周期 */\n\t\tcase SETPERIOD_CMD:\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\t/* 上锁 */\n\t\t\tdev->timeperiod = arg;\t/* 保护状态下从用户空间获取定时器周期并赋值 */\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\t/* 解锁 */\n\t\t\tmod_timer(&dev->timer, jiffies + msecs_to_jiffies(arg));\t/* 重启定时器 */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\t\nstatic struct file_operations timer_fops = {\n\t.owner = THIS_MODULE,\n\t.open = timer_open,\n\t.unlocked_ioctl = timer_unlocked_ioctl,\n};\n\n/* 定时器回调 */\nvoid timer_function(struct timer_list *t)\n{\n\tstruct timer_dev *dev = from_timer(dev, t, timer);\t/* 从定时器实例获取父级结构体 */\n\tstatic int sta = 1;\n\tint timerperiod;\n\tunsigned long flags;\n\n\t/* 翻转LED */\n\tsta = !sta;\n\tgpio_set_value(dev->led_gpio, sta);\n\n\tspin_lock_irqsave(&dev->lock, flags);\t/* 上锁 */\n\ttimerperiod = dev->timeperiod;\t/* 保护状态下获取当前定时器周期 */\n\tspin_unlock_irqrestore(&dev->lock, flags);\t/* 解锁 */\n\tmod_timer(&dev->timer, jiffies + msecs_to_jiffies(dev->timeperiod));\t/* 重启定时器 */\n}\n\nstatic int __init timer_init(void)\n{\n\t/* 初始化自旋锁 */\n\tspin_lock_init(&timerdev.lock);\n\n\t/* 注册设备 */\n\tif (timerdev.major){\n\t\ttimerdev.devid = MKDEV(timerdev.major, 0);\n\t\tregister_chrdev_region(timerdev.devid, TIMER_CNT, TIMER_NAME);\n\t}else{\n\t\talloc_chrdev_region(&timerdev.devid, 0, 1, TIMER_NAME);\n\t\ttimerdev.major = MAJOR(timerdev.devid);\n\t\ttimerdev.minor = MINOR(timerdev.devid);\n\t}\n\tprintk(\"Device reg ok, major = %d, minor = %d\\r\\n\", timerdev.major, timerdev.minor);\n\n\t/* 配置CDEV*/\n\ttimerdev.cdev.owner = THIS_MODULE;\n\tcdev_init(&timerdev.cdev, &timer_fops);\n\tcdev_add(&timerdev.cdev, timerdev.devid, TIMER_CNT);\n\n\t/* 配置CLASS */\n\ttimerdev.class = class_create(TIMER_NAME);\n\tif (IS_ERR(timerdev.class)){\n\t\treturn PTR_ERR(timerdev.class);\n\t}\n\n\t/* 配置DEVICE */\n\ttimerdev.device = device_create(timerdev.class, NULL, timerdev.devid, NULL, TIMER_NAME);\n\tif (IS_ERR(timerdev.device))\n\t{\n\t\treturn PTR_ERR(timerdev.device);\n\t}\n\n\t/* 初始化定时器 */\n\ttimer_setup(&timerdev.timer, timer_function, 0);\n\n\treturn 0;\n}\n\nstatic void __exit timer_exit(void)\n{\n\tgpio_set_value(timerdev.led_gpio, 1);\n\tdel_timer_sync(&timerdev.timer);\n\n\tcdev_del(&timerdev.cdev);\n\tunregister_chrdev_region(timerdev.devid, TIMER_CNT);\n\n\tdevice_destroy(timerdev.class, timerdev.devid);\n\tclass_destroy(timerdev.class);\n}\n\nmodule_init(timer_init);\nmodule_exit(timer_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"aki\");\n```\n\n\n","categories":["嵌入式(Linux开发)"]},{"title":"Linux并发与竞争","url":"/2025/03/24/Linux并发与竞争/","content":"## 原子操作\n原子操作能够在无锁条件下实现线程安全操作，避免多个线程同时修改变量导致数据竞争。比较适用于简单的计数或标志变量等小型共享数据。但是原子操作只能保证单个原子变量的原子性，不能保护复杂数据结构。并且虽然其不会导致线程阻塞，但可能导致活锁，即多个线程不断重试并竞争CPU资源。\n\n驱动中通过原子操作来保护进程的方式为：\n1. 在设备结构体中声明原子变量\n```\nstruct gpioled_dev{\n    ......\n    atomic_t lock;   /* 原子变量 */\n}\n```\n2. open函数中判断原子变量的值来检查目标设备有无被别的应用调用\n```\nstatic int led_open(...)\n{\n    if (!atomic_dec_and_test(&gpioled.lock)){\n        atomic_inc(&gpioled.lock);\n        return -EBUSY;\n    }\n}\n```\n这段代码的逻辑是，`atomic_dec_and_test`将原子变量递减并检查其是否为0.如果为0，表示当前线程获得访问权限；如果递减后原子变量仍大于0，说明已经有其他线程持有权限，当前线程不能访问。如果当前线程可以访问，则将原子变量恢复原值，避免影响计数。\n\n在驱动文件关闭时，释放原子变量：\n```\nstatic int led_release(...)\n{\n    ......\n    atomic_inc(&dev->lock);\n}\n```\n\n在驱动入口函数内，初始化原子变量为1：\n```\nstatic int __init led_init(void)\n{\n    ...\n\n    atomic_set(&gpioled.lock, 1);\n}\n```\n\n## 自旋锁(Spinlock)\n这是一种轻量级的锁，通过不断循环检查锁的状态来等待资源，而非让线程进入睡眠。\n\n- 线程在等待锁时会不断检查，不释放CPU时间\n- 适用于**临界区执行时间短**的场景，否则浪费CPU资源\n- 需要显式加锁/解锁，适用于保护复杂的数据结构\n\n自旋锁保护的是临界区，即`spin_lock_irqsave()`到`spin_unlock_irqrestore()`之间的\n代码所操作的共享变量。\n\n自旋锁适用于临界区执行时间短或锁的持有时间短的情况，或多核CPU场景。操作自旋锁时，一般使用`spin_lock_irqsave`和`spin_unlock_irqrestore`函数，其会关闭中断，避免IRQ抢占锁以造成竞争问题。解锁时函数会一并恢复中断，防止中断永久关闭。\n```\n函数声明：\n\tvoid spin_lock_irqsave(spinlock_t *lock, unsigned long flags);\n函数功能：\n\t1. 保存本地中断状态\n\t2. 关闭本地中断\n\t3. 获取自旋锁\n参数说明：\n\tlock：被定义且初始化过的锁；\n\tflags：保存本地中断状态；\n```\n\n驱动通过自旋锁来保护线程的方法：\n1. 设备结构体中声明设备状态和自旋锁：\n```\nstrcut gpioled_dev {\n    ......\n    int dev_stats; /* 设备状态，0：未使用；>0：已经被使用 */\n    spinlock_t lock;   /* 自旋锁 */\n}\n```\n2. open函数中检查锁的状态\n```\nstatic int led_open(...)\n{\n    ......\n    spin_lock_irqsave(&gpioled.lock ,flags);    /* 上锁 */\n    if (gpioled.dev_stats){     /* 如果设备已经被其他线程使用 */\n        spin_unlock_irqrestore(&gpioled.lock, flags);   /* 解锁 */\n        return -EBUSY;  /* 设备正忙 */\n    }\n    gpioled.dev_stats++;    /* 如果设备未打开，则更新设备状态为已经打开 */\n    spin_unlock_irqrestore(&gpioled.lock, flags);   /* 解锁 */\n}\n```\n3. release函数中更新锁的状态\n```\nstatic int led_release(...)\n{\n    ......\n    spin_lock_irqsave(&dev->lock, flags);   /* 上锁 */\n    if (dev->dev_stats){\n        dev->dev_stats--;   /* 更新设备状态至未使用 */\n    }\n    spin_unlock_irqrestore(&dev->lock, flags);  /* 解锁 */\n}\n```\n\n4. 设备初始化时初始化自旋锁\n```\nstatic int __init led_init(void)\n{\n    ......\n    spin_lock_init(&gpioled.lock);\n}\n```\n\n*问题：为什么不在设备（线程）被使用后直接上锁，而是上锁后又解锁？ 这样不就防止其他线程访问了吗？*\n简单来说，锁的作用不是用来“锁住整个设备”，而是用来“保护对共享资源的访问”。\n在 `led_open()` 里，我们用自旋锁来保证检查 & 修改设备状态这段代码是原子的，而不是用来锁住整个设备的访问权限。\n\n假设我们在 `gpioled.dev_stats++` 之后不解锁，而是让锁一直保持不释放，其他线程就无法再进入 `led_open()`，但这带来了两个大问题：\n1. 整个设备会被锁死，这个设备无法再被其他线程使用\n2. `led_release`无法再获取锁，设备无法被释放，造成死锁。\n\n也就是说，锁保护的不是这个设备，而是设备中的某个量(这里就是`gpioled.dev_stats`)，这个量用于检查该设备是否已经/正在被其他线程使用。\n\n## 信号量(Semaphore)\n和自旋锁不同，信号量可以阻塞线程，如果获取不到信号量，线程将会进入睡眠以释放CPU资源，适用于长时间访问资源的场景（如访问文件、操作设备等）。线程会进入睡眠这点涉及上下文切换，有一定的开销。\n```\nstruct semaphore sem;\nsema_init(&sem, 1);  // 初始化信号量，初始值为1（类似互斥锁）\n\ndown(&sem);  // 🔒 获取信号量（如果已经被占用，当前线程会进入睡眠）\nshared_resource++;  // 访问共享资源\nup(&sem);    // 🔓 释放信号量\n```\n\n## 互斥体(Mutex)\n和信号量不同，互斥体中只有一个线程能获得锁（信号量允许多个线程同时访问），其他线程会阻塞（睡眠）。\n1. 结构体中声明互斥体\n```\nstruct mutex lock;\n```\n2. open函数中获取互斥体(`interruptible`表示该函数可被信号打断)\n```\nif (mutexc_lock_interruptible(&gpioled.lock)){\n    return -ERESTARTSYS;\n}\n```\n3. release时释放互斥锁\n```\nmutex_unlock(&dev->lock);\n```\n4. 初始化设备时初始化互斥锁\n```\nmutex_init(&gpioled.lock);\n```\n\n## 对比\n假设你去银行🏦取钱：\n\n- 🔢 原子变量（Atomic）：银行门口有一个“当前排队人数”显示屏，每个人来都可以安全地加 1 或减 1，但不会控制谁去办业务（只适用于简单计数）。\n\n- 🔄 自旋锁（Spinlock）：你去银行取钱，发现柜台有人，你站在那里等，直到轮到你（CPU 忙等）。\n\n- 🔢 信号量（Semaphore）：银行有多个柜台，你可以去任何空闲的柜台办理业务（多个线程同时访问）。\n\n- 🛑 互斥体（Mutex）：你去银行取钱，发现柜台有人，你去等候区坐着，等柜台空了再去（线程睡眠）。\n\n\n","categories":["嵌入式(Linux开发)"]},{"title":"Linux字符设备驱动框架","url":"/2025/03/14/Linux字符设备驱动框架/","content":"## 字符设备\n字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。最常见的点灯、按键、IIC、SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动。\n\n## 字符设备驱动工作流程\n### 加载/卸载驱动模块\nLinux的驱动有两种工作方式：\n- 驱动编译进kernel，kernel启动时自动运行驱动程序\n- 驱动编译为模块(`.ko`)，kernel启动后调用`insmod`加载驱动模块\n\n模块有加载和卸载两种操作：\n```\nmodule_init(xxx_init);  //注册模块加载\nmodule_exit(xxx_exit);  //注册模块卸载\n```\n`module_init`用于向Kernel注册一个模块加载函数，当`insmod`时，该函数就会被Kernel调用。\n\n字符设备驱动的模块加载和卸载模板如下：\n```\n/* 驱动入口 */\nstatic int __init xxx_init(void)\n{\n    /* 入口函数具体内容 */\n    return 0;\n}\n\n/* 驱动出口 */\nstatic void __exit xxx_exit(void)\n{\n    /* 出口函数具体内容 */\n}\n\n/* 将上面两个函数指定为驱动的入口和出口函数 */\nmodule_init(xxx_init); \nmodule_exit(xxx_exit); \n```\n\n驱动编译完成后，Kernel有两种命令用于加载驱动模块：`insmod`和`modprobe`：\n- `insmod`是最简单的模块加载命令，用于加载指定的`.ko`模块，比如`insmod drv.ko`。但`insmod`不能解决模块的依赖关系。\n- `modprobe`可以自动分析模块的依赖关系，然后加载所有的依赖模块到Kernel中。\n\n模块卸载则使用`rmmod`或`modprobe -r`。\n\n推荐：加载使用`modprobe`，卸载使用`rmmod`。\n\n### 注册与注销\n模块加载成功后需要注册字符设备，卸载模块时也需要注销相关字符设备：\n```\nstatic inline int register_chrdev(unsigned int major, const char *name, const struct file_operation *fops)\nstatic inline void unregister_chrdev(unsigned int major, const char *name)\n```\n`register_chrdev`用于注册字符设备，形参有：\n- `major`：主设备号\n- `name`：设备名\n- `fops`：结构体`file_operations`类型指针，指向操作函数集合变量\n\n`unregister_chrdev`用于注册字符设备，形参有：\n- `major`：主设备号\n- `name`：设备名\n\n一半字符设备的注册在入口函数中进行，注销在出口函数中执行：\n```\nstatic struct file_operations test_fops;\n\nstatic int __init xxx_init(void)\n{\n    int retvalue = 0;\n\n    /* 注册字符设备驱动 */\n    retvalue = register_chrdev(200, \"chrtest\", &test_ops);  /* 主设备号200，设备名\"chrtest\" */\n    if (retvalue < 0)\n    {\n        error_handler();\n    }\n\n    return 0;\n}\n\nstatic void __exit xxx_exit(void)\n{\n    /* 注销字符设备驱动 */\n    unregister_chrdev(200, \"chrtest\");\n}\n\n/* 将个函数指定为驱动的入口和出口函数 */\nmodule_init(xxx_init);\nmodule_exit(xxx_exit);\n```\n\n终端中`car /proc/devices`可查看当前已被使用的设备号\n\n### 实现设备的具体操作函数\n在对`test_fops`进行初始化之前，首先要分析需求，即`chrtest`这个设备需要实现哪些功能：\n1. 对`chrtest`能够进行打开和关闭操作。这是最基本的要求\n2. 对`chrtest`进行读写操作。假设设备控制着一段缓冲区（内存），应用需要通过`read`和`write`对缓冲区进行读写操作，因此需要实现`file_operations`中的`read`和`write`两个函数。\n\n修改代码：\n```\n/* 打开设备 */\nstatic int chrtest_open(struct inode *inode, struct file *filp)\n{\n    return 0;\n}\n\n/* 从设备读取 */\nstatic ssize_t chrtest_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)\n{\n    return 0;\n}\n\n/* 向设备写数据 */\nstatic ssize_t chrtest_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)\n{\n    return 0;\n}\n\n/* 关闭/释放设备 */\nstatic int chrtest_release(struct inode *inode, struct file *filp)\n{\n    return 0;\n}\n\n/* 初始化file_operations结构体 */\nstatic struct file_operations test_fops = {\n    .owner = THIS_MODULE, \n    .open = chrtest_open,\n    .read = chrtest_read,\n    .write = chrtest_write,\n    .release = chrtest_release,\n};\n\nstatic int __init xxx_init(void)\n{\n    int retvalue = 0;\n\n    /* 注册字符设备驱动 */\n    retvalue = register_chrdev(200, \"chrtest\", &test_ops);  /* 主设备号200，设备名\"chrtest\" */\n    if (retvalue < 0)\n    {\n        error_handler();\n    }\n\n    return 0;\n}\n\nstatic void __exit xxx_exit(void)\n{\n    /* 注销字符设备驱动 */\n    unregister_chrdev(200, \"chrtest\");\n}\n\n/* 将个函数指定为驱动的入口和出口函数 */\nmodule_init(xxx_init);\nmodule_exit(xxx_exit);\n```\n\n这里的函数形参需要使用Linux驱动框架所规定的标准格式：\n- `struct inode *inode`：指向设备文件的 索引节点，描述了文件的元数据（如权限、文件类型等）\n- `struct file *filp`：表示 已打开的文件，包含文件的当前状态、访问模式等信息。\n- `char __user *buf`：用户空间的缓冲区，内核需要将数据拷贝到这个缓冲区\n- `size_t cnt`：写入的字节数，表示用户请求写入的长度\n- `loff_t *offt`：文件偏移量，用于支持文件的随机访问\n\n### 添加LICENSE和作者信息\nLICENSE不添加编译会报错：\n```\nMODULE_LICENSE();\n```\n\n### 设备号分配\n#### 静态分配\nWIP\n\n#### 动态分配\n推荐使用动态分配设备号：\n```\nint alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)\n```\n- `dev`：保存申请到的设备号\n- `baseminor`：次设备号起始地址，alloc_chrdev_region 可以申请一段连续的多个设备号，这些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递增。一般 baseminor 为 0，也就是说次设备号从 0 开始。\n- `count`：要申请的设备号数量\n- `name`：设备名\n\n释放设备号函数：\n```\nvoid unregister_chrdev_region(dev_t from, unsigned count)\n```\n- `from`：要释放的设备号\n- `count`：从`from`开始要释放的设备号数量\n\n#### cdev\ncdev 是 Linux 内核中用于表示字符设备的一个结构体。它是 Linux 字符设备驱动中非常重要的一部分，主要用于管理字符设备的注册和文件操作的绑定。当注册一个字符设备时，cdev 会帮助内核处理与设备相关的操作。\n```\nstruct cdev {\n    struct kobject kobj;\n    struct module *owner;\n    const struct file_operations *ops;  // 设备的文件操作结构\n    struct list_head list;  // 链接到系统设备列表\n    dev_t dev;  // 设备号\n};\n```\ncdev 的主要任务是将文件操作函数（例如：open、read、write 等）和设备进行关联。当设备被打开、读写或释放时，内核会通过 cdev 结构体找到相应的操作函数并调用它们。\n\ncdev应当按照顺序被使用：\n1. 初始化\n```\nstruct cdev chrdev_cdev;\ncdev_init(&chrdev_cdev, &fops);\n```\n这个操作可以通过`cdev_alloc()`来一次性完成：\n```\nstruct cdev *cdev_alloc(void)\n{\n\tstruct cdev *p = kzalloc(sizeof(struct cdev), GFP_KERNEL);\n\tif (p) {\n\t\tINIT_LIST_HEAD(&p->list);\n\t\tkobject_init(&p->kobj, &ktype_cdev_dynamic);\n\t}\n\treturn p;\n}\n```\n2. 注册字符设备：使用 `cdev_add` 函数将其注册到内核。这样，内核就能够在收到对该设备的请求时，调用对应的文件操作函数。\n```\nint ret = cdev_add(&chrdev_cdev, dev_num, 1);\nif (ret < 0) {\n    printk(\"Failed to add cdev\\n\");\n    return ret;\n}\n```\n3. 注销字符设备\n```\ncdev_del(&chrdev_cdev);\n```\n\n#### 其他\n驱动中还会用到`copy_to_user`函数：\n```\nstatic inline long copy_to_user(void __user *to, const void *from, unsigned long n)\n```\n该函数用于将内核空间中的数据复制到用户空间。\n\n## 测试APP\n### C库文件操作\n#### open()\n```\nint open(const char *pathname, int flags)\n```\n- `pathname`:要打开的设备或者文件名\n- `flags`：文件打开模式，以下三种模式必选其一：\n    + `O_RDONLY` 只读模式\n    + `O_WRONLY` 只写模式\n    + `O_RDWR` 读写模式\n\n如果文件打开成功的话返回文件的文件描述符.\n### read()\n```\nssize_t read(int fd, void *buf, size_t count)\n```\n- `fd`:要读取的文件描述符，读取文件之前要先用 open 函数打开文件，open 函数打开文件成功以后会得到文件描述符\n- `buf`:数据读取到此 buf 中\n- `count`:要读取的数据长度，也就是字节数\n\n读取成功的话返回读取到的字节数；如果返回 0 表示读取到了文件末尾；如果返回负值，表示读取失败。\n\n### write()\n```\nssize_t write(int fd, const void *buf, size_t count);\n```\n- `fd`:要进行写操作的文件描述符，写文件之前要先用 open 函数打开文件，open 函数打开文件成功以后会得到文件描述符\n- `buf`:要写入的数据\n- `count`:要写入的数据长度，也就是字节数\n\n返回值：写入成功的话返回写入的字节数；如果返回 0 表示没有写入任何数据；如果返回\n负值，表示写入失败\n\n### close()\n```\nint close(int fd);\n```\n\n0 表示关闭成功，负值表示关闭失败。\n\n## fops、cdev、class、device \n\n1. 定义 fops，提供 read/write/open/close/ioctl 操作\n2. 定义 cdev，并绑定 fops\n3. 注册 cdev，并分配 major/minor 设备号\n4. 创建 class，供 udev 识别\n5. 创建 device，在 `/dev/` 下自动生成设备文件\n\n\n## 完整流程\n1. 定义设备信息，用于注册设备至kernel\n```\nstatic dev_t chrdev_devno;\n```\n2. 定义文件操作结构体，用于封装用于操作外设的功能函数\n```\nstatic struct file_operations chrdev_fops = {\n    .owner = THIS_MODULE,\n    .open = chrdev_open,\n    .read = chrdev_read,\n    .write = chrdev_write,\n    .release = chrdev_release,\n};\n```\n3. 实现设备操作函数\n```\nstatic int chrdev_open(struct inode *inode, struct file *filp) {\n    return 0;\n}\n\nstatic ssize_t chrdev_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt) {\n    return 0;\n}\n\nstatic ssize_t chrdev_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt) {\n    return 0;\n}\n\nstatic int chrdev_release(struct inode *inode, struct file *filp) {\n    return 0;\n}\n```\n4. 初始化和清理\n```\nstatic int __init chrdev_init(void) {\n    int ret;\n    ret = alloc_chrdev_region(&chrdev_devno, 0, 1, \"chrdevbase\");   //动态分配设备号\n    if (ret < 0) {\n        printk(\"Failed to register device\\n\");\n        return ret;\n    }\n    cdev_init(&chrdev_cdev, &chrdev_fops);      //注册cdev\n    ret = cdev_add(&chrdev_cdev, chrdev_devno, 1);      //添加cdev\n    if (ret < 0) {\n        unregister_chrdev_region(chrdev_devno, 1);\n        printk(\"Failed to add cdev\\n\");\n        return ret;\n    }\n    return 0;\n}\n\nstatic void __exit chrdev_exit(void) {\n    cdev_del(&chrdev_cdev);     //销毁cdev\n    unregister_chrdev_region(chrdev_devno, 1);      //注销设备号\n}\n\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\n5. 创建节点。如果应用程序要想使用设备，还必须创建字符设备节点：\n```\nmknod /dev/chrdev c 249 0\n```\n然后应用程序才能将设备号和具体的设备连接起来并使用。\n\n如果初始化中创建了`device`和`class`类，会自动生成节点。\n\n## LED点灯示例\n```\n/* **************Includes************** */\n#include \"linux/fs.h\"\n#include \"linux/printk.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/ide.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/gpio.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <asm/mach/map.h>\n#include <asm/uaccess.h>\n#include <asm/io.h>\n\n/* **************Defines************** */\n#define LED_DEVICE_CNT    1\n#define LED_DEVICE_NAME   \"led_dev\"\n#define LEDON   1\n#define LEDOFF  0\n\n/* 寄存器物理地址 */\n#define CCM_CCGR1_BASE            (0x020C406C)\n#define SW_MUX_GPIO1_IO03_BASE    (0x020E0068)\n#define SW_PAD_GPIO1_IO03_BASE    (0x020E02F4)\n#define GPIO1_DR_BASE             (0x0209C000)\n#define GPIO1_GDIR_BASE           (0x0209C004)\n\n/* 寄存器虚拟地址 */\nstatic void __iomem *IMX6U_CCM_CCGR1;\nstatic void __iomem *SW_MUX_GPIO1_IO03;\nstatic void __iomem *SW_PAD_GPIO1_IO03;\nstatic void __iomem *GPIO1_DR;\nstatic void __iomem *GPIO1_GDIR;\n\n/* 设备结构体 */\nstruct led_dev{\n  dev_t devid;\n  struct cdev cdev;\n  struct class *class;\n  struct device *device;\n  int major;\n  int minor;\n};\n\n/* 声明实例 */\nstruct led_dev led;\n\n/* LED切换开关函数 */\nvoid led_switch(u8 status)\n{\n  u32 val = 0;\n\n  if (status == LEDON){\n    val = readl(GPIO1_DR);\n    val &= ~(1 << 3);\n    writel(val, GPIO1_DR);\n  }else if (status == LEDOFF){\n    val = readl(GPIO1_DR);\n    val |= (1 << 3);\n    writel(val, GPIO1_DR);\n  }\n}\n\n/***********  fops结构体函数填充 **************/\nstatic int led_open(struct inode *inode, struct file *filp)\n{\n  filp->private_data = &led;  /* 设置私有变量 */\n  return 0;\n}\n\nstatic ssize_t led_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)\n{\n  return 0;\n}\n\nstatic ssize_t led_write(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)\n{\n  int retvalue;\n  unsigned char databuf[1];\n  unsigned char led_status;\n\n  retvalue = copy_from_user(databuf, buf, cnt);\n  if (retvalue < 0){\n    printk(\"copy from user failed\\r\\n\");\n    return -EFAULT;\n  }\n\n  led_status = databuf[0];\n\n  switch (led_status) {\n    case LEDON:\n      led_switch(LEDON);\n      break;\n    case LEDOFF:\n      led_switch(LEDOFF);\n      break;\n  }\n\n  return 0;\n}\n\nstatic int led_release(struct inode *inode, struct file *filp)\n{\n  return 0;\n}\n\n/* fops结构体 */\nstatic struct file_operations led_fops = {\n  .owner = THIS_MODULE,\n  .open = led_open,\n  .read = led_read,\n  .write = led_write,\n  .release = led_release,\n};\n\n/* 设备初始化函数 */\nstatic int __init led_init(void)\n{\n  int retvalue = 0;\n  u32 val = 0;\n\n  /* 获取寄存器虚拟地址 */\n  IMX6U_CCM_CCGR1 = ioremap(CCM_CCGR1_BASE, 4);\n  SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, 4);\n  SW_PAD_GPIO1_IO03 = ioremap(SW_PAD_GPIO1_IO03_BASE, 4);\n  GPIO1_DR = ioremap(GPIO1_DR_BASE, 4);\n  GPIO1_GDIR = ioremap(GPIO1_GDIR_BASE, 4);\n\n  /* 使能时钟 */\n  val =readl(IMX6U_CCM_CCGR1);\n  val &= ~(3 << 26);\n  val |= (3 << 26);\n  writel(val, IMX6U_CCM_CCGR1);\n\n  /* 设置 GPIO1_IO03 复用 */\n  writel(5, SW_MUX_GPIO1_IO03);\n\n  /* 配置 GPIO1_IO03 */\n  writel(0x10B0, SW_PAD_GPIO1_IO03);\n\n  /* 设置 GPIO1_IO03 为输出 */\n  val = readl(GPIO1_GDIR);\n  val &= ~(1 << 3);\n  val |= (1 << 3);\n  writel(val, GPIO1_GDIR);\n\n  /* 注册设备 */\n  if (led.major){\n    /* 如果事先指定了主设备号 */\n    led.devid = MKDEV(led.major, 0);\n    register_chrdev_region(led.devid, LED_DEVICE_CNT, LED_DEVICE_NAME);\n  }else {\n    /* 动态分配 */\n    alloc_chrdev_region(&led.devid, 0, LED_DEVICE_CNT, LED_DEVICE_NAME);\n    led.major = MAJOR(led.devid);\n    led.minor = MINOR(led.devid);\n  }\n  printk(\"led register ok: major= %d, minor = %d\\r\\n\", led.major, led.minor);\n\n  /* 初始化Cdev */\n  led.cdev.owner = THIS_MODULE;\n  cdev_init(&led.cdev, &led_fops);\n\n  /* 向内核注册cdev */\n  retvalue = cdev_add(&led.cdev, led.devid, LED_DEVICE_CNT);\n  if (retvalue < 0){\n    printk(\"cdev add failed\\r\\n\");\n    return retvalue;\n  }\n\n  /* 创建设备类 */\n  led.class = class_create(THIS_MODULE, LED_DEVICE_NAME);\n  if (IS_ERR(led.class)){\n    printk(\"class create failed\\r\\n\");\n    return PTR_ERR(led.class);\n  }\n\n  /* 创建设备实例 */\n  led.device = device_create(led.class, NULL, led.devid, NULL, LED_DEVICE_NAME);\n  if (IS_ERR(led.device)){\n    printk(\"device create failed\\r\\n\");\n    return PTR_ERR(led.device);\n  }\n\n  return 0;\n}\n\n/* 设备出口函数 */\nstatic void __exit led_exit(void)\n{\n  /* 释放寄存器映射 */\n  iounmap(IMX6U_CCM_CCGR1);\n  iounmap(SW_MUX_GPIO1_IO03);\n  iounmap(SW_PAD_GPIO1_IO03);\n  iounmap(GPIO1_DR);\n  iounmap(GPIO1_GDIR);\n\n  /* 销毁cdev，注销设备号 */\n  cdev_del(&led.cdev);\n  unregister_chrdev_region(led.devid, LED_DEVICE_CNT);\n\n  /* 销毁设备类和设备实例 */\n  device_destroy(led.class, led.devid);\n  class_destroy(led.class);\n}\n\nmodule_init(led_init);\nmodule_exit(led_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"aki\");\n\n\n```","categories":["嵌入式(Linux开发)"]},{"title":"IMX6ULL Linux内核移植","url":"/2025/03/11/Linux内核移植/","content":"## 准备工作\n### 网络设置\n关闭主机的Ubuntu的防火墙：\n```\nsudo ufw disable\n```\n确认VMWare使用桥接模式，主机、虚拟机和开发板三者处于同一网段，如：\n- 主机：192.168.1.100\n- 虚拟机：192.168.1.105\n- 开发板：192.168.1.103 (DHCP获取)\n\n在uboot下，开发板ping虚拟机和主机、虚拟机ping主机应当都能ping通。未加载Linux内核前网卡尚未使能，虚拟机ping开发板应当ping不通。\n\n### TFTP搭建\nTFTP常见用途：\n- U-Boot 加载 Linux 内核、设备树和根文件系统\n- NFS 结合 TFTP 进行网络启动\n- 固件更新\n- 开发调试\n\n安装xinetd：\n```\nsudo apt install xinetd\n```\n检查`/etc/xinetd.conf`是否存在，不存在则创建，修改内容如下：\n```\n# Simple configuration file for xinetd\n#\n# Some defaults, and include /etc/xinetd.d/\ndefaults\n{\n# Please note that you need a log_type line to be able to use log_on_success\n# and log_on_failure. The default is the following :\n# log_type = SYSLOG daemon info\n}\nincludedir /etc/xinetd.d\n```\n新建TFTP目录于`/home/aki/linux`，然后`chmod 777`该目录。\n\n安装tftp-hpa和tftpd-hpa：\n```\nsudo apt install tftp-hpa tftpd-hpa\n```\n安装完后，`sudo nvim /etc/default/tftpd-hpa`，修改tftp目录为TFTP服务器工作目录：\n\n![TFTP_DIRECTORY](/images/linux/linux_1.png)\n\n然后`sudo nvim /etc/xinetd.d/tftp`，添加：\n```\nserver tftp\n {\n socket_type = dgram\n wait = yes\n disable = no\n user = root\n protocol = udp\n server = /usr/sbin/in.tftpd\n server_args = -s /home/aki/linux/tftp -c\n #log_on_success += PID HOST DURATION\n #log_on_failure += HOST\n per_source = 11\n cps =100 2\n flags =IPv4\n }\n```\n保存，重启TFTP服务：`sudo service tftpd-hpa restart`，重启xinetd服务：`sudo service xinetd restart`\n\n### NFS搭建\nNFS主要用于：\n- 嵌入式设备的根文件系统（RootFS）挂载：在开发阶段，NFS 服务器可以存放 根文件系统（RootFS），嵌入式设备通过网络直接挂载，而无需烧录到 Flash 或 SD 卡\n- 远程文件访问：如开发板访问PC共享目录\n\n安装NFS服务：\n```\nsudo apt install nfs-kernel-server\n```\n新建NFS共享目录并`chmod 777`：\n```\nsudo mkdir /home/aki/linux/nfs\nsudo chmod 777 /home/aki/linux/nfs\n```\n安装完后，`sudo nvim /etc/exports`，在最后添加：\n```\n/home/aki/linux/nfs *(rw,sync,no_root_squash)\n```\n保存退出，重启NFS服务：`sudo /etc/init.d/nfs-kernel-server restart`，确认共享目录已经配置完毕：`shouwmount -e`\n\n## Linux镜像测试\n先确认官方linux镜像是否可以。在linux根目录中，修改顶层Makefile，添加`ARCH`和`CROSS_COMPILE`变量，然后\n```\nmake clean\nmake imx_v7_mfg_defconfig\n```\n然后\n```\nmake -j16\n```\nmake完成后makefile会提示得到两个重要的文件：\n- zImage：linux内核镜像，位于`/arch/arm/boot/`\n- imx6ull-14x14-evk.dtb：编译后的设备树文件，位于`/arch/arm/boot/dts/`\n\n然后，启动uboot，设置uboot中的env`bootargs`为：\n```\nconsole=ttymxc0,115200 root=/dev/mmcblk 1p2 rootwait rw\n```\n表明将从eMMC/SD卡的第2分区启动 Linux。然后，修改`bootcmd`：\n```\nsetenv bootcmd 'tftp 80800000 zImage;tftp 83000000 imx6ull-14x14-evk.dtb;bootz 80800000 - 83000000`\n```\n表明将通过TFTP从虚拟机拉取内核镜像和设备树并启动内核。然后，`boot`，启动内核。\n\n\n## 配置主频、EMMC和网络驱动\n### 主频设置\nWIP\n\n### EMMC设置\n6.6版本的Kernel已经默认禁用1.8V供电，同时自动启用了8位宽的EMMC总线，所以不用进行其他的设置。\n\n### 网络驱动\n和uboot中进行过的很像。已知NXP原版设备树中的SPI4节点中的两个引脚和SR8201F的冲突，因此打开`/arch/arm/boot/dts/nxp/imx/imx6ul-14x14-evk.dtsi`这个底层设备树，找到`pinctrl_spi4: spi4grp`这个节点，删掉包含`GPIO5 7`和`GPIO5 8`的两行。然后前往`SPI4`的子节点，把status改成`disable`，直接禁用掉SPI4。\n\n然后，修改pinctrl复用信息，来到`&iomuxc`节点，在节点末尾新增两个`pinctrl group`：\n```\npinctrl_enet1_reset: enet1resetgrp {\n    fsl,pins = <\n        /* used for enet1 reset */\n        MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07 0x10B0 \n    >;\n};\n\npinctrl_enet2_reset: enet2resetgrp {\n    fsl,pins = <\n        /* used for enet2 reset */\n        MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08 0x10B0 \n    >;\n};\n```\n按照步骤还需要修改ENET1和ENET2的网络时钟引脚配置，但是6.6版本的kernel设备树已经添加了，就不用手动操作了。\n\n继续，在`fec1`和`fec2`节点里加入刚刚设置好的复位引脚的`pinctrl group`信息：\n```\n&fec1 {\n    .....\n    pinctrl-0 = <&pinctrl_enet1\n                 &pinctrl_enet1_reset>;\n    .....\n}\n\n&fec2 {\n    .....\n    pinctrl-0 = <&pinctrl_enet2\n                 &pinctrl_enet2_reset>;\n    .....\n}\n```\n继续，检查设备树`fec1`和`fec2`节点下`mdio`子节点中的PHY地址是否正确。新版kernel默认都是设置好的。\n\n然后，在`defconfig`里告知kernel使用realtek的PHY驱动：\n```\nCONFIG_REALTEK_PHY=y\n```\n\n最后，根据SR8201F复位后至少延时150ms才能开始使用的要求，修改`drivers/net/ethernet/freescale/fec_main.c`，在`static void fec_reset_phy()`函数的末尾加入:\n```\nmsleep(200);\n```\n重新编译kernel，然后启动，通过`ifconfig`观察网卡是否工作正常（正常情况下ETH1会自动启动）：\n```\nifconfig eth0 up    //启动ETH0网卡\nifconfig eth1 up    //启动ETH1网卡\nifconfig eth0 192.168.xx.xx\nifconfig eth1 192.168.xx.xx\n```\n\n## 构建根文件系统\n使用busybox构建，在busybox根目录的顶层Makefile中添加`ARCH`和`CORSS_COMPILE`，然后：\n```\nmake defconfig\nmake menuconfig\n```\n进入图形化配置界面：\n- 选中Settings->Build static binary\n- 选中Setttings->vi-style line editing commands\n- 取消选中Linux Module Utilities->Simpilified modutils\n\n编译busybox时必须使用静态库，动态库会缺库文件导致dns解析没法正常使用。\n\n然后，\n```\nmake \nmake install CONFIG_PREFIX=/home/aki/linux/nfs/rootfs\n```\n*注意*：1.37.0版本busybox报告有一个bug，即：\n```\ncompilation\nof tc.c fails with: \n\nnetworking/tc.c: In function ‘cbq_print_opt’:\nnetworking/tc.c:236:27: error: ‘TCA_CBQ_MAX’ undeclared (first use in this\nfunction); did you mean ‘TCA_CBS_MAX’?\n  236 |         struct rtattr *tb[TCA_CBQ_MAX+1];\n      |                           ^~~~~~~~~~~\n      |                           TCA_CBS_MAX\n————————————————\n```\n和CBQ队列管理有关的大量宏会报错，解决方法是把`tc.c`从`/busybox/networking`文件夹里删除。\n\n然后，需要将编译器所包含的库文件全部打包到根目录下。\n\n使用NFS挂载时，bootargs要设成：\n```\nsetenv bootargs 'console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.105:/home/aki/linux/nfs/rootfs,vers=3,proto=tcp rw ip=192.168.1.103:192.168.1.105:192.168.1.1:255.255.255.0::eth0:off'\n```\n*注意*：这里通过`vers=3`强制使用NFS v3版本，否则会挂载失败。\n\n\n如果碰到hotplug：can’t create /proc/sys/kernel/hotplug: nonexistent directory问题：[参见](https://blog.csdn.net/m0_51149752/article/details/146395215?spm=1001.2014.3001.5502)\n\n`fstab`要加一行：\n```\nmdev  /dev  ramfs defaults 0 0\n```","categories":["嵌入式(Linux开发)"]},{"title":"NXP 官方u-boot移植和启动过程","url":"/2025/03/07/uboot移植/","content":"## 官方U-Boot下载\n[Github](https://github.com/nxp-imx/uboot-imx)\n下载后拷贝`tar.bz2`至Linux，然后`tar -vxjf`\n\n## U-boot工程目录\n![编译后的uboot源码](/images/linux/uboot_7.png)\n除了文件夹之外，还有一些文件：\n![编译后的uboot源码](/images/linux/uboot_8.png)\n\n## 验证defconfig\n`cd /configs/`，确认存在有I.MX6ULL的配置文件：\n\n![mx6ull配置文件](/images/linux/uboot_1.png)\n\n新版本uboot中`mx6ull_14x14_evk_defconfig`用于传统的非安全启动（Non-Secure Boot）模式，而`mx6ull_14x14_evk_plugin_defconfig`支持安全启动（Secure Boot），允许 U-Boot 在 ROM 加载阶段执行自定义代码，通常用于 HAB 安全启动初始化（如 DRAM 训练）。通常使用前者即可。\n\n## 添加变量至顶层Makefile\n在uboot根目录下的顶层Makefile中添加：\n```\nARCH=arm\nCROSS_COMPILE=arm-linux-gnueabihf-\n```\n\n## 编写make用Shell，编译\n1. `touch mx6ull_14x14_evk.sh`\n2. \n```\n#!/bin/bash\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_evk_emmc_defconfig\nmake V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16\n```\n3. `chmod 777 mx6ull_14x14_evk.sh`\n4. `./mx6ull_14x14_evk.sh`，编译\n\n这里用的uboot是NXP最新的分支`v2022.04`，这个uboot版本比较新，如果用老版本的交叉编译器会报错，因为它不支持比较新的语法。这里使用的uboot、kernel和编译器的版本都为：\n- uboot：`v2022.04`\n- kernel：`if 6.6y`\n- arm-linux-gnueabihf-gcc: `7.5.0`\n\n编译完成后，`imxdownload`烧录至SD卡，设置开发板从SD卡启动。\n\n此时Uboot启动之后，由于LCD未做配置，LCD上是不会显示NXP的Logo的。下一步是修改LCD驱动。\n\n## 修改LCD驱动\nIO部分不用修改，官方和开发板一致，仅需修改参数。较老版本的LCD参数在`board/freescale/mx6ull_aki/mx6ull_14x14_evk_emmc.c`的`display_info_t`结构体里。但是新版本uboot全部把诸如LCD之类的外设配置参数全部移到了设备树中。并且，imx6ull是由imx6ul这块板子拓展而来的，二者的设备树也呈非常明显的层次关系，即先读imx6ul的设备树，再读imx6ull的，所以很多外设节点都在`/arch/arm/dts/imx6ul-14x14-evk.dtsi`这个设备树文件中定义。\n\n打开该设备树文件，找到：\n```\n&lcdif {\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_lcdif_dat\n\t\t     &pinctrl_lcdif_ctrl>;\n\n\tdisplay = <&display0>;\n\tstatus = \"okay\";\n\n\tdisplay0: display@0 {\n\t\tbits-per-pixel = <24>;\n\t\tbus-width = <24>;\n\n\t\tdisplay-timings {\n\t\t\tnative-mode = <&timing0>;\n\t\t\ttiming0: timing0 {\n\t\t\tclock-frequency = <51200000>;\t//像素时钟频率，Hz\n\t\t\thactive = <1024>;\t\t//水平可见像素数（水平分辨率）\n\t\t\tvactive = <600>;\t\t//垂直可见像素数（垂直分辨率）\n\t\t\thfront-porch = <160>;\t//水平前肩，HFP\n\t\t\thback-porch = <140>;\t//水平后肩，HBP\n\t\t\thsync-len = <20>;\t\t//水平同步脉冲，HSPW\n\t\t\tvback-porch = <20>;\t\t//水平后肩，VBP\n\t\t\tvfront-porch = <12>;\t//水平前肩，VFP\n\t\t\tvsync-len = <3>;\t\t//垂直同步脉冲，VSPW\n\n\t\t\thsync-active = <0>;\t\t//水平同步信号极性\n\t\t\tvsync-active = <0>;\t\t//垂直同步信号极性\n\t\t\tde-active = <1>;\t\t//数据使能，高电平有效\n\t\t\tpixelclk-active = <0>;\t//下降沿采样\n\t\t\t};\n\t\t};\n\t};\n};\n```\n按注释修改即可。新版设备树似乎没有定义LCD名字的地方，感觉不是那么在意设备名，毕竟都用设备树了。\n\n## 联网\n### 主机部分\n物理部分：路由器WAN连接校园网，LAN1接电脑，LAN2接开发板ENET2（网卡1）。\n\nVMware需开启桥接模式：\n![桥接模式](/images/linux/uboot_5.png)\n\n虚拟网络编辑器中一般会自动设置桥接网卡，不用手动设置。桥接模式下虚拟机和物理主机一样存在于局域网中，可以和主机相通，和互联网相通，和局域网中其它主机相通。\n\n配置成桥接模式后虚拟机的IP、网关、DNS、netmask等全部会自动配置。在虚拟机中`ifconfig`：\n```\nens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.1.105  netmask 255.255.255.0  broadcast 192.168.1.255\n        ether 00:0c:29:0d:4a:09  txqueuelen 1000  (以太网)\n        RX packets 4642  bytes 4241810 (4.2 MB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 2980  bytes 400799 (400.7 KB)\n        TX errors 0  dropped 5 overruns 0  carrier 0  collisions 0\n\nlo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536\n        inet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10<host>\n        loop  txqueuelen 1000  (本地环回)\n        RX packets 1298  bytes 110055 (110.0 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 1298  bytes 110055 (110.0 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n此时主机的IPv4地址为192.168.1.100，可以看到桥接模式已经生效，主机和虚拟机处于同一个网段下。\n\n### 板级部分\n官方的NXP IMX6ULL EVK开发板使用的不是LAN8720A这个IC，因此需要修改一系列设置。好在官方的板子和正点原子阿尔法开发板的PHY物理地址是一致的，这点从设备树里可以看到：\n```\n&fec1 {\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_enet1>;\n\tphy-mode = \"rmii\";\n\tphy-handle = <&ethphy0>;\n  phy-reset-gpios = <&gpio5 7 GPIO_ACTIVE_LOW>;\n  phy-reset-duration = <100>;\n  phy-reset-post-delay = <100>;\n\tstatus = \"disable\";\n};\n\n&fec2 {\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_enet2>;\n\tphy-mode = \"rmii\";\n\tphy-handle = <&ethphy1>;\n  phy-reset-gpios = <&gpio5 8 GPIO_ACTIVE_LOW>;\n  phy-reset-duration = <100>;\n  phy-reset-post-delay = <100>;\n\tstatus = \"okay\";\n\n\tmdio {\n\t\t#address-cells = <1>;\n\t\t#size-cells = <0>;\n\n\t\tethphy0: ethernet-phy@2 {\n\t\t\treg = <2>;\t//PHY0物理地址为2\n\t\t\tmicrel,led-mode = <1>;\n\t\t\tclocks = <&clks IMX6UL_CLK_ENET_REF>;\n\t\t\tclock-names = \"rmii-ref\";\n\t\t};\n\n\t\tethphy1: ethernet-phy@1 {\n\t\t\treg = <1>;\t//PHY1物理地址为1\n\t\t\tmicrel,led-mode = <1>;\n\t\t\tclocks = <&clks IMX6UL_CLK_ENET2_REF>;\n\t\t\tclock-names = \"rmii-ref\";\n\t\t};\n\t};\n};\n```\n### 初始化检查\n检查`/common/board_r.c`，其中从网络初始化入口`initr_net`开始Uboot会进行网络设置，其中`initr_net`会调用`eth_initialize()`进行网络初始化，然后调用`reset_phy()`对PHY进行复位，而`phy_init()`中有以下条件宏语句：\n```\nint phy_init(void)\n{\n...\n#ifdef CONFIG_PHY_MICREL_KSZ8XXX\n    phy_micrel_ksz8xxx_init();\n#endif \n#ifdef CONFIG_PHY_MICREL_KSZ90X1\n    phy_micrel_ksz90x1_init();\n#endif\n...\n#ifdef CONFIG_PHY_SMSC\n    phy_smsc_init();\n#endif\n...\n    genphy_init();\n \n    return 0;\n}\n```\n显然这是根据`defconfig`里的键值来对应不同的PHY初始化函数。阿尔法开发板上的SR8201F是Realtek公司生产的，因此根据`phy_init`，`defconfig`里要设置`CONFIG_PHY_REALTEK=y`才会触发`phy_realtek_init()`这个函数。\n\n打开`/configs/imx6ull_14x14_evk_emmc_defconfig`，删除或屏蔽：\n```\nCONFIG_PHY_MICREL=y\nCONFIG_PHY_MICREL_KSZ8XXX=y\n```\n添加：\n```\nCONFIG_PHY_REALTEK=y\n```\n（不过这里我一开始错误的改成了`CONFIG_PHY_SMSC=y`，发现网络也能正常使用，不知道为什么）\n### 配置fec复位管脚\n`fecmxc_probe`函数中还调用了`fec_gpio_reset()`来复位fec网卡：\n```\n#if CONFIG_IS_ENABLED(DM_GPIO)\n\tfec_gpio_reset(priv);\n#endif\n\t/* Reset chip. */\n\twritel(readl(&priv->eth->ecntrl) | FEC_ECNTRL_RESET,\n\t       &priv->eth->ecntrl);\n\tstart = get_timer(0);\n\twhile (readl(&priv->eth->ecntrl) & FEC_ECNTRL_RESET) {\n\t\tif (get_timer(start) > (CONFIG_SYS_HZ * 5)) {\n\t\t\tprintf(\"FEC MXC: Timeout resetting chip\\n\");\n\t\t\tgoto err_timeout;\n\t\t}\n\t\tudelay(10);\n\t}\n```\n而这里设备树会使用`fecmxc_of_to_plat`这个OF函数来读取节点信息到驱动，该函数中有：\n```\n#if CONFIG_IS_ENABLED(DM_GPIO)\n\tret = gpio_request_by_name(dev, \"phy-reset-gpios\", 0,\n\t\t\t\t   &priv->phy_reset_gpio, GPIOD_IS_OUT);\n\tif (ret < 0)\n\t\treturn 0; /* property is optional, don't return error! */\n\n\tpriv->reset_delay = dev_read_u32_default(dev, \"phy-reset-duration\", 1);\n\tif (priv->reset_delay > 1000) {\n\t\tprintf(\"FEC MXC: phy reset duration should be <= 1000ms\\n\");\n\t\t/* property value wrong, use default value */\n\t\tpriv->reset_delay = 1;\n\t}\n\n\tpriv->reset_post_delay = dev_read_u32_default(dev,\n\t\t\t\t\t\t      \"phy-reset-post-delay\",\n\t\t\t\t\t\t      0);\n\tif (priv->reset_post_delay > 1000) {\n\t\tprintf(\"FEC MXC: phy reset post delay should be <= 1000ms\\n\");\n\t\t/* property value wrong, use default value */\n\t\tpriv->reset_post_delay = 0;\n\t}\n#endif\n```\n可以看到这里依赖节点的三个用于描述复位的值：\n- `phy-reset-gpios`\n- `phy-reset-duration`\n- `phy-reset-post-delay`\n\n回到设备树，将这三个属性加进节点：\n```\n&fec1 {\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_enet1>;\n\tphy-mode = \"rmii\";\n\tphy-handle = <&ethphy0>;\n    phy-reset-gpios = <&gpio5 7 GPIO_ACTIVE_LOW>;\n    phy-reset-duration = <100>;\n    phy-reset-post-delay = <100>;\n\tstatus = \"disable\";\n};\n\n&fec2 {\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_enet2>;\n\tphy-mode = \"rmii\";\n\tphy-handle = <&ethphy1>;\n    phy-reset-gpios = <&gpio5 8 GPIO_ACTIVE_LOW>;\n    phy-reset-duration = <100>;\n    phy-reset-post-delay = <100>;\n\tstatus = \"okay\";\n\n\tmdio {\n\t\t#address-cells = <1>;\n\t\t#size-cells = <0>;\n\n\t\tethphy0: ethernet-phy@2 {\n\t\t\treg = <2>;\n\t\t\tmicrel,led-mode = <1>;\n\t\t\tclocks = <&clks IMX6UL_CLK_ENET_REF>;\n\t\t\tclock-names = \"rmii-ref\";\n\t\t};\n\n\t\tethphy1: ethernet-phy@1 {\n\t\t\treg = <1>;\n\t\t\tmicrel,led-mode = <1>;\n\t\t\tclocks = <&clks IMX6UL_CLK_ENET2_REF>;\n\t\t\tclock-names = \"rmii-ref\";\n\t\t};\n\t};\n};\n```\n`GPIO5_IO07`和`GPIO5_IO08`会跟SPI4的两个IO冲突，这里直接把spi4 disable掉即可。通常uboot会自动加载fec2，为了方便起见，我把fec1也disable了。\n\n最后，还需要在`/drviers/net/phy`中，找到`genphy_config_aneg`函数，这个函数负责PHY自协商的完整配置，在初始化PHY时会调用（通过操作`BMCR_RESET`位）。在函数中加入：\n```\nint genphy_config_aneg(struct phy_device *phydev)\n{\n\tint result;\n  \n  /* Soft reset */\n  phy_reset(phydev);\n  mdelay(150);\t//IC要求复位后延时150ms\n\n  ......\n}\n```\n\n### uboot设置\n在uboot内设置开发板网络配置：\n```\nsetenv ipaddr 192.168.1.55\nsetenv ethaddr b8:ae:1d:01:00:00\nsetenv gatewayip 192.168.1.1\nsetenv netmask 255.255.255.0\nsetenv serverip 192.168.1.105   # Ubuntu IP\n```\n然后`saveenv`，保存变量。\n\nuboot支持自动配置物理地址，只需要在defconfig中加入：`CONFIG_NET_RANDOM_ETHADDR=y`\n\n如果对静态IP没有要求，或者想要简单一点，可以直接在Uboot内使用`DHCP`命令。DHCP会自动申请可用IP，自动配置网关、DNS、子网掩码等。\n\n此时在Uboot内ping 虚拟机地址`192.168.1.105`，应当是能Ping通的。为防止IP被复用，关闭虚拟机，再Ping一次虚拟机，如果无法Ping通，说明配置正确：\n![Ping测试](/images/linux/uboot_6.png)\n\n反过来，从虚拟机Ping开发板，肯定是Ping不通的（Ping通了说明有问题，这个IP被其他的什么东西复用了），因为此时Linux内核还未启动，网口不会被使能。\n\n此时，三台机器的IP地址分别为：\n- 主机：192.168.1.100\n- 虚拟机：192.168.1.105\n- 开发板：192.168.1.101(DHCP获取)\n\n## uboot启动流程\n### reset函数\nuboot编译后会在根目录下生成链接脚本`u-boot.lds`。其内容的前几行里有：\n```\nOUTPUT_FORMAT(\"elf32-littlearm\", \"elf32-littlearm\", \"elf32-littlearm\")\nOUTPUT_ARCH(arm)\nENTRY(_start)\nSECTIONS\n{\n    ........\n```\n很显然第3行的`ENTRY(_start)`中的`_start`是代码入口点，在`arch/arm/lib/vectors.S`中定义：\n```\n/*\n *  vectors - Generic ARM exception table code\n *\n *  Copyright (c) 1998\tDan Malek <dmalek@jlc.net>\n *  Copyright (c) 1999\tMagnus Damm <kieraypc01.p.y.kie.era.ericsson.se>\n *  Copyright (c) 2000\tWolfgang Denk <wd@denx.de>\n *  Copyright (c) 2001\tAlex Züpke <azu@sysgo.de>\n *  Copyright (c) 2001\tMarius Gröger <mag@sysgo.de>\n *  Copyright (c) 2002\tAlex Züpke <azu@sysgo.de>\n *  Copyright (c) 2002\tGary Jennejohn <garyj@denx.de>\n *  Copyright (c) 2002\tKyle Harris <kharris@nexus-tech.net>\n *\n * SPDX-License-Identifier:\tGPL-2.0+\n */\n\n#include <config.h>\n\n/*\n *************************************************************************\n *\n * Symbol _start is referenced elsewhere, so make it global\n *\n *************************************************************************\n */\n\n.globl _start\n\n/*\n *************************************************************************\n *\n * Vectors have their own section so linker script can map them easily\n *\n *************************************************************************\n */\n\n\t.section \".vectors\", \"ax\"\n\n/*\n *************************************************************************\n *\n * Exception vectors as described in ARM reference manuals\n *\n * Uses indirect branch to allow reaching handlers anywhere in memory.\n *\n *************************************************************************\n */\n\n_start:\n\n#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG\n\t.word\tCONFIG_SYS_DV_NOR_BOOT_CFG\n#endif\n\n\tb\treset\n\tldr\tpc, _undefined_instruction\n\tldr\tpc, _software_interrupt\n\tldr\tpc, _prefetch_abort\n\tldr\tpc, _data_abort\n\tldr\tpc, _not_used\n\tldr\tpc, _irq\n\tldr\tpc, _fiq\n\n.................\n\n```\n显然`_start`后面就是中断向量表，`.section \".vectors\", \"ax\"`表明此代码存放在`vectors`里面，具体的地址可以在`u-boot.map`中查询。`b reset`跳转至reset函数内，该函数在`arch/arm/cpu/armv7/start.S`里：\n```\nreset:\n /* Allow the board to save important registers */\n b save_boot_params\n```\n`reset`函数紧接着又跳转到了`save_boot_params`函数，该函数同样定义在`start.S`里：\n```\nENTRY(save_boot_params)\n b save_boot_params_ret @ back to my caller\n```\n这个函数又直接跳转到了`save_boot_params_ret`函数：\n```\nsave_boot_params_ret:\n /*\n * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 \n * mode, except if in HYP mode already\n */\n mrs r0, cpsr       @ 读取CPSR\n and r1, r0, #0x1f  @ 提取bit0 - bit4，用于设置Cortex-A7工作模式\n teq r1, #0x1a      @ 判断处理器是否处于HYP模式\n bicne r0, r0, #0x1f @ 若不处于HYP模式，清除模式位\n orrne r0, r0, #0x13 @ 进入SVC模式（特权）\n orr r0, r0, #0xc0   @ 关闭FIQ和IRQ\n msr cpsr,r0         @ 恢复CPSR\n```\n然后，继续执行：\n```\n /*\n * Setup vector:\n * (OMAP4 spl TEXT_BASE is not 32 byte aligned.\n * Continue to use ROM code vector only in OMAP4 spl)\n */\n #if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))       \n /* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */\n mrc p15, 0, r0, c1, c0, 0 @ 读取 CP15 SCTLR 寄存器\n bic r0, #CR_V @ V = 0\n mcr p15, 0, r0, c1, c0, 0 @ 写 CP15 SCTLR 寄存器，V清零，准备重定位向量表\n\n /* CP15 VBAR 寄存器中设置向量表地址 */\n ldr r0, =_start\n mcr p15, 0, r0, c12, c0, 0 @Set VBAR\n #endif\n```\n继续执行：\n```\n/* the mask ROM code should have PLL and others stable */\n #ifndef CONFIG_SKIP_LOWLEVEL_INIT\n bl cpu_init_cp15       @ 设置CP15相关内容\n bl cpu_init_crit       \n #endif\n\n bl _main\n```\n这已经是跳转至main的最后一步。`cpu_init_crit`定义如下：\n```\nENTRY(cpu_init_crit)\n /*\n * Jump to board specific initialization...\n * The Mask ROM will have already initialized\n * basic memory. Go here to bump up clock rate and handle\n * wake up conditions.\n */\n b lowlevel_init @ go setup pll,mux,memory\n ENDPROC(cpu_init_crit)\n```\n注释已经写了，该函数即将要跳转到的`lowlevel_init`会设置PLL、MUX和内存。\n### lowlevel_init\n函数在`arch/arm/cpu/armv7/lowlevel_init.S`中定义：\n```\n/*\n * A lowlevel_init function that sets up the stack to call a C function to\n * perform further init.\n *\n * (C) Copyright 2010\n * Texas Instruments, <www.ti.com>\n *\n * Author :\n *\tAneesh V\t<aneesh@ti.com>\n *\n * SPDX-License-Identifier:\tGPL-2.0+\n */\n\n#include <asm-offsets.h>\n#include <config.h>\n#include <linux/linkage.h>\n\nENTRY(lowlevel_init)\n\t/*\n\t * Setup a temporary stack. Global data is not available yet.\n\t */\n\tldr\tsp, =CONFIG_SYS_INIT_SP_ADDR\n\tbic\tsp, sp, #7 /* 8-byte alignment for ABI compliance */\n#ifdef CONFIG_SPL_DM\n\tmov\tr9, #0\n#else\n\t/*\n\t * Set up global data for boards that still need it. This will be\n\t * removed soon.\n\t */\n#ifdef CONFIG_SPL_BUILD\n\tldr\tr9, =gdata\n#else\n\tsub\tsp, sp, #GD_SIZE\n\tbic\tsp, sp, #7\n\tmov\tr9, sp\n#endif\n#endif\n\t/*\n\t * Save the old lr(passed in ip) and the current lr to stack\n\t */\n\tpush\t{ip, lr}\n\n\t/*\n\t * Call the very early init function. This should do only the\n\t * absolute bare minimum to get started. It should not:\n\t *\n\t * - set up DRAM\n\t * - use global_data\n\t * - clear BSS\n\t * - try to start a console\n\t *\n\t * For boards with SPL this should be empty since SPL can do all of\n\t * this init in the SPL board_init_f() function which is called\n\t * immediately after this.\n\t */\n\tbl\ts_init\n\tpop\t{ip, pc}\nENDPROC(lowlevel_init)\n```\n第22行`ldr\tsp, =CONFIG_SYS_INIT_SP_ADDR`，将栈指针指向`CONFIG_SYS_INIT_SP_ADDR`，这个宏在`include/configs/mx6ullevk.h`里定义：\n```\n#define CONFIG_SYS_INIT_RAM_ADDR IRAM_BASE_ADDR\n#define CONFIG_SYS_INIT_RAM_SIZE IRAM_SIZE\n\n#define CONFIG_SYS_INIT_SP_OFFSET \\\n(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)\n#define CONFIG_SYS_INIT_SP_ADDR \\\n(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)\n```\n`IRAM_BASE_ADDR`和`IRAM_SIZE`在`arch/arm/include/asm/arch-mx6/imx-regs.h`中定义，实际上就是MX6ULL内部OCRAM的首地址和大小。这里`CONFIG_SYS_INIT_RAM_ADDR = IRAM_BASE_ADDR = 0x00900000`，`CONFIG_SYS_INIT_RAM_SIZE = 0x00020000 =128KB`。\n\n根据这两行：\n```\n#define CONFIG_SYS_INIT_SP_OFFSET \\\n(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)\n#define CONFIG_SYS_INIT_SP_ADDR \\\n(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)\n```\n显然还需要知道`GENERATED_GBL_DATA_SIZE`的值，在`include/generated/generic-asm-offsets.h`中定义，大小为256.那么综上，`CONFIG_SYS_INIT_SP_ADDR`的值如下：\n```\nCONFIG_SYS_INIT_SP_OFFSET = 0x00020000 - 256 = 0x1FF00\nCONFIG_SYS_INIT_SP_ADDR = 0x00900000 + 0x1FF00 = 0x0091FF00\n```\n此时栈指针SP指向0x0091FF00，这属于IMX6ULL的内部RAM。\n\n回到lowlevel_init.S，`bic\tsp, sp, #7`对栈指针作8字节对齐处理。第34行`sub\tsp, sp, #GD_SIZE`用栈指针减去`GD_SIZE`，这个变量在`generic-asm-offsets.h`中定义，大小为248；第35行`bic\tsp, sp, #7`，8字节对齐SP，此时`SP=0x0091FF00 - 248 = 0x0091FE08`。第36行将SP保存至R9，第42行将ip和lr入栈，57行调用s_init函数，然后58行出栈ip和lr，并将lr赋给pc。\n\n### s_init\nlowlevel_init在最后回调用s_init，定义在`arch/arm/cpu/armv7/mx6/soc.c`中。对于MX6ULL而言，s_init()是个空函数（不满足触发要求）。至此lowlevel_init结束，返回cpu_init_crit，该函数也结束，最后返回save_boot_params_ret，紧接着就会执行_main函数。\n\n### _main\n定义在`arch/arm/lib/crt0.S`。总体而言非常长，总共调用了4个函数：`board_init_f`、`relocate_code`、`relocate_vectors`、`board_init_r`。\n#### board_init_f\n在`common/board_f.c`中定义，该函数的工作：\n- 初始化外设，包括串口、定时器等，并打印一些消息\n- 初始化 gd 的各个成员变量，uboot 会将自己重定位到 DRAM 最后面的地址区域，也就是将自己拷贝到 DRAM 最后面的内存区域中。这么做的目的是给 Linux 腾出空间，防止 Linux kernel 覆盖掉 uboot，将 DRAM 前面的区域完整的空出来。在拷贝之前肯定要给 uboot 各部分分配好内存位置和大小，比如 gd 应该存放到哪个位置，malloc 内存池应该存放到哪个位置等等。这些信息都保存在 gd 的成员变量中，因此要对 gd 的这些成员变量做初始化。最终形成一个完整的内存map，在后面重定位 uboot 的时候就会用到这个内存map。\n\n该函数中包括非常关键的一行：\n```\nif (initcall_run_list(init_sequence_f))\nhang();\n```\n`initcall_run_list`会初始化一系列外设：\n```\nstatic init_fnc_t init_sequence_f[] = {\nsetup_mon_len,       //设置代码长度\ninitf_malloc,        //初始化malloc相关的成员变量\ninitf_console_record,   //无效，返回0\narch_cpu_init,          //基本的arch cpu依赖项初始化\ninitf_dm, \narch_cpu_init_dm, \nmark_bootstage, \nboard_early_init_f,     //初始化串口IO配置\ntimer_init,         //初始化Cortex-A7内核定时器，为Uboot提供时间(类似systick)\nboard_postclk_init,     //设置VDDSOC电压\nget_clocks,             //获取SD卡外设时钟\nenv_init,               //初始化环境变量\ninit_baud_rate,         //初始化波特率\nserial_init,            //初始化串口\nconsole_init_f, \ndisplay_options,        //串口打印信息\ndisplay_text_info,      //打印调试信息\nprint_cpuinfo,          //打印CPU信息\nshow_board_info,        //打印板子信息，调用checkboard()\nINIT_FUNC_WATCHDOG_INIT     //无效\nINIT_FUNC_WATCHDOG_RESET    //无效\ninit_func_i2c,          //初始化I2C\nannounce_dram_init,     \ndram_init,              //设置gd->ram_size\npost_init_f,            //测试函数\nINIT_FUNC_WATCHDOG_RESET\ntestdram,               //无效\nINIT_FUNC_WATCHDOG_RESET\nINIT_FUNC_WATCHDOG_RESET\n/*\n* Now that we have DRAM mapped and working, we can\n* relocate the code and continue running from DRAM.\n*\n* Reserve memory at end of RAM for (top down in that order):\n* - area that won't get touched by U-Boot and Linux (optional)\n* - kernel log buffer\n* - protected RAM\n* - LCD framebuffer\n* - monitor code\n* - board info struct\n*/\nsetup_dest_addr,        //设置gd->ram_size(ram大小)，gd->ram_top(ram最高地址)和gd->relocaddr(重定位后最高地址)\nreserve_round_4k,       //gd->relocaddr 4字节对齐\nreserve_mmu,            //留出MMU的TLB表位置\nreserve_trace, \nreserve_uboot,          //留出重定位后uboot所占内存区域，大小由gd->monlen指定，留出的空间需4KB对齐并设置gd->start_addr_sp\nreserve_malloc,         //留出malloc区域，由宏TOTAL_MALLOC_LEN定义(默认16MB)\nreserve_board,          //留出bd_t内存区\nsetup_machine,          //无效\nreserve_global_data,    //留出gd_t内存区域\nreserve_fdt,            //无效\nreserve_arch,           //空\nreserve_stacks,         //留出栈空间，如果使能IRQ还需要留出IRQ相应的内存\nsetup_dram_config,      //设置DRAM，告知linux DRAM起始地址和大小\nshow_dram_config, \ndisplay_new_sp,         //显示新的sp位置\nINIT_FUNC_WATCHDOG_RESET\nreloc_fdt,              //无效\nsetup_reloc,            //设置gd的其他成员变量\nNULL,\n};\n```\n至此，`board_init_f`执行完成，最终的内存分配：\n![内存分配](/images/linux/uboot_9.png)\n\n#### relocate_code / relocate_vectors\n用于拷贝代码和重定位向量表。\n\n#### board_init_r\n用于初始化高级外设，包括EMMC、LCD、BSP芯片、网络等。\n\n### 小结\n总的来说，uboot的汇编启动阶段包括：\n1. 入口点：`_start`(`arch/arm/lib/vectors.S`)设置异常向量表\n2. CPU模式切换：进入SVC模式，禁用IRQ/FIQ\n3. 关闭MMU/Cache，确保直接访问物理地址\n4. 初始化栈指针\n5. lowlevel_init（板级特定）：\n\t- 配置系统时钟\n\t- DDR控制器初始化\n6. 代码重定位：将U-Boot从加载地址（如SRAM）拷贝到DDR目标地址\n\nC语言初始化阶段(`board_init_f`)包括：\n1. 全局数据结构初始化：`gd_t`和`bd_t`\n2. 低级驱动初始化：\n\t- 串口、GPIO、MMU、内核定时器\n\t- DDR\n3. 重定位准备\n\t- 计算uboot在DDR中的最终位置，预留内核、DTB、initrd、代码空间\n\t- 执行重定位，更新代码地址相关引用(如全局变量指针)\n4. 设备树预解析：若使用DTS，加载并校验DTB\n\n重定位后主流程(`board_init_r`)包括：\n1. 高级外设初始化：\n\t- 以太网、SD、USB、EEPROM等\n\t- 展开DTB，匹配驱动，设置硬件参数\n2. 环境变量加载：从存储介质读取`uEnv.txt`或环境分区\n3. 用户交互\n\t- 检测输入\n\t- 加载zImage、设备树、initrd到指定内存地址\n\t- 准备加载内核","categories":["嵌入式(Linux开发)"]},{"title":"IMX6UL DDR3配置","url":"/2025/03/05/DDR3配置/","content":"## RAM和ROM\n- RAM：Random-access memory，随机存储器，随时读写，速度快，掉电后数据丢失。内存条即为常见的RAM。ARM中栈、堆(malloc申请的内存)、全局区（.bss段、.data段）都存放在RAM中。\n- ROM：Read-only memory，只读存储器。容量大，速度慢，掉电后数据留存。\n\n对于IMX6U，256/512MB的DDR3为RAM，512MB的NANF Flash或8GB EMMC为ROM。\n\n## SRAM\nStatic Random-Access Memory，静态随机存储器。“静态”的意思是只要SRAM上电，SRAM里面的数据就会一直保存，直到SRAM掉电。为了随机读取任何一个地址空间内的数据，SRAM的地址线和数据线分离。\n\n以F103/F407常用的IS62WV51216 SRAM而言，其包括几个部分：\n\n![IS62WV51216框图](/images/linux/sram_1.png)\n\n1. 地址线，用于寻址。地址线的根数代表着能够访问的地址大小，19根线就能访问2^19=524288=512KB的内存。该SRAM是16位宽的，一次访问两个字节，实际的可访问大小为512KB*2=1MB。\n2. 数据线，用于传输数据。16位宽即有16根数据线，高低字节分开传输。\n3. 控制线。包括：\n    - CS1/CS2：片选信号\n    - OE：输出使能信号\n    - WE：写使能信号\n    - UB/LB：高字节/低字节控制信号\n\nSRAM最大的缺点就是成本高、价格高。\n\n## SDRAM\nSynchronous Dynamic Random Access Memory，同步动态随机存储器。“同步”的意思是 SDRAM 工作需要时钟线，“动态”的意思是 SDRAM 中的数据需要不断的刷新来保证数据不会丢失，“随机”的意思就是可以读写任意地址的数据。相比SRAM，SDRAM读写速度较慢（要持续刷新），但是容量大，价格更低，功耗也更低，适合做大容量存储。\n\nSDRAM已经发展到了第四代：\n    1. SDRAM\n    2. DDR SDRAM\n    3. DDR2 SDRAM\n    4. DDR3 SDRAM\n    5. DDR4 SDRAM\n\nSTM32F429/F767等都支持SDRAM。就以 STM32 开发板最常用的华邦 W9825G6KH 为例，W9825G6KH 是一款 16 位宽(数据位为 16 位)、32MB 的 SDRAM、速度一般为 133MHz、166MHz 或 200MHz：\n\n![W9825G6KH框图](/images/linux/sram_2.png)\n\n1. 控制线\n    - CLK：时钟线，SDRAM中“同步”二字表明其必定需要时钟线\n    - CKE：时钟使能信号线\n    - CS：片选信号\n    - RAS：行选通信号。与SRAM不同，SDRAM通过行、列来确定具体的存储区域，类似于“坐标”，因此有行地址和列地址之分\n    - CAS：列选通信号\n    - WE：写使能信号\n2. A10地址线：除了地址线外，A10线还控制Auto-precharge（预充电）。SDRAM内部分为多个BANK，读写完成后如果要对同一个BANK中的另一行进行寻址，则必须将原来的有效行关闭，然后发送新的行/列地址。关闭现在正工作的行，打开新行的操作就叫做预充电。\n3. 地址线：A0-A12，共13根，包含行地址和列地址。如W9825G6KH的A0-A8是列地址(9位)，A0-A12是行地址(13位)，可寻址范围为2^9*2^13=4194304B=4MB。 考虑到位宽为2，4MB * 2=8MB，共4个BANK，因此容量为32MB。\n4. BANK选择线：在一片 SDRAM 中因为技术、成本等原因，不可能做一个全容量的 BANK。而且，因为 SDRAM 的工作原理，单一的 BANK 会带来严重的寻址冲突，减低内存访问效率。为此，厂商在一片 SDRAM 中分割出多块 BANK，一般都是 2 的 n 次方，比如 2，4，8 等。如果有4个BANK，那么BANK选择则需要两根线，同理8个BANK就需要三根线。\n5. BANK区域\n6. 数据线：16位宽，共16根数据线\n7. 高低字节选择线\n\n## DDR\nDouble Data Rate SDRAM，双倍速率SDRAM。\n- DDR1:一个CLK周期内，在上升沿和下降沿各传输一次数据，该过程被称为prefetch（预取）\n- DDR2：在DDR1的基础上将预取增加到了4bit\n- DDR3：在DDR2的基础上将预取增加到了8bit，DDR3又细分为以下型号：\n    + LPDDR3：低功耗，电压为1.2V\n    + DDR3：标压，电压为1.5V，台式机多使用该类\n    + DDR3L：低压，电压为1.35V，手机、嵌入式设备、笔记本等多使用该类\n\n## DDR3\n以NT5CC256M16ER-EK为例：\n![DDR3L框图](/images/linux/sram_3.png)\n1. 控制线\n    - ODT：片上终端使能，使能和禁止片内终端电阻\n    - ZQ：输出驱动校准的外部参考引脚，应外接240欧电阻至VSSQ\n    - RESET：复位\n    - CKE：时钟使能\n    - A12：地址线，复用为BC引脚，在READ和WRITE命令期间会被采样以决定burst chop是否执行\n    - CK和CK#：时钟信号。DDR3使用差分时钟线，所有的控制和地址信号都会在CK的上升沿和CK#的下降沿交叉处被采集\n    - CS#：片选信号\n    - RAS#、CAS#、WE#：行选通，列选通和写使能信号\n2. 地址线：A0-A14，列地址为A0-A9共10根，行地址为A0-A14共15根，一个BANK大小即为2^10 * 2^15 * 2=64MB。IC共有8个BANK，加起来就是512MB。\n3. BANK选择线：8个BANK，需要3根选择线\n4. BANK区域\n5. 数据线：16位宽，共需16根数据线\n6. 数据选通引脚：DQS和DQS#，差分信号\n7. 数据输入屏蔽引脚：DM\n\n## DDR3关键时间参数\n1. 传输速率：如1066MT/S、1600MT/S、1866MT/S 等\n2. tRCD参数：RAS-to-CAS Delay，即行寻址到列寻址之间的延迟。DDR的寻址流程是先指定 BANK 地址，然后再指定行地址，最后指定列地址确定最终要寻址的单元。BANK 地址和行地址是同时发出的，这个命令叫做“行激活”(Row Active)。行激活以后就发送列地址和具体的操作命令(读还是写)，这两个是同时发出的，因此一般也用“读/写命令”表示列寻址。在行有效(行激活)到读写命令发出的这段时间间隔叫做 tRCD。该参数在初始化DDR3时需要配置\n3. CL参数：CAS Latency，列地址选通潜伏期，列地址发出后，数据从存储单元到内存芯片IO接口上的时间。一般tRCD和CL大小一样\n4. AL参数：Additive Latency，前置CAS后读写操作并没有提前，依旧需要AL来保证足够的延迟（潜伏）期。AL和CL相加组成了RL（Read Latency）\n5. tRC参数：两个 ACTIVE 命令，或者 ACTIVE 命令到 REFRESH 命令之间的周期\n6. tRAS参数：ACTIVE 命令到 PRECHARGE 命令之间的最小时间，DDR3L 的数据手册同样也会给出此参数\n\n## I.MX6U MMDC控制器\n### IO\nMMDC 是 I.MX6U的内存控制器，是一个多模的 DDR 控制器，可以连接 16 位宽的 DDR3/DDR3L、16 位\n宽的 LPDDR2，MMDC 是一个可配置、高性能的 DDR 控制器。MMDC 外设包含一个内核(MMDC_CORE)和 PHY(MMDC_PHY)，内核和 PHY 的功能如下：\n- MMDC内核：负责通过AXI接口与系统通信、DDR命令生成、DDR命令优化、读写数据路径\n- MMDCPHY：负责时序调整和校准，保障数据在400MHz内被准确捕获\n\n因为硬件要求严格，I.MX6U的DDR引脚没有复用：\n![DDR信号IO](/images/linux/sram_4.png)\n\n### 时钟源\n![MMDC时钟源](/images/linux/sram_5.png)\n1. pre_periph2时钟选择器，由CBCMR的PRE_PERIPH2_CLK_SEL 位控制：\n| PRE_PERIPH2_CLK_SEL(bit22:21) | 时钟源       |\n| ----------------------------- | --------- |\n| 00                             | PLL2      |\n| 01                             | PLL2_PFD2 |\n| 10                            | PLL2_PFD0 |\n| 11                            | PLL4      |\n先前的时钟配置已经将PLL2_PFD2设置为396MHz（约400MHz），因此DDR频率也为400MHz\n2. periph2_clk 时钟选择器，由 CBCDR 寄存器的 PERIPH2_CLK_SEL 位(bit26)控制，置0时选择pll2_main_clk作为periph2_clk的时钟源，因此`periph2_clk = PLL2_PFD0 = 396MHz`\n3. 分频器，由 CBCDR 寄存器的 FABRIC_MMDC_PODF 位(bit5:3)设置，0 - 7 对应1 - 8 分频，此处应设置1分频，即该位置0\n\n### DDR驱动\n1. 使用excel表生成inc文件\n2. 加载inc至NXP DDR Test Tool，连接USB OTG线，设置MCU从USB启动，开始校准\n3. 校准后的寄存器数据回填至inc文件，重新下载，进行压力测试\n","categories":["嵌入式(Linux开发)"]},{"title":"IMX6ULL外部中断配置","url":"/2025/03/04/IMX6ULL外部中断配置/","content":"## Cortex-A7中断系统\n### 中断向量表\nCortex-A7的中断向量表共有8个异常中断，其中一个未使用，有效中断为7个：\n\n| 向量地址 | 中断类型                           | 中断模式             |\n| ---- | ------------------------------ | ---------------- |\n| 0X00 | 复位中断(Rest)                     | 特权模式(SVC)        |\n| 0X04 | 未定义指令中断(Undefined Instruction) | 未定义指令中止模式(Undef) |\n| 0X08 | 软中断(Software Interrupt,SWI)    | 特权模式(SVC)        |\n| 0X0C | 指令预取中止中断(Prefetch Abort)       | 中止模式             |\n| 0X10 | 数据访问中止中断(Data Abort)           | 中止模式             |\n| 0X14 | 未使用(Not Used)                  | 未使用              |\n| 0X18 | IRQ 中断(IRQ Interrupt)          | 外部中断模式(IRQ)      |\n| 0X1C | FIQ 中断(FIQ Interrupt)          | 快速中断模式(FIQ)      |\n\n不同于Cortex-M在中断向量表中列出了所有的中断向量，Cortex-A将所有属于内核CPU的外部中断放在0x18的IRQ中断中，任意外部中断都会触发IRQ中断，然后在IRQ中断中通过读取寄存器的方式来判断具体的中断类型，然后做出相应处理。\n\n### 汇编代码(启动文件`start.S`)\n#### 中断向量表\n```\n.global _start  \t\t\t\t/* 全局标号 */\n\n_start:\n\tldr pc, =Reset_Handler\t\t/* 复位中断 \t\t\t\t\t*/\t\n\tldr pc, =Undefined_Handler\t/* 未定义中断 \t\t\t\t\t*/\n\tldr pc, =SVC_Handler\t\t/* SVC(Supervisor)中断 \t\t*/\n\tldr pc, =PrefAbort_Handler\t/* 预取终止中断 \t\t\t\t\t*/\n\tldr pc, =DataAbort_Handler\t/* 数据终止中断 \t\t\t\t\t*/\n\tldr\tpc, =NotUsed_Handler\t/* 未使用中断\t\t\t\t\t*/\n\tldr pc, =IRQ_Handler\t\t/* IRQ中断 \t\t\t\t\t*/\n\tldr pc, =FIQ_Handler\t\t/* FIQ(快速中断)未定义中断 \t\t\t*/\n```\n指定中断发生后调用对应的中断复位函数。`pc`为程序计数器，用来指出下一条指令在主存储器中的地址。中断发生后，主程序的下一条指令地址会自动更新为中断服务函数的地址。\n\n### GIC控制器\n![GIC v2框图](/images/linux/GIC_1.png)\n\n类似于STM32的NVIC，Cortex-A的中断控制器名字叫GIC，GIC负责处理输入的所有中断，然后生成一个IRQ信号上报给ARM内核。GIC将众多的中断源分为三类：\n- SPI，共享中断，常见外部中断均属于SPI中断\n- PPI，私有中断，指定核心处理\n- SGI，软件中断，通过向寄存器`GICR_SGIR`写入数据触发，常用于多核通信\n\n### 中断ID\nI.MX6UL的1020个中断ID分配如下：\n- ID0 - ID15：分配至SGI\n- ID16 - ID31：分配至PPI\n- ID32 - ID1019：分配至SPI\n\nI.MX6U的中断源由官方SDK在`MCIMX6Y2.h`中给出，共有160个，每个中断源有独属的中断ID。\n\n### GIC逻辑分块\nGIC架构分为两个逻辑块：\n- Distributor：分发器端，负责处理中断事件分发问题（中断事件该发送到哪个CPU Interface上去）。分发器收集所有的中断源，可控制每个中断的优先级，具体功能有：\n    1. 全局中断使能控制\n    2. 控制每个中断的使能或关闭\n    3. 设置中断优先级\n    4. 设置每个中断的目标处理器列表\n    5. 设置每个外部中断的触发模式：电平触发或边沿触发\n    6. 设置每个中断属于组 0 还是组 1\n- CPU Interface：CPU接口端，具体功能有：\n    1. 使能或者关闭发送到 CPU Core 的中断请求信号\n    2. 应答中断\n    3. 通知中断处理完成\n    4. 设置优先级掩码，通过掩码来设置哪些中断不需要上报给 CPU Core\n    5. 定义抢占策略\n    6. 当多个中断到来的时候，选择优先级最高的中断通知给 CPU Core\n\nGIC控制器的所有寄存器在`core_ca7.h`中声明：\n```\n/*\n * GIC寄存器描述结构体，\n * GIC分为分发器端和CPU接口端\n */\ntypedef struct\n{\n        uint32_t RESERVED0[1024];\n  __IOM uint32_t D_CTLR;                 /*!< Offset: 0x1000 (R/W) Distributor Control Register */\n  __IM  uint32_t D_TYPER;                /*!< Offset: 0x1004 (R/ )  Interrupt Controller Type Register */\n  __IM  uint32_t D_IIDR;                 /*!< Offset: 0x1008 (R/ )  Distributor Implementer Identification Register */\n        uint32_t RESERVED1[29];\n  __IOM uint32_t D_IGROUPR[16];          /*!< Offset: 0x1080 - 0x0BC (R/W) Interrupt Group Registers */\n        uint32_t RESERVED2[16];\n  __IOM uint32_t D_ISENABLER[16];        /*!< Offset: 0x1100 - 0x13C (R/W) Interrupt Set-Enable Registers */\n        uint32_t RESERVED3[16];\n  __IOM uint32_t D_ICENABLER[16];        /*!< Offset: 0x1180 - 0x1BC (R/W) Interrupt Clear-Enable Registers */\n        uint32_t RESERVED4[16];\n  __IOM uint32_t D_ISPENDR[16];          /*!< Offset: 0x1200 - 0x23C (R/W) Interrupt Set-Pending Registers */\n        uint32_t RESERVED5[16];\n  __IOM uint32_t D_ICPENDR[16];          /*!< Offset: 0x1280 - 0x2BC (R/W) Interrupt Clear-Pending Registers */\n        uint32_t RESERVED6[16];\n  __IOM uint32_t D_ISACTIVER[16];        /*!< Offset: 0x1300 - 0x33C (R/W) Interrupt Set-Active Registers */\n        uint32_t RESERVED7[16];\n  __IOM uint32_t D_ICACTIVER[16];        /*!< Offset: 0x1380 - 0x3BC (R/W) Interrupt Clear-Active Registers */\n        uint32_t RESERVED8[16];\n  __IOM uint8_t  D_IPRIORITYR[512];      /*!< Offset: 0x1400 - 0x5FC (R/W) Interrupt Priority Registers */\n        uint32_t RESERVED9[128];\n  __IOM uint8_t  D_ITARGETSR[512];       /*!< Offset: 0x1800 - 0x9FC (R/W) Interrupt Targets Registers */\n        uint32_t RESERVED10[128];\n  __IOM uint32_t D_ICFGR[32];            /*!< Offset: 0x1C00 - 0xC7C (R/W) Interrupt configuration registers */\n        uint32_t RESERVED11[32];\n  __IM  uint32_t D_PPISR;                /*!< Offset: 0x1D00 (R/ ) Private Peripheral Interrupt Status Register */\n  __IM  uint32_t D_SPISR[15];            /*!< Offset: 0x1D04 - 0xD3C (R/ ) Shared Peripheral Interrupt Status Registers */\n        uint32_t RESERVED12[112];\n  __OM  uint32_t D_SGIR;                 /*!< Offset: 0x1F00 ( /W) Software Generated Interrupt Register */\n        uint32_t RESERVED13[3];\n  __IOM uint8_t  D_CPENDSGIR[16];        /*!< Offset: 0x1F10 - 0xF1C (R/W) SGI Clear-Pending Registers */\n  __IOM uint8_t  D_SPENDSGIR[16];        /*!< Offset: 0x1F20 - 0xF2C (R/W) SGI Set-Pending Registers */\n        uint32_t RESERVED14[40];\n  __IM  uint32_t D_PIDR4;                /*!< Offset: 0x1FD0 (R/ ) Peripheral ID4 Register */\n  __IM  uint32_t D_PIDR5;                /*!< Offset: 0x1FD4 (R/ ) Peripheral ID5 Register */\n  __IM  uint32_t D_PIDR6;                /*!< Offset: 0x1FD8 (R/ ) Peripheral ID6 Register */\n  __IM  uint32_t D_PIDR7;                /*!< Offset: 0x1FDC (R/ ) Peripheral ID7 Register */\n  __IM  uint32_t D_PIDR0;                /*!< Offset: 0x1FE0 (R/ ) Peripheral ID0 Register */\n  __IM  uint32_t D_PIDR1;                /*!< Offset: 0x1FE4 (R/ ) Peripheral ID1 Register */\n  __IM  uint32_t D_PIDR2;                /*!< Offset: 0x1FE8 (R/ ) Peripheral ID2 Register */\n  __IM  uint32_t D_PIDR3;                /*!< Offset: 0x1FEC (R/ ) Peripheral ID3 Register */\n  __IM  uint32_t D_CIDR0;                /*!< Offset: 0x1FF0 (R/ ) Component ID0 Register */\n  __IM  uint32_t D_CIDR1;                /*!< Offset: 0x1FF4 (R/ ) Component ID1 Register */\n  __IM  uint32_t D_CIDR2;                /*!< Offset: 0x1FF8 (R/ ) Component ID2 Register */\n  __IM  uint32_t D_CIDR3;                /*!< Offset: 0x1FFC (R/ ) Component ID3 Register */\n\n  __IOM uint32_t C_CTLR;                 /*!< Offset: 0x2000 (R/W) CPU Interface Control Register */\n  __IOM uint32_t C_PMR;                  /*!< Offset: 0x2004 (R/W) Interrupt Priority Mask Register */\n  __IOM uint32_t C_BPR;                  /*!< Offset: 0x2008 (R/W) Binary Point Register */\n  __IM  uint32_t C_IAR;                  /*!< Offset: 0x200C (R/ ) Interrupt Acknowledge Register */\n  __OM  uint32_t C_EOIR;                 /*!< Offset: 0x2010 ( /W) End Of Interrupt Register */\n  __IM  uint32_t C_RPR;                  /*!< Offset: 0x2014 (R/ ) Running Priority Register */\n  __IM  uint32_t C_HPPIR;                /*!< Offset: 0x2018 (R/ ) Highest Priority Pending Interrupt Register */\n  __IOM uint32_t C_ABPR;                 /*!< Offset: 0x201C (R/W) Aliased Binary Point Register */\n  __IM  uint32_t C_AIAR;                 /*!< Offset: 0x2020 (R/ ) Aliased Interrupt Acknowledge Register */\n  __OM  uint32_t C_AEOIR;                /*!< Offset: 0x2024 ( /W) Aliased End Of Interrupt Register */\n  __IM  uint32_t C_AHPPIR;               /*!< Offset: 0x2028 (R/ ) Aliased Highest Priority Pending Interrupt Register */\n        uint32_t RESERVED15[41];\n  __IOM uint32_t C_APR0;                 /*!< Offset: 0x20D0 (R/W) Active Priority Register */\n        uint32_t RESERVED16[3];\n  __IOM uint32_t C_NSAPR0;               /*!< Offset: 0x20E0 (R/W) Non-secure Active Priority Register */\n        uint32_t RESERVED17[6];\n  __IM  uint32_t C_IIDR;                 /*!< Offset: 0x20FC (R/ ) CPU Interface Identification Register */\n        uint32_t RESERVED18[960];\n  __OM  uint32_t C_DIR;                  /*!< Offset: 0x3000 ( /W) Deactivate Interrupt Register */\n} GIC_Type;\n```\n不过，这里只给出了GIC各寄存器的偏移地址，基地址需要通过CP15协处理器获取。\n\n### CP15协处理器\nCP15协处理器共有16个32位寄存器。对CP15协处理器的访问可通过下列指令完成：\n- **MRC**：将CP15的寄存器数据读取到ARM寄存器中\n- **MCR**：将ARM寄存器数据写入到CP15寄存器中。格式：`MCR{cond} p15, <opc1>, <Rt>, <CRn>, <CRm>, <opc2>`\n    + cond：指令执行的条件码。若忽略，表示无条件执行\n    + opc1：CP15要执行的操作码\n    + Rt：ARM源寄存器\n    + CRn：CP15的目标寄存器\n    + CRm：CP15中附加的目标寄存器或源操作数寄存器。如不需要附加信息，该位应设置为`c0`\n    + opc2：可选的CP15特定操作码，不需要时设置为0\n\nCP15的16个寄存器在被MRC和MCR指令访问时，指令中的参数搭配若不同，得到的寄存器含义也不同。以c0寄存器为例：\n\n![CP15 c0寄存器参数搭配](/images/linux/GIC_2.png)\n\n例如，当`opc1 = 0`, `CRm = c0`, `opc2 = 0`时，此时c0是MIDR寄存器，即主ID寄存器，包含厂商编号、主版本号、架构代码等信息。\n\n对于c15寄存器:\n![CP15 c15寄存器参数搭配](/images/linux/GIC_3.png)\n\n可见GIC基地址保存在CBAR中，因此可通过`MRC p15, 4, r1, c15, c0, 0`指令获取GIC基地址至r1中。现在就可以设置GIC的寄存器了，比如：读取当前中断ID，将ID保存在`GICC_IAR`中，SDK中已经给出`GICC_IAR`的偏移地址`__IM  uint32_t C_IAR;                  /*!< Offset: 0x200C (R/ ) Interrupt Acknowledge Register */`为`0x200C`，因此获取当前中断ID的汇编代码为：\n```\nMRC p15, 5, r1, c15, c0 ,0  ;获取GIC基地址\nADD r1, r1, #0x2000         ;基地址+0x2000得到CPU接口端寄存器起始地址\nLDR r0, [r1, #0xC]          ;读取GIC_IAR的值\n```\n总结：\n- c0寄存器可获取到处理器内核信息\n- c1寄存器可使能或禁止MMU、I/D Cache\n- c12寄存器可设置中断向量偏移\n- c15可获取GIC基地址\n\n### 中断使能\n#### IRQ和FIQ总中断使能\n汇编下支持以下快捷指令：\n| 指令      | 描述      |\n| ------- | ------- |\n| cpsid i | 禁止IRQ中断 |\n| cpsie i | 使能IRQ中断 |\n| cpsid f | 禁止FIQ中断 |\n| cpsie f | 使能FIQ中断 |\n\n#### ID0 - ID1019 中断使能和禁止\n由以下寄存器完成：\n- `GICD_ISENABLERn`：`GICD_ISENABLER0`的bit[15:0]对应ID15 - 0的SGI中断，bit[31:16]对应ID31 - 16的PPI中断\n- `GICD_ICENABLERn`：`GICD_ISENABLER1` - `GICD_ISENABLER15`控制SPI中断\n\n### 中断优先级\n#### 优先级数量配置\n`GICC_PMR`寄存器用于配置优先级数量，寄存器低8位有效。I.MX6U是Cortex-A7内核，支持32个优先级，因此`GICC_PMR`设置为`0b11111000`.\n\n#### 抢占优先级和子优先级位数配置\n抢占优先级和子优先级各占多少位由寄存器`GICC_BPR`决定，低3位有效，配置如下所示：\n| Binary Point | 抢占优先级域 | 子优先级域 | 描述                |\n| ------------ | ------ | ----- | ----------------- |\n| 0            | [7:1]  | [0]   | 7 级抢占优先级，1 级子优先级。 |\n| 1            | [7:2]  | [1:0] | 6 级抢占优先级，2 级子优先级。 |\n| 2            | [7:3]  | [2:0] | 5 级抢占优先级，3 级子优先级。 |\n| 3            | [7:4]  | [3:0] | 4 级抢占优先级，4 级子优先级。 |\n| 4            | [7:5]  | [4:0] | 3 级抢占优先级，5 级子优先级。 |\n| 5            | [7:6]  | [5:0] | 2 级抢占优先级，6 级子优先级。 |\n| 6            | [7:7]  | [6:0] | 1 级抢占优先级，7 级子优先级。 |\n| 7            | 无      | [7:0] | 0 级抢占优先级，8 级子优先级。 |\n\n一般而言所有的中断优先级位都配置为抢占优先级。如IMX6U的优先级位数为5（32个优先级），可设置Binary point为2，表示5个优先级位全部为抢占优先级。\n\n#### 优先级设置\n某个中断ID的中断优先级设置由寄存器`GICD_IPRIORITYR`完成，每个中断ID配有一个该寄存器，共512个。如果优先级个数为32，即使用`GICD_IPRIORITYR`的bit[7:4]来设置优先级（实际优先级左移3位）。例如，要设置ID == 40中断优先级为5：`GICD_IPRIORITYR[40] = 5 << 3`\n\n总结一下，中断优先级设置分三部分：\n1. 设置`GICC_PMR`，配置优先级个数，IMX6U为32级\n2. 设置抢占优先级和子优先级位数，一般默认所有位数都为抢占优先级\n3. 设置指定中断ID的优先级\n\n### 复位中断服务函数\n整个启动文件在设置完中断向量表后，要进行复位中断的设置，其分为以下步骤：\n1. 设置复位中断：关闭IRQ，然后关闭I/D Cache、MMU、对齐检测和分支预测\n2. 进行中断向量表重映射\n3. 设置IRQ模式、SYS模式和SVC模式下的栈指针，栈大小均为2MB\n4. 打开IRQ中断\n5. 跳转至main函数\n```\n/* 复位中断 */\t\nReset_Handler:\n\n\tcpsid i\t\t\t\t\t\t/* 关闭全局中断 */\n\n\t/* 关闭I,DCache和MMU \n\t * 采取读-改-写的方式。\n\t */\n\tmrc     p15, 0, r0, c1, c0, 0     /* 读取CP15的C1寄存器到R0中       \t\t        \t*/\n    bic     r0,  r0, #(0x1 << 12)     /* 清除C1寄存器的bit12位(I位)，关闭I Cache            \t*/\n    bic     r0,  r0, #(0x1 <<  2)     /* 清除C1寄存器的bit2(C位)，关闭D Cache    \t\t\t\t*/\n    bic     r0,  r0, #0x2             /* 清除C1寄存器的bit1(A位)，关闭对齐\t\t\t\t\t\t*/\n    bic     r0,  r0, #(0x1 << 11)     /* 清除C1寄存器的bit11(Z位)，关闭分支预测\t\t\t\t\t*/\n    bic     r0,  r0, #0x1             /* 清除C1寄存器的bit0(M位)，关闭MMU\t\t\t\t       \t*/\n    mcr     p15, 0, r0, c1, c0, 0     /* 将r0寄存器中的值写入到CP15的C1寄存器中\t \t\t\t\t*/\n\n#if 0\n\t/* 汇编版本设置中断向量表偏移 */\n\tldr r0, =0X87800000\n\n\tdsb\n\tisb\n\tmcr p15, 0, r0, c12, c0, 0\n\tdsb\n\tisb\n#endif\n    \n\t/* 设置各个模式下的栈指针，\n\t * 注意：IMX6UL的堆栈是向下增长的！\n\t * 堆栈指针地址一定要是4字节地址对齐的！！！\n\t * DDR范围:0X80000000~0X9FFFFFFF\n\t */\n\t/* 进入IRQ模式 */\n\tmrs r0, cpsr\n\tbic r0, r0, #0x1f \t/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 \t*/\n\torr r0, r0, #0x12 \t/* r0或上0x13,表示使用IRQ模式\t\t\t\t\t*/\n\tmsr cpsr, r0\t\t/* 将r0 的数据写入到cpsr_c中 \t\t\t\t\t*/\n\tldr sp, =0x80600000\t/* 设置IRQ模式下的栈首地址为0X80600000,大小为2MB */\n\n\t/* 进入SYS模式 */\n\tmrs r0, cpsr\n\tbic r0, r0, #0x1f \t/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 \t*/\n\torr r0, r0, #0x1f \t/* r0或上0x13,表示使用SYS模式\t\t\t\t\t*/\n\tmsr cpsr, r0\t\t/* 将r0 的数据写入到cpsr_c中 \t\t\t\t\t*/\n\tldr sp, =0x80400000\t/* 设置SYS模式下的栈首地址为0X80400000,大小为2MB */\n\n\t/* 进入SVC模式 */\n\tmrs r0, cpsr\n\tbic r0, r0, #0x1f \t/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 \t*/\n\torr r0, r0, #0x13 \t/* r0或上0x13,表示使用SVC模式\t\t\t\t\t*/\n\tmsr cpsr, r0\t\t/* 将r0 的数据写入到cpsr_c中 \t\t\t\t\t*/\n\tldr sp, =0X80200000\t/* 设置SVC模式下的栈首地址为0X80200000,大小为2MB */\n\n\tcpsie i\t\t\t\t/* 打开全局中断 */\n#if 0\n\t/* 使能IRQ中断 */\n\tmrs r0, cpsr\t\t/* 读取cpsr寄存器值到r0中 \t\t\t*/\n\tbic r0, r0, #0x80\t/* 将r0寄存器中bit7清零，也就是CPSR中的I位清零，表示允许IRQ中断 */\n\tmsr cpsr, r0\t\t/* 将r0重新写入到cpsr中 \t\t\t*/\n#endif\n\n\tb main\t\t\t\t/* 跳转到main函数 \t\t\t \t*/\n```\n### 其他中断\n```\n/* 未定义中断 */\nUndefined_Handler:\n\tldr r0, =Undefined_Handler\n\tbx r0\n\n/* SVC中断 */\nSVC_Handler:\n\tldr r0, =SVC_Handler\n\tbx r0\n\n/* 预取终止中断 */\nPrefAbort_Handler:\n\tldr r0, =PrefAbort_Handler\t\n\tbx r0\n\n/* 数据终止中断 */\nDataAbort_Handler:\n\tldr r0, =DataAbort_Handler\n\tbx r0\n\n/* 未使用的中断 */\nNotUsed_Handler:\n\n\tldr r0, =NotUsed_Handler\n\tbx r0\n\n    /* FIQ中断 */\nFIQ_Handler:\n\n\tldr r0, =FIQ_Handler\t\n\tbx r0\t\n```\n\n### IRQ中断服务函数\n所有的外部中断都会触发IRQ中断，因此IRQ中断服务函数的工作就是获取当前发生的中断ID以确定中断来源，然后根据不同的外部中断来进行不同的处理。这里会涉及到几个ARM中常用的寄存器：\n- IP寄存器：内部程序调用暂存寄存器，子程序的连接text段中常使用该规则\n- SP寄存器：栈指针寄存器，用于存储当前栈顶地址。程序执行过程中，栈是用来存储临时变量、函数调用返回地址等数据的重要数据结构，SP寄存器的值会随着栈的变化而变化\n- LR寄存器：连接寄存器，程序跳转（子程序调用，中断跳转）后，arm自动在该寄存器中存入原程序（未跳转）的下一条指令的地址，也叫函数调用返回地址。当一个函数被调用时，LR寄存器会存储调用该函数的下一条指令的地址，当函数执行完毕后，程序会跳转到LR寄存器中存储的地址继续执行。\n- PC寄存器：程序计数器，保存的是当前正在取指的指令的地址（arm采用2级流水线，因此是当前正在执行指令的地址+8）。PC寄存器是ARM中的程序计数器，用于存储下一条将要执行的指令的地址。\n\n此外，还有两个比较重要的状态寄存器：\n- CPSR：程序状态寄存器，在任何处理器模式下被访问。它包含了条件标志位、中断禁止位、当前处理器模式标志以及其他的一些控制和状态位。CPSR在用户级编程时用于存储条件码。\n- SPSR：程序状态保存寄存器，每一种处理器模式下都有一个状态寄存器SPSR,SPSR用于保存CPSR的状态，以便异常返回后恢复异常发生时的工作状态。当特定的异常中断发生时，这个寄存器用于存放当前程序状态寄存器的内容。在异常中断退出时，可以用SPSR来恢复CPSR。由于用户模式和系统模式不是异常中断模式，所以他没有SPSR。当用户在用户模式或系统模式访问SPSR，将产生不可预知的后果。\n\n二者常用于MRS或MSR指令,用于spsr中的值转移到寄存器或把寄存器的内容加载到spsr中，如:\n\n```\nmrs r0, spsr                /* 读取spsr寄存器 */\nmsr spsr_cxsf, r0            /* 恢复spsr */\n```\n\nIRQ中断服务函数的编写大致分为以下步骤：\n1. 进入IRQ模式，保存上下文。ARM在进入IRQ模式会自动切换LR和SPSR，但不会自动保存其他寄存器，因此需手动保存r0-r3和r12寄存器（后续操作可能修改）。自动切换时，LR保存被中断指令的下一条指令`-4`。\n\n```\n/* IRQ中断 */\nIRQ_Handler:\n\tpush {lr}\t\t\t\t\t/* 保存lr地址 */\n\tpush {r0-r3, r12}\t\t\t/* 保存r0-r3，r12寄存器 */\n```\n\n2. 保存现场。SPSR存储被中断前CPU的模式状态，必须保存SPSR以正确恢复中断前的执行环境。\n```\n\tmrs r0, spsr\t\t\t\t/* 读取spsr寄存器 */\n\tpush {r0}\t\t\t\t\t/* 保存spsr寄存器 */\n```\n\n3. 获取GIC中断号。通过MRC向cp15读取寄存器以获取GIC基址，从而计算GICC_IAR地址并读取，读取后自动标记该中断为active状态，获取到的中断号`r0`作为参数传递给C语言ISR。\n```\n\tmrc p15, 4, r1, c15, c0, 0 /* 读取CP15的C0寄存器内的值到R1寄存器中\n\t\t\t\t\t\t\t\t* 参考文档ARM Cortex-A(armV7)编程手册V4.0.pdf P49\n\t\t\t\t\t\t\t\t* Cortex-A7 Technical ReferenceManua.pdf P68 P138\n\t\t\t\t\t\t\t\t*/\t\t\t\t\t\t\t\n\tadd r1, r1, #0X2000\t\t\t/* GIC基地址加0X2000，也就是GIC的CPU接口端基地址 */\n\tldr r0, [r1, #0XC]\t\t\t/* GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，\n\t\t\t\t\t\t\t\t * GICC_IAR寄存器保存这当前发生中断的中断号，我们要根据\n\t\t\t\t\t\t\t\t * 这个中断号来绝对调用哪个中断服务函数\n\t\t\t\t\t\t\t\t */\n\tpush {r0, r1}\t\t\t\t/* 保存r0,r1 */\n```\n\n4. 切换至SVC模式并调用C函数。IAR模式栈空间有限，切换至SVC模式（特权模式）以获得更大的栈空间，并允许C函数处理更复杂的逻辑，如中断嵌套。\n```\n\tcps #0x13\t\t\t\t\t/* 进入SVC模式，允许其他中断再次进去 */\n\t\n\tpush {lr}\t\t\t\t\t/* 保存SVC模式的lr寄存器 */\n\tldr r2, =system_irqhandler\t/* 加载C语言中断处理函数到r2寄存器中*/\n\tblx r2\t\t\t\t\t\t/* 运行C语言中断处理函数，带有中断号参数，保存在R0寄存器中 */\n```\n\n5. 恢复模式并发送中断结束信号。向向GIC的End of Interrupt Register (GICC_EOIR) 写入中断号，告知中断控制器该中断已处理完毕。\n```\n\tpop {lr}\t\t\t\t\t/* 执行完C语言中断服务函数，lr出栈 */\n\tcps #0x12\t\t\t\t\t/* 进入IRQ模式 */\n\tpop {r0, r1}\t\t\t\t\n\tstr r0, [r1, #0X10]\t\t\t/* 中断执行完成，写EOIR */\n```\n\t\n6. 恢复中断前状态并返回。\n\n这里是一个很容易搞错的点。ARM使用三级流水线机制：取指->译指->执行，而我们总以执行位置作为参考点，因此PC永远是当前执行位置`+8`；LR存放函数调用结束后返回继续执行的地址，也就是当前执行指令的下一条(`+4`)。进入IRQ中断时，中断总是在执行一条指令后再进入，此时PC更新为`+12`，相应的LR变为`+8`，然后LR被入栈保存。如果中断结束后，直接将LR出栈，程序会从`+8`处开始运行，那么`+4`处的指令就直接被跳过了。因此，中断结束后将LR出栈时，要将LR`-4`。\n\n用表格可以解释为：\n|      |            | 状态A：中断前 | 状态B：进入中断后 | 状态C：中断恢复          |\n| ---- | ---------- | ------- | --------- | ----------------- |\n| 0x00 | MOV R1, R0 | 准备执行    | 已执行       |                   |\n| 0x04 | MOV R2, R1 | LR      |           | LR（恢复为状态A时的PC值-4） |\n| 0x08 | MOV R3, R2 | PC      | LR（已入栈）   |                   |\n| 0x0c | MOV R4 ,R3 |         |           |                   |\n|      | PC值        | 0x08    | 0x12      | 由LR值决定            |\n|      | LR值        | 0x04    | 0x08      | 0x04              |\n\n再通俗一点：PC始终指向当前执行指令+8，发生中断时，入栈保存的LR实际上是PC的地址，如果返回时将LR直接赋给PC，中间就跳过了一个指令，因此LR出栈后要`-4`才能赋给PC。\n```\n\tpop {r0}\t\t\t\t\t\t\n\tmsr spsr_cxsf, r0\t\t\t/* 恢复spsr */\n\n\tpop {r0-r3, r12}\t\t\t/* r0-r3,r12出栈 */\n\tpop {lr}\t\t\t\t\t/* lr出栈 */\n\tsubs pc, lr, #4\t\t\t\t/* 将计算后的地址（lr-4）赋给pc */\t\n```\n### 中断驱动文件（C函数）\n1. 中断初始化函数。向量表基地址设置为程序存放开始地址。\n```\nvoid int_init(void) {\n    GIC_Init();                        // 初始化通用中断控制器，该函数由SDK提供\n    system_irqtable_init();            // 初始化中断函数表\n    __set_VBAR((uint32_t)0x87800000);  // 设置向量表基地址\n}\n```\n\n2. 中断向量表初始化。将所有中断初始化为default_irqhandler（死循环），强制开发者显式注册有效ISR，避免未处理中断导致不可控行为。\n```\nvoid system_irqtable_init(void) {\n    unsigned int i = 0;\n    irqNesting = 0;  // 重置嵌套计数器\n    \n    for(i = 0; i < NUMBER_OF_INT_VECTORS; i++) {\n        system_register_irqhandler((IRQn_Type)i, default_irqhandler, NULL);\n    }\n}\n```\n\n3. 中断注册函数。用于绑定中断服务函数和中断源。\n```\nvoid system_register_irqhandler(IRQn_Type irq, system_irq_handler_t handler, void *userParam) {\n    irqTable[irq].irqHandler = handler;   // 注册处理函数\n    irqTable[irq].userParam = userParam;  // 绑定用户参数\n}\n```\n\n4. 中断分发器。默认允许中断嵌套。\n```\nvoid system_irqhandler(unsigned int giccIar) {\n    uint32_t intNum = giccIar & 0x3FFUL;  // 提取中断号\n    \n    /* 校验中断号有效性 */\n    if ((intNum == 1023) || (intNum >= NUMBER_OF_INT_VECTORS)) {\n        return;  // 非法中断号（1023伪中断或中断号不在表内）直接返回\n    }\n \n    irqNesting++;  // 嵌套计数增加\n    \n    /* 调用注册的ISR */\n    irqTable[intNum].irqHandler(intNum, irqTable[intNum].userParam);\n \n    irqNesting--;  // 嵌套计数减少\n}\n```\n\n### 中断处理全流程\n1. 硬件触发：外设触发中断，GIC将中断请求发送至CPU。\n2. 汇编入口：CPU跳转至IRQ_Handler，保存上下文并调用system_irqhandler(giccIar)。\n3. 中断分发：\n    - 解析giccIar获取有效中断号\n    - 查表irqTable[intNum]获取处理函数和参数\n4. ISR执行：执行用户注册的函数（如uart_isr），处理具体中断任务。\n5. 中断结束：汇编代码写GICC_EOIR通知GIC处理完成。\n\n\t\t\t\t\t\n## 示例（定时器按键消抖）\n实现功能：\n1. 按下按键，进入外部中断，在中断中开启定时器\n2. 定时器中断中完成消抖延时，中断周期即为延时时间。如果定时中断触发，表示消抖完成，执行按键处理函数\n### 按键初始化\n1. 设置GPIO复用和Config\n2. 填充gpio结构体，初始化gpio\n3. 使能中断，注册ISR（绑定中断源和对应的ISR）\n4. 初始化定时器\n```\nvoid filterkey_init(void)\n{\t\n\tgpio_pin_config_t key_config;\n\t\n\t/* 1、初始化IO复用 */\n\tIOMUXC_SetPinMux(IOMUXC_UART1_CTS_B_GPIO1_IO18,0);\t/* 复用为GPIO1_IO18 */\n\n\t/* 2、、配置GPIO1_IO18的IO属性\t\n\t *bit 16:0 HYS关闭\n\t *bit [15:14]: 11 默认22K上拉\n\t *bit [13]: 1 pull功能\n\t *bit [12]: 1 pull/keeper使能\n\t *bit [11]: 0 关闭开路输出\n\t *bit [7:6]: 10 速度100Mhz\n\t *bit [5:3]: 000 关闭输出\n\t *bit [0]: 0 低转换率\n\t */\n\tIOMUXC_SetPinConfig(IOMUXC_UART1_CTS_B_GPIO1_IO18,0xF080);\n\t\n\t/* 3、初始化GPIO为中断 */\n\tkey_config.direction = kGPIO_DigitalInput;          /* 输入 */\n\tkey_config.interruptMode = kGPIO_IntFallingEdge;    /* 下降沿触发 */\n\tkey_config.outputLogic = 1;\n\tgpio_init(GPIO1, 18, &key_config);\n\n\tGIC_EnableIRQ(GPIO1_Combined_16_31_IRQn); /* 使能GIC中对应的中断 */\n\t\n\t/* 注册中断服务函数 */\n\tsystem_register_irqhandler(GPIO1_Combined_16_31_IRQn, \n\t\t\t\t\t\t\t   (system_irq_handler_t)gpio1_16_31_irqhandler, \n\t\t\t\t\t\t\t   NULL);\n\t\n\tgpio_enableint(GPIO1, 18);\t\t/* 使能GPIO1_IO18的中断功能 */\n\n\tfiltertimer_init(66000000/100);\t/* 初始化定时器,10ms */\n}\n```\n\n### 定时器初始化\n```\nvoid filtertimer_init(unsigned int value)\n{\n\tEPIT1->CR = 0;\t//先清零\n\t\n\t/*\n     * CR寄存器:\n     * bit25:24 01 时钟源选择Peripheral clock=66MHz\n     * bit15:4  0  1分频\n     * bit3:\t1  当计数器到0的话从LR重新加载数值\n     * bit2:\t1  比较中断使能\n     * bit1:    1  初始计数值来源于LR寄存器值\n     * bit0:    0  先关闭EPIT1\n     */\n\tEPIT1->CR = (1<<24 | 1<<3 | 1<<2 | 1<<1);\n\n\t/* 计数值 */\n\tEPIT1->LR = value;\n\t\n\t/* 比较寄存器，当计数器值和此寄存器值相等的话就会产生中断 */\n\tEPIT1->CMPR\t= 0;\t\n\t\n\tGIC_EnableIRQ(EPIT1_IRQn);\t/* 使能GIC中对应的中断 */\n\t\n\t/* 注册中断服务函数\t\t    */\n\tsystem_register_irqhandler(EPIT1_IRQn, (system_irq_handler_t)filtertimer_irqhandler, NULL);\t\n}\n```\n\n\n### GPIO ISR函数\n```\nvoid gpio1_16_31_irqhandler(void)\n{ \n\t/* 开启定时器 */\n\tfiltertimer_restart(66000000/100);\n\n\t/* 清除中断标志位 */\n\tgpio_clearintflags(GPIO1, 18);\n}\n```\n\n### 定时器 ISR函数\n```\nvoid filtertimer_irqhandler(void)\n{ \n\tstatic unsigned char state = OFF;\n\n\tif(EPIT1->SR & (1<<0)) \t\t\t\t\t/* 判断比较事件是否发生\t\t\t*/\n\t{\n\t\tfiltertimer_stop();\t\t\t\t\t/* 关闭定时器 \t\t\t\t*/\n\t\tif(gpio_pinread(GPIO1, 18) == 0)\t/* KEY0 \t\t\t\t*/\n\t\t{\n\t\t\tstate = !state;\n\t\t\tbeep_switch(state);\t\t\t\t/* 反转蜂鸣器 \t\t\t\t*/\n\t\t}\n\t}\n\t\t\n\tEPIT1->SR |= 1<<0; \t\t\t\t\t\t/* 清除中断标志位 \t\t\t\t*/\n}\n```\n\n### 辅助函数\n```\nvoid filtertimer_stop(void)\n{\n\tEPIT1->CR &= ~(1<<0);\t/* 关闭定时器 */\n}\n\nvoid filtertimer_restart(unsigned int value)\n{\n\tEPIT1->CR &= ~(1<<0);\t/* 先关闭定时器 */\n\tEPIT1->LR = value;\t\t/* 计数值 \t\t\t*/\n\tEPIT1->CR |= (1<<0);\t/* 打开定时器 \t\t*/\n}\n```","categories":["嵌入式(Linux开发)"]},{"title":"I.MX6ULL 时钟配置","url":"/2025/03/03/时钟配置/","content":"## 时钟来源和生成\n![/images/linux/clock_1.png](时钟生成来源)\n包括以下三个时钟来源：\n1. 外部晶振，高速晶振频率24Mhz，低速晶振频率32.768KHz\n2. 低压差分信号 (LVDS) I/O 端口，用于从外部获取时钟信号\n3. 锁相环(PLL)，主时钟包含七个 PLL。其中两个 PLL 分别配备四个相位小数分频器 (PFD)，以生成额外的频率。\n\n七个PLL包括：\n- PLL1(ARM_PLL)，ARM内核时钟，最高可倍频至1.3GHz(但MCU最高仅支持到1.0GHz)\n- PLL2(SYS_PLL/528_PLL)，固定倍频22倍，从外部高速晶振的24MHz倍频产生528MHz，自带四个PFD。通常528_PLL和4路PFD是MX6U内部系统总线的时钟源，如逻辑单元、DDR、NAND/NOR设备等\n- PLL3(USB1_PLL)，USB PHY的第一个实例（USBPHY1，也称为 OTG PHY）一起使用。此 PLL 驱动四个 PFD（PLL3_PFD0...PLL3_PFD3）并以固定乘数 20 运行。这导致 VCO 频率为 480 MHz，振荡器为 24 MHz。主 PLL 输出及其 PFD 输出用作许多需要恒定频率的时钟根的输入，例如 UART 和其他串行接口、音频接口等\n- PLL4(Audio_PLL)，用于生成具有标准音频频率的低抖动和高精度音频时钟。其频率范围为 650 MHz 至 1300 MHz，频率分辨率优于 1 Hz。该时钟主要用作串行音频接口的时钟和外部音频编解码器的参考时钟。\n- PLL5(Video_PLL)，用于生成具有标准视频频率的低抖动和高精度视频时钟。PLL 振荡器频率范围为 650 MHz 至 1300 MHz，频率分辨率优于 1 Hz。该时钟主要用作显示和视频接口的时钟。\n- PLL6(ENET_PLL)，固定(20+5/6)倍频，输出500MHz，用于生成以太网\n- PLL7(USB2_PLL)，专门为 USB2 PHY（USBPHY2，也称为 OTG PHY）提供时钟，固定倍频 20，输出频率480MHz\n\n## CCM时钟树\n![时钟树(1)](/images/linux/clock_2.png)\n\n![时钟树(2)](/images/linux/clock_3.png)\n\n具体参见手册第629页。\n\n## 时钟配置\n以ARM时钟配置为例：\n\n![ARM时钟](/images/linux/clock_4.png)\n\n时钟从PLL1的996MHz开始，通过寄存器CCM_CACRR的ARM_PODF位进行分频，可选1/2/4/8分频，然后得到ARM时钟ARM_CLK_ROOT。灰色的/2分频并未实际效果。其中PLL1频率可通过寄存器CCM_ANALOG_PLL_ARMn设置。\n\n![CCM_CACRR寄存器](/images/linux/clock_5.png)\n\n![CCM_ANALOG_PLL_ARMn寄存器](/images/linux/clock_6.png)\n\n修改PLL1时钟时要首先要切换内核时钟源。\n\n![PLL1时钟源](/images/linux/clock_7.png)\n1. PLL1最终输出时钟频率。\n2. 选择器，用于选择pll1的时钟源，由CCM_CCSR的PLL1_SW_CLK_SEL位决定。默认为pll1_main_clk，但如果要调整pll1_main_clk频率，则首先应将pll_sw_clk切换至step_clk，调整完成后再切换回来。\n3. 选择器，用于选择step_clk的时钟源，由CCM_CCSR的STEP_SEL位决定。默认为osc_clk，即外部高速晶振。\n\n![CCM_CCSR寄存器](/images/linux/clock_8.png)\n\n至此，修改I.MX6U主频的步骤可以归纳为：\n1. 设置CCM_CCSR的STEP_SEL位，设置step_clk时钟源为外部24MHz高速晶振\n2. 设置CCM_CCSR的PLL1_SW_CLK_SEL位，设置pll_sw_clk来源为step_clk=24Mhz\n3. 设置CCM_ANALOG_PLL_ARMn，将pll1_main_clk设置为1056MHz\n4. 设置CCM_CCSR的PLL1_SW_CLK_SEL位，将pll1_sw_clk时钟源切换回pll1_main_clk\n5. 设置CCM_CACRR的ARM_PODF为2分频，完成分频设置\n\n其他的时钟配置方式大同小异。\n\n## 代码\n```\n/*\n * @description\t: 初始化系统时钟，设置系统时钟为792Mhz，并且设置PLL2和PLL3各个\n \t\t\t\t  PFD时钟,所有的时钟频率均按照I.MX6U官方手册推荐的值.\n * @param \t\t: 无\n * @return \t\t: 无\n */\nvoid imx6u_clkinit(void)\n{\n\tunsigned int reg = 0;\n\t/* 1、设置ARM内核时钟为792MHz */\n\t/* 1.1、判断当前ARM内核是使用的那个时钟源启动的，正常情况下ARM内核是由pll1_sw_clk驱动的，而\n\t *      pll1_sw_clk有两个来源：pll1_main_clk和tep_clk。\n\t *      如果我们要让ARM内核跑到792M的话那必须选择pll1_main_clk作为pll1的时钟源。\n\t *      如果我们要修改pll1_main_clk时钟的话就必须先将pll1_sw_clk从pll1_main_clk切换到step_clk,\n\t *\t\t当修改完pll1_main_clk以后在将pll1_sw_clk切换回pll1_main_clk。而step_clk的时钟源可以选择\n\t * \t\t板子上的24MHz晶振。\n\t */\n\t\n\tif((((CCM->CCSR) >> 2) & 0x1 ) == 0) \t/* 当前pll1_sw_clk使用的pll1_main_clk*/\n\t{\t\n\t\tCCM->CCSR &= ~(1 << 8);\t\t\t\t/* 配置step_clk时钟源为24MH OSC */\t\n\t\tCCM->CCSR |= (1 << 2);\t\t\t\t/* 配置pll1_sw_clk时钟源为step_clk */\n\t}\n\n\t/* 1.2、设置pll1_main_clk为792MHz\n\t *      因为pll1_sw_clk进ARM内核的时候会被二分频！\n\t *      配置CCM_ANLOG->PLL_ARM寄存器\n\t *      bit13: 1 使能时钟输出\n\t *      bit[6:0]: 66, 由公式：Fout = Fin * div_select / 2.0，792=24*div_select/2.0,\n\t *              \t\t得出：div_select=    66 \n\t */\n\tCCM_ANALOG->PLL_ARM = (1 << 13) | ((66 << 0) & 0X7F); \t/* 配置pll1_main_clk=792MHz */\n\tCCM->CCSR &= ~(1 << 2);\t\t\t\t\t\t\t\t\t/* 将pll_sw_clk时钟重新切换回pll1_main_clk */\n\tCCM->CACRR = 0;\t\t\t\t\t\t\t\t\t\t\t/* ARM内核时钟为pll1_sw_clk/1=792/1=792Mhz */\n\n\t/* 2、设置PLL2(SYS PLL)各个PFD */\n\treg = CCM_ANALOG->PFD_528;\n\treg &= ~(0X3F3F3F3F);\t\t/* 清除原来的设置 \t\t\t\t\t\t*/\n\treg |= 32<<24;\t\t\t\t/* PLL2_PFD3=528*18/32=297Mhz \t*/\n\treg |= 24<<16;\t\t\t\t/* PLL2_PFD2=528*18/24=396Mhz(DDR使用的时钟，最大400Mhz) */\n\treg |= 16<<8;\t\t\t\t/* PLL2_PFD1=528*18/16=594Mhz \t*/\n\treg |= 27<<0;\t\t\t\t/* PLL2_PFD0=528*18/27=352Mhz  \t*/\n\tCCM_ANALOG->PFD_528=reg;\t/* 设置PLL2_PFD0~3 \t\t \t\t*/\n\n\t/* 3、设置PLL3(USB1)各个PFD */\n\treg = 0;\t\t\t\t\t/* 清零   */\n\treg = CCM_ANALOG->PFD_480;\n\treg &= ~(0X3F3F3F3F);\t\t/* 清除原来的设置 \t\t\t\t\t\t\t*/\n\treg |= 19<<24;\t\t\t\t/* PLL3_PFD3=480*18/19=454.74Mhz \t*/\n\treg |= 17<<16;\t\t\t\t/* PLL3_PFD2=480*18/17=508.24Mhz \t*/\n\treg |= 16<<8;\t\t\t\t/* PLL3_PFD1=480*18/16=540Mhz\t\t*/\n\treg |= 12<<0;\t\t\t\t/* PLL3_PFD0=480*18/12=720Mhz\t \t*/\n\tCCM_ANALOG->PFD_480=reg;\t/* 设置PLL3_PFD0~3 \t\t\t\t\t*/\t\n\n\t/* 4、设置AHB时钟 最小6Mhz， 最大132Mhz (boot rom自动设置好了可以不用设置)*/\n\tCCM->CBCMR &= ~(3 << 18); \t/* 清除设置*/ \n\tCCM->CBCMR |= (1 << 18);\t/* pre_periph_clk=PLL2_PFD2=396MHz */\n\tCCM->CBCDR &= ~(1 << 25);\t/* periph_clk=pre_periph_clk=396MHz */\n\twhile(CCM->CDHIPR & (1 << 5));/* 等待握手完成 */\n\t\t\n\t/* 修改AHB_PODF位的时候需要先禁止AHB_CLK_ROOT的输出，但是\n\t * 我没有找到关闭AHB_CLK_ROOT输出的的寄存器，所以就没法设置。\n\t * 下面设置AHB_PODF的代码仅供学习参考不能直接拿来使用！！\n\t * 内部boot rom将AHB_PODF设置为了3分频，即使我们不设置AHB_PODF，\n\t * AHB_ROOT_CLK也依旧等于396/3=132Mhz。\n\t */\n#if 0\n\t/* 要先关闭AHB_ROOT_CLK输出，否则时钟设置会出错 */\n\tCCM->CBCDR &= ~(7 << 10);\t/* CBCDR的AHB_PODF清零 */\n\tCCM->CBCDR |= 2 << 10;\t\t/* AHB_PODF 3分频，AHB_CLK_ROOT=132MHz */\n\twhile(CCM->CDHIPR & (1 << 1));/\n* 等待握手完成 */\n#endif\n\t\n\t/* 5、设置IPG_CLK_ROOT最小3Mhz，最大66Mhz (boot rom自动设置好了可以不用设置)*/\n\tCCM->CBCDR &= ~(3 << 8);\t/* CBCDR的IPG_PODF清零 */\n\tCCM->CBCDR |= 1 << 8;\t\t/* IPG_PODF 2分频，IPG_CLK_ROOT=66MHz */\n\t\n\t/* 6、设置PERCLK_CLK_ROOT时钟 */\n\tCCM->CSCMR1 &= ~(1 << 6);\t/* PERCLK_CLK_ROOT时钟源为IPG */\n\tCCM->CSCMR1 &= ~(7 << 0);\t/* PERCLK_PODF位清零，即1分频 */\n}\n```"},{"title":"Linux下规范性Makefile规则","url":"/2025/03/02/Linux下规范性Makefile规则/","content":"## 文件目录\n- bsp\n    - clk   (时钟驱动)\n        - bsp_clk.c\n        - bsp_clk.h\n    - delay (延时驱动)\n        - bsp_delay.c\n        - bsp_delay.h\n    - led   (LED驱动)\n        - bsp_led.c\n        - bsp_led.h\n- imx6ul\n    - cc.h  (变量类型声明)\n    - fsl_common.h  (NXP官方SDK通用宏定义文档)\n    - fsl_iomuxc.h  (NXP官方SDK寄存器地址定义文档)\n    - imx6ul.h      (常用头文件)\n    - MCIMX6Y2.h    (NXP官方SDK寄存器结构体和相关位定义文档)\n- obj\n    .o文件目标地址\n- project\n    - main.c    (主函数)\n    - start.S   (启动文件)\n\n\n## Makefile\n```\nCROSS_COMPILE \t?= arm-linux-gnueabihf-\nTARGET\t\t  \t?= bsp\n\nCC \t\t\t\t:= $(CROSS_COMPILE)gcc\nLD\t\t\t\t:= $(CROSS_COMPILE)ld\nOBJCOPY \t\t:= $(CROSS_COMPILE)objcopy\nOBJDUMP \t\t:= $(CROSS_COMPILE)objdump\n\nINCDIRS \t\t:= imx6ul \\\n\t\t\t\t   bsp/clk \\\n\t\t\t\t   bsp/led \\\n\t\t\t\t   bsp/delay \n\t\t\t\t   \t\t\t   \nSRCDIRS\t\t\t:= project \\\n\t\t\t\t   bsp/clk \\\n\t\t\t\t   bsp/led \\\n\t\t\t\t   bsp/delay \n\t\t\t\t   \n\t\t\t\t   \nINCLUDE\t\t\t:= $(patsubst %, -I %, $(INCDIRS))\n\nSFILES\t\t\t:= $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.S))\nCFILES\t\t\t:= $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.c))\n\nSFILENDIR\t\t:= $(notdir  $(SFILES))\nCFILENDIR\t\t:= $(notdir  $(CFILES))\n\nSOBJS\t\t\t:= $(patsubst %, obj/%, $(SFILENDIR:.S=.o))\nCOBJS\t\t\t:= $(patsubst %, obj/%, $(CFILENDIR:.c=.o))\nOBJS\t\t\t:= $(SOBJS) $(COBJS)\n\nVPATH\t\t\t:= $(SRCDIRS)\n\n.PHONY: clean\n\t\n$(TARGET).bin : $(OBJS)\n\t$(LD) -Timx6ul.lds -o $(TARGET).elf $^\n\t$(OBJCOPY) -O binary -S $(TARGET).elf $@\n\t$(OBJDUMP) -D -m arm $(TARGET).elf > $(TARGET).dis\n\n$(SOBJS) : obj/%.o : %.S\n\t$(CC) -Wall -nostdlib -c -O2  $(INCLUDE) -o $@ $<\n\n$(COBJS) : obj/%.o : %.c\n\t$(CC) -Wall -nostdlib -c -O2  $(INCLUDE) -o $@ $<\n\t\nclean:\n\trm -rf $(TARGET).elf $(TARGET).dis $(TARGET).bin $(COBJS) $(SOBJS)\n\n```\n\n## 细节\n### 工具配置\n```\nCROSS_COMPILE \t?= arm-linux-gnueabihf-     # 交叉编译工具前缀（ARM架构）\nTARGET\t\t  \t?= bsp                      # 目标程序名称，默认输出文件名为 `bsp`\n\nCC \t\t\t\t:= $(CROSS_COMPILE)gcc      # C 编译器\nLD\t\t\t\t:= $(CROSS_COMPILE)ld       # 链接器\nOBJCOPY \t\t:= $(CROSS_COMPILE)objcopy  # 二进制转换工具\nOBJDUMP \t\t:= $(CROSS_COMPILE)objdump  # 反汇编工具\n```\n\n### 目录与文件管理\n```\nINCDIRS := imx6ul \\            # 头文件搜索目录列表，\"\\\"为换行符\n           bsp/clk \\\n           bsp/led \\\n           bsp/delay\n\nSRCDIRS := project \\           # 源码搜索目录列表，\"\\\"为换行符\n           bsp/clk \\\n           bsp/led \\\n           bsp/delay\n\nINCLUDE := $(patsubst %, -I %, $(INCDIRS))  # 将 INCDIRS 转换为 gcc 的 `-I` 选项\n```\n`patsubst`:\n- 函数用法：`$(patsubst <pattern>,<replacement>,<text>`\n\n- 名称：模式字符串替换函数——patsubst。\n\n- 功能：查找`<text>`中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式`<pattern>`，如果匹配的话，则以`<replacement>`替换。这里，`<pattern>`可以包括通配符“%”，表示任意长度的字串。如果`<replacement>`中也包含“%”，那么`<replacement>`中的这个“%”将是`<pattern>`中的那个“%”所代表的字串。（可以用“\\”来转义，以“\\%”来表示真实含义的“%”字符）\n\n- 返回：函数返回被替换过后的字符串。\n\n- 示例：`$(patsubst %.c,%.o, a.c b.c)`，把字串“a.c b.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“a.o b.o”\n\n### 源码文件收集\n```\nSFILES := $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.S))  # 所有 .S 汇编文件\nCFILES := $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.c))  # 所有 .c C 文件\n\nSFILENDIR := $(notdir $(SFILES))  # 去除路径，保留文件名（如 `start.S`）\nCFILENDIR := $(notdir $(CFILES))  # 去除路径，保留文件名（如 `main.c`）\n\nSOBJS := $(patsubst %, obj/%, $(SFILENDIR:.S=.o))  # 汇编文件对应的 .o 文件（放在 obj 目录）\nCOBJS := $(patsubst %, obj/%, $(CFILENDIR:.c=.o))  # C 文件对应的 .o 文件（放在 obj 目录）\nOBJS  := $(SOBJS) $(COBJS)                        # 所有目标文件\n\nVPATH := $(SRCDIRS)  # 指定源码搜索路径，Make 会在这些目录中查找依赖文件\n```\n\n`foreach`：\n\n- 用法：`$(foreach <var>, <list>, <expr>)`\n\n- 功能：遍历 `<list>` 中的每个元素，将元素赋值给 `<var>`，然后展开 `<expr>`，最终将所有展开结果合并成一个空格分隔的字符串。\n\n- 示例中的用法：遍历 `SRCDIRS` 中的每个目录，收集所有 `.S` 和 `.c` 文件的完整路径。\n    1. `dir` 依次取 `SRCDIRS` 中的值（如 `project`, `bsp/clk` 等）\n    2. `$(wildcard $(dir)/*.S)` 展开为 `dir` 目录下所有 `.S` 文件的路径（如 `project/start.S, bsp/clk/clk.S`）。\n    3. 最终 `SFILES` 是所有 `.S` 文件的路径列表，`CFILES` 是所有 `.c` 文件的路径列表。\n\n`wildcard`：\n- 用法：`$(wildcard <pattern>)`\n- 功能：匹配符合 `<pattern>` 的文件路径，支持通配符 * 和 ?。\n- 示例中的用法:在 `foreach` 循环中，为每个 `dir` 目录生成文件列表。\n\n### 生成二进制文件\n```\n$(TARGET).bin : $(OBJS)                       # 依赖所有 .o 文件\n\t$(LD) -Timx6ul.lds -o $(TARGET).elf $^    # 1. 链接生成 ELF 文件\n\t$(OBJCOPY) -O binary -S $(TARGET).elf $@  # 2. 提取二进制文件\n\t$(OBJDUMP) -D -m arm $(TARGET).elf > $(TARGET).dis  # 3. 生成反汇编文件\n```\n\n### 编译规则\n```\n$(SOBJS) : obj/%.o : %.S      # 编译 .S 汇编文件（需预处理的汇编）\n\t$(CC) -Wall -nostdlib -c -O2 $(INCLUDE) -o $@ $<\n```\n- `-nostdlib`：不链接标准库，适用于裸机程序\n- `-O2`：优化等级为2\n- `$(INCLUDE)`：包含头文件目录的`-I`选项\n\n```\n$(COBJS) : obj/%.o : %.c      # 编译 .c C 文件\n\t$(CC) -Wall -nostdlib -c -O2 $(INCLUDE) -o $@ $<\n```\n\n### 清理规则\n```\nclean:\n\trm -rf $(TARGET).elf $(TARGET).dis $(TARGET).bin $(COBJS) $(SOBJS)\n```\n\n## 完整流程：\n1. 收集源码路径：\n    - `SFILES = project/start.S bsp/clk/clk.S`\n    - `CFILES = project/main.c bsp/clk/clk.c`\n2. 提取文件名：\n    - `SFILENDIR = start.S clk.S`\n    - `CFILENDIR = main.c clk.c`\n3. 生成目标文件列表\n    - `SOBJS = obj/start.o obj/clk.o`\n    - `COBJS = obj/main.o obj/clk.o`\n    - `OBJS = obj/start.o obj/clk.o obj/main.o obj/clk.o`\n4. 编译时\n    - Make 根据 `VPATH` 在 `project` 和 `bsp/clk` 目录中查找 `start.S` 和 `clk.c` 等文件。","categories":["嵌入式(Linux开发)"]},{"title":"LVGL发生各种卡死现象的原因分析和排故","url":"/2025/02/20/LVGL发生各种卡死现象的原因分析和排故/","content":"## 前言\nLVGL是一个在使用时非常容易产生卡死故障的GUI库，大多数卡死都发生在动态阶段，包括且不仅限于：\n- 启动并初始化第一个页面时\n- 在多个页面间来回切换\n- 触发组件回调时（例如button或timer）\n- 长时间运行后\n\n本文所提供的解决方案就是我自己摸索出来的，不一定适用于所有人，也不一定是最标准的办法。网上关于LVGL的教程很多，包括官方文档，但是很多方法都是不怎么规范的。官方的Github issue中也有很多奇奇怪怪的问题，哪怕是LVGL的作者也无法解决或定位错误。但是LVGL已经迭代到了V9版本，大多数因为自带库问题导致的错误已经得到修复，由LVGL本身带来的致命错误已经很少，大多数错误都来源于用户自身的不规范代码或者是用法。\n\n如果你的LVGL例程发生了卡死，首先应当按照以下步骤尝试解决：\n1. 更新LVGL版本至最新。同时，确保你使用的函数在最新的LVGL中仍然可用。LVGL库函数迭代的很快，且自从v8.3之后几乎每个小版本都有大改，v9之后更是删了一大批我认为很好用的功能（比如`lv_label_recolor()`）。如果你抄了一个旧版本的函数并在新版本的lvgl环境下使用它，可能导致问题\n2. 尝试在模拟器中复现代码，确认是否是LVGL库自身的问题\n3. 如果LVGL工作在OS下，尝试在裸机中复现问题；如果裸机和OS下都发生问题，说明部分代码可能存在问题；如果裸机下工作正常，大概率是线程问题导致的LVGL错误。\n\n如果尝试过上述方法之后问题还没有解决，应考虑是用户代码造成的问题。\n\n## 排故\n在开始前，确保在`lv_conf.h`中启用内存监视和CPU占用监视，具体为：\n```\n/*1: Enable system monitor component*/\n/*1: Enable system monitor component*/\n#define LV_USE_SYSMON   1\n#if LV_USE_SYSMON\n    /*Get the idle percentage. E.g. uint32_t my_get_idle(void);*/\n    #define LV_SYSMON_GET_IDLE lv_timer_get_idle\n\n    /*1: Show CPU usage and FPS count\n     * Requires `LV_USE_SYSMON = 1`*/\n    #define LV_USE_PERF_MONITOR 1       /* 启用CPU性能监视 */\n    #if LV_USE_PERF_MONITOR\n        #define LV_USE_PERF_MONITOR_POS LV_ALIGN_BOTTOM_RIGHT\n\n        /*0: Displays performance data on the screen, 1: Prints performance data using log.*/\n        #define LV_USE_PERF_MONITOR_LOG_MODE 0\n    #endif\n\n    /*1: Show the used memory and the memory fragmentation\n     * Requires `LV_USE_STDLIB_MALLOC = LV_STDLIB_BUILTIN`\n     * Requires `LV_USE_SYSMON = 1`*/\n    #define LV_USE_MEM_MONITOR 1        /* 启用内存监视 */\n    #if LV_USE_MEM_MONITOR\n        #define LV_USE_MEM_MONITOR_POS LV_ALIGN_BOTTOM_LEFT\n    #endif\n\n#endif /*LV_USE_SYSMON*/\n```\n### 启动时卡死、白屏、花屏\n非常常见的情况。首先在初始化后移除所有的对象创建函数，仅保留一个最基本的创建空白屏幕的函数，这么做是为了排除其他对象引起的干扰因素。\n\n然后，按照下列顺序检查：\n1. 硬件问题。\n- 确保屏幕和MCU硬件连接正确。最好的方式是先不跑LVGL，而是用一个最基本的填色函数来测试屏幕是否工作正常。\n- 确保供电满足要求\n- 确保时钟源正确配置\n\n2. 检查MCU启动文件中栈和堆大小是否设置正确。 LVGL正常运行至少需要以下条件：\n~~~\nFlash/ROM: > 64 kB for the very essential components (> 180 kB is recommended)\n\nRAM:\nStatic RAM usage: ~2 kB depending on the used features and object types\n\nstack: > 2kB (> 8 kB is recommended)\n\nDynamic data (heap): > 2 KB (> 48 kB is recommended if using several objects).\nSet by LV_MEM_SIZE in lv_conf.h.\n\nDisplay buffer: > \"Horizontal resolution\" pixels (> 10 \"Horizontal resolution\" is recommended)\n\nOne frame buffer in the MCU or in an external display controller\n~~~\n3. 检查`lv_conf.h`中内存缓存地址及大小是否设置正确：\n```\n#if LV_USE_STDLIB_MALLOC == LV_STDLIB_BUILTIN\n    /*Size of the memory available for `lv_malloc()` in bytes (>= 2kB)*/\n    #define LV_MEM_SIZE (300U * 1024U)          /*[bytes]*/\n\n    /*Size of the memory expand for `lv_malloc()` in bytes*/\n    #define LV_MEM_POOL_EXPAND_SIZE 0\n\n    /*Set an address for the memory pool instead of allocating it as a normal array. Can be in external SRAM too.*/\n    #define LV_MEM_ADR (0XC0000000+1024*600*2)     /*0: unused*/\n    /*Instead of an address give a memory allocator that will be called to get a memory pool for LVGL. E.g. my_malloc*/\n    #if LV_MEM_ADR == 0\n        #undef LV_MEM_POOL_INCLUDE\n        #undef LV_MEM_POOL_ALLOC\n    #endif\n#endif  /*LV_USE_STDLIB_MALLOC == LV_STDLIB_BUILTIN*/\n```\n我这里使用的是外部SDRAM作为lvgl的显存地址，大小为300KB。如果启动时白屏，优先考虑增加`LV_MEM_SIZE`的大小，至少为64KB。如果增加至64KB还未能解决卡死的问题，如果原本现存位置是MCU内部SRAM，考虑将显存移至外部SDRAM；如果原本是外部SDRAM，考虑移动至内部SRAM。\n\n4. 检查`lv_port_disp.c`和`lv_port_indev.c`\n\n确认以下项设置正确：\n- 屏幕分辨率：\n```\n#ifndef MY_DISP_HOR_RES\n    #warning Please define or replace the macro MY_DISP_HOR_RES with the actual screen width, default value 320 is used for now.\n    #define MY_DISP_HOR_RES    1024\n#endif\n\n#ifndef MY_DISP_VER_RES\n    #warning Please define or replace the macro MY_DISP_VER_RES with the actual screen height, default value 240 is used for now.\n    #define MY_DISP_VER_RES    600\n#endif\n```\n屏幕分辨率如果比实际屏幕大，会导致花屏；如果比实际小，可能导致显示错位。\n\n- `disp_flush()`是否在初始化后被正确调用\n\n- 颜色深度是否选择正确，lvgl默认为RGB565\n\n- 是否选择了正确的输入设备，没有用到的输入设备所对应的初始化代码要注释掉。\n\n如果LVGL初始化正确并进入了空白屏幕，那么至少屏幕左下角和右下角会分别显示内存监视和CPU监视的小窗口，且CPU监视窗口的数字应当是在动态变化的。\n\n### 切换页面时卡死或花屏\n通常认为，有两种切换屏幕的方式：\n- 通过`lv_obj_clean`或`lv_obj_del`删除旧页面，然后`lv_scr_load`创建新页面。比如：\n```\n        lv_obj_t *act_scr = lv_scr_act();\n        lv_obj_del(act_scr);\n        create_main_scr();        \n        lv_scr_load(main_scr);\n```\n- 通过向页面添加或移除`LV_OBJ_FLAG_HIDDEN`来控制页面的可视化，这么做需要事先一次性创建完所有可能需要显示的页面并添加flag，比如：\n```\n        lv_obj_add_flag(main_screen, LV_OBJ_FLAG_HIDDEN); /* 隐藏页面 */\n        lv_obj_clear_flag(main_screen, LV_OBJ_FLAG_HIDDEN); /* 显示页面 */\n```\n\n*建议*：**不要**使用第二种通过控制`FLAG_HIDDEN`来实现切换页面的方法，除非你真的确认第一种方法没法使用。因为：\n- 初始化时一次性创建大量页面及其子类对象会极大的增加CPU和内存负担。应尽可能降低同时操作多个对象的可能性。\n- 浪费内存，造成内存泄漏，页面管理混乱。\n- 在LVGL v9及以上版本使用时，大概率导致花屏（很多例子），推测是多个对象叠加带来的内存问题。\n\n如果修改为第一种方法后还出现错误，参照以下步骤：\n1. 确保LVGL版本为最新。LVGL v9中`lv_scr_load()`函数的执行步骤是：\n    1. 获取当前活动屏幕和其关联的显示器对象\n    2. 判断当前屏幕是否为待切换的目标屏幕，如果是，退出函数\n    3. 判断是否有切换动画正在执行，如果有，立即切换至目标屏幕\n    4. 切换后，删除旧屏幕，更新`acr_scr`指针至目标屏幕\n    \n    这里的切换逻辑已经写的非常合理了，如果还是有错误：\n2. 确保使用`lv_obj_del()`而不是`lv_obj_clean()`来删除旧屏幕。两个函数的功能有区别，`lv_obj_del()`会立即删除对象本身和其子项，而`lv_obj_clean()`仅删除目标对象的子项，而不删除目标对象本身，这可能造成内存泄漏。\n\n3. 调换`lv_obj_del()`和`lv_scr_load()`的位置，即先创建新屏幕，再删除旧屏幕。之前有Github issue报告称在创建新屏幕前就删除旧屏幕可能导致内存池问题，lvgl会访问空指针导致hardfault。\n\n4. 确保旧屏幕（包括其子项）和新屏幕（包括其子项）之间的对象依赖关系正确。具体一点来说：\n    - 新屏幕必须已经被创建（父对象必须实际存在且为静态）\n    - 新屏幕中的子项不能指向、包含或引用不存在的对象。这么说的意思是，如果你是在切换屏幕时才创建新屏幕中的对象，那么这个对象在切换屏幕前是不存在的。如果子项试图访问一个并不实际存在的对象，即访问一个空指针，那么LVGL就会卡死。举个例子：\n    ```\n    static void btn_to_main_page_cb(lv_event_t *e){\n    if (lv_event_get_code(e) == LV_EVENT_CLICKED){\n        lv_obj_t *act_scr = lv_scr_act();\n        create_main_scr();        \n        lv_scr_load(main_scr);  /* 切换至main_scr() *、`\n        lv_obj_del(act_scr);\n    }\n    }\n\n    static void create_main_scr(){\n        /* ..... */\n        lv_label_set_text_fmt(Example_label);\n    }\n    ```\n\n    这个例子里，我即将切换到的目标屏幕中包含一个对`Example_label`的操作，而`Example_label`可能是在其他屏幕初始化函数中被创建的，那么必须确保在切换前`Example_label`就已经存在。\n\n5. 如果启用了定时器(lv_timer)，检查定时器创建位置和回调执行位置。假设`lv_timer_1`用于实时更新`test_scr`中的某个label组件，那么`lv_timer_1`应当只在进入`test_scr`后被创建，如果其他屏幕没有用到`lv_timer_1`，那么`lv_timer_1`在退出`test_scr`前就应当被销毁（先销毁定时器，再删除旧屏幕），尤其是当`lv_timer_1`的回调函数中包括对`test_scr`中子对象的引用、指向和删除操作时，因为一旦退出`test_scr`，回调函数所指向的对象就不再存在（被删除），即指向空指针，LVGL会立即卡死。\n\n    推荐使用这种方式来管理定时器的创建：\n    ```\n    static void lvgl_create_timers_1(void)\n    {\n    // 如果存在旧的定时器对象\n    if (timer_1 != NULL) {\n        lv_timer_del(timer_1);  // 删除旧的定时器\n        timer_1 = NULL;         // 清空指针\n    }\n\n    // 创建新的定时器\n    timer_1 = lv_timer_create(lvgl_timer_1_cb, 500, NULL);\n    }\n    ```\n\n6. 如果到这里还没有解决问题，应使用IDE的debug功能进行单步调试，定位故障来源。下面是几个例子：\n    - 函数卡死在`lv_tlsf.c`中的某个函数：内存管理出现问题，极大可能是访问或释放了不存在的内存（空指针），确保正确处理了对象之间的依赖关系。\n    - 函数卡死在`delay`函数：函数停在这里是正常现象，这里的卡死指的是一直在delay中循环而不跳出，考虑时钟问题，可能的情况下降低屏幕时钟频率。\n    - 函数跳转至`hardfault_handler()`：非LVGL自身原因带来的问题，必定是用户的代码产生了错误。\n\n### 触发组件回调时卡死\n1. 不要在回调中使用`while`、`for`或长时间的延时\n2. 不要在回调函数中访问已经被删除或无效的对象，参加上一小节中的第5条。这一条看似不起眼，但很多人都不会意识到这个问题\n3. LVGL不是线程安全的。如果在OS中使用LVGL，考虑为回调函数添加标志位或互斥锁，避免竞态条件\n4. 尽可能地优化代码，不要嵌套过多的API或一次性创建大量对象，github issue中有因为这么干而造成栈溢出的。\n\n### 长时间运行后卡死\n99%是内存问题。确保创建新对象后删除旧对象并释放内存。\n\n## 后话\n最后，一些好习惯，能够高效的进行debug：\n- 对LVGL申请的关键内存添加`static`，尤其是各种缓冲区\n- 发生错误时，从父类到子类、从大到小、从前到后依次定位故障来源，着重关注“动态阶段”，也就是创建对象、删除对象、刷新对象等等的这些操作\n- 善用搜索功能和官方文档","categories":["嵌入式（裸机开发）"]},{"title":"C++类构造函数初始化列表","url":"/2025/02/18/C-类构造函数初始化列表/","content":"使用初始化列表的构造函数显式的初始化类的成员：\n```\nclass example{\npublic:\n    int a;\n    float b;\n\n    example(): a(0), b(8.8)\n    {}\n}\n```\n没使用初始化列表的构造函数是对类的成员赋值，并没有进行显式的初始化:\n```\nclass example{\npublic:\n    int a;\n    float b;\n\n    example()\n    {\n        a = 0;\n        b = 8.8;\n    }\n}\n```\n初始化和赋值对内置类型的成员没有什么大的区别，像上面的任一个构造函数都可以。对非内置类型成员变量，为了避免两次构造，推荐使用类构造函数初始化列表。但有的时候必须用带有初始化列表的构造函数：\n- 成员类型是**没有默认构造函数的类**。若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。\n- **const成员或引用类型的成员**。因为 const 对象或引用类型只能初始化，不能对他们赋值。\n\n*初始化数据成员与对数据成员赋值的含义是什么？有什么区别？*\n\n对于内置数据类型和复合类型（指针，引用），初始化过程在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的；而对于用户定义类型（类类型），初始化结果相同，但是性能上存在很大的差别。因为类类型的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行构造对象的工作，调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成（如果并未提供，则使用编译器提供的默认按成员赋值行为）。\n\n*注意*：C++初始化类成员时，按照**声明的顺序**初始化，而不是按照出现在初始化列表中的顺序。这意味着，即使你在初始化列表中改变了成员的初始化顺序，实际初始化时仍然会按照声明顺序进行。\n```\nclass MyClass {\npublic:\n    int a;\n    int b;\n\n    // 构造函数\n    MyClass(int x, int y) : b(x), a(y) {\n        // 尽管初始化列表中 b 在 a 前面，但实际初始化顺序是 a 先于 b\n    }\n};\n```\n很显然这会带来潜在问题，比如如果初始化顺序依赖于其他成员的值，可能会导致未定义行为。例如：\n```\nclass MyClass {\npublic:\n    int a;\n    int b;\n\n    // 构造函数\n    MyClass(int x) : b(x), a(b + 1) {\n        // 这里 a 依赖于 b 的值，但由于 a 先初始化，b 还未初始化，导致未定义行为\n    }\n};\n```\n要解决这个问题，正确做法是确保初始化顺序不依赖于其他成员的值，或者调整成员的声明顺序：\n```\nclass MyClass {\npublic:\n    int b;\n    int a;\n\n    // 构造函数\n    MyClass(int x) : b(x), a(b + 1) {\n        // 现在 b 先于 a 初始化，a 可以正确使用 b 的值\n    }\n};\n```","categories":["C++"]},{"title":"适用于Cortex-A的常见GNU汇编语法","url":"/2025/02/18/适用于Cortex-A的常见GNU汇编语法/","content":"## 语句\nGNU 汇编语法适用于所有的架构，并不是 ARM 独享的，GNU 汇编由一系列的语句组成，每行一条语句，每条语句有三个可选部分：`label: instruction @ comment`\n- `label`：标号，表示地址位置\n- `instruction`：指令，汇编指令或伪指令\n- `@ comment`：注释\n\nARM中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用。\n\n## 伪操作（伪指令）\n用户可通过`.section`伪操作来定义一个段，汇编系统预定义了一些段名，包括：\n- `.text`：代码段\n- `.data`：初始化的数据段\n- `.bss`：未初始化的数据段\n- `.rodata`：只读数据段\n\n`.section`也可用于自定义段，每个段以段名开始，以下一段名或文件结尾结束。如`.section .testsection @顶一个testsection段`\n\n汇编程序的默认入口标号是`_start`，不过我们也可以在链接脚本中使用`ENTRY`来指明其它的入口点，下面的代码就是使用`_start`作为入口标号：\n``\n.global _start \n\n_start:\nldr r0, =0x12 @r0=0x12\n``\n代码中`.global`是伪操作，表示`_start`是一个全局标号（性质类似于C语言中的全局变量）。\n\n常见的伪指令有：\n- `.global`：声明全局符号，如`.global main @声明main为全局符号`\n- `.section`：定义段\n- `.word`：定义字数据\n- `.asciz`：定义以null结尾的字符串，如`.asciz \"Hello World\"`\n- `.byte`：定义单字节数据，比如`.byte 0x12`\n- `.short`：定义双字节数据，比如`.short 0x1234`\n- `.long`：定义一个4字节数据，比如`.long 0x12345678`\n- `.equ`：赋值，如`.equ num, 0x12`表示`num=0x12`\n- `.align`：数据字节对齐，`.align 4`表示4字节对齐\n- `.end`：表示源文件结束\n\n## 处理器内部数据传输指令\n最常见的一类指令，包括：\n- 将数据从一个寄存器传递到另外一个寄存器\n- 将数据从一个寄存器传递到特殊寄存器，如 CPSR 和 SPSR 寄存器\n- 将立即数传递到寄存器\n\n### MOV\n将数据从一个寄存器拷贝到另一个寄存器，或将一个立即数传递到寄存器中。\n```\nMOV R0, R1      @寄存器R1中的数据传递给R0\nMOV R0, #0x12   @立即数0x12传递给R0\n```\n### MRS\n将特殊寄存器（如CPSR和SPSR）中的数据传递给通用寄存器。*注意*：读取特殊寄存器数据时只能使用`MRS`指令。\n```\nMRS R0, CPSR\n```\n### MSR\n将普通寄存器的数据传递至特殊寄存器，即写入特殊寄存器。\n```\nMSR CPSR, R0\n```\n\n## 存储器访问指令\nARM无法直接访问存储器（如RAM）。以I.MX6UL为例，其寄存器为RAM类型，汇编配置寄存器时需借助存储器访问指令，将待配置的值写入到Rx(x=0~12)寄存器中，然后借助存储器访问指令将Rx中的数据写入之MX6UL的寄存器中，读取亦同。\n### LDR\n用于从存储器加载数据至寄存器Rx中，也可以将一个立即数加载到寄存器Rx中。加载立即数时，使用`=`而不是`#`，如`=0xFFFFFFFF`。\n\n在嵌入式开发中，LDR最常用的就是读取CPU的寄存器值：\n```\nLDR R0, =0x0209C004     @将寄存器地址0x0209C004加载到R0中，准备寻址\nLDR R1, [R0]            @读取地址0x0209C004中的值到R1中\n```\n### STR\n与LDR相反，STR用于将数据写入到存储器中。\n```\nLDR R0, =0x0209C004     @寄存器地址0x0209C004写入R0\nLDR R1, =0x20000002     @待写入值0x20000002写入R1\nSTR R1, [R0]            @R1中的值写入R0中所保存的地址中\n```\n\n## 跳转指令\n### B指令\nB指令将PC寄存器的值设置为目标跳转地址，一旦执行B指令，ARM处理器就会立即跳转至指定的目标地址。如果待调用函数不会再返回到原来的执行处，就可以使用B指令。\n```\n_start:\n    ldr sp, =0x80200000     @设置栈指针\n    b main                  @跳转到main函数\n```\n### BL指令\n相比B指令，BL指令在跳转之前会在寄存器 LR(R14) 中保存当前 PC 寄存器值，所以可以通过将 LR 寄存器中的值重新加载到 PC 中来继续从跳转之前的代码处运行，这是子程序调用一个基本但常用的手段，常见于各种中断服务程序。\n\nCortex-A 处理器的 irq 中断服务函数都是汇编写的，主要用汇编来实现现场的保护和恢复、获取中断号等。但是具体的中断处理过程都是 C 函数，所以就会存在汇编中调用 C 函数的问题。而且当 C 语言版本的中断处理函数执行完成以后是需要返回到 irq 汇编中断服务函数，因为还要处理其他的工作，一般是恢复现场。这个时候就不能直接使用 B 指令了，因为 B 指令一旦跳转就再也不会回来了，这个时候要使用 BL 指令，示例代码如下：\n\n```\npush {r0, r1}           @入栈，保存R0, R1\ncps #0x13               @进入SVC模式，CPS指令用于直接修改CPSR寄存器的M[4:0]，让CPU进入不同的模式\n\nbl system_irqhandler    @加载C语言中断处理函数至R2寄存器\n\ncps #0x12               @进入IRQ模式\npop {r0, r1}            @恢复现场\nstr r0, {r1, 0#10}      @中断执行完成，写EOIR\n```\n\n## ARM中常见的寄存器\n几个ARM中常用的寄存器：\n- IP寄存器：内部程序调用暂存寄存器，子程序的连接text段中常使用该规则\n- SP寄存器：栈指针寄存器，用于存储当前栈顶地址。程序执行过程中，栈是用来存储临时变量、函数调用返回地址等数据的重要数据结构，SP寄存器的值会随着栈的变化而变化\n- LR寄存器：连接寄存器，程序跳转（子程序调用，中断跳转）后，arm自动在该寄存器中存入原程序（未跳转）的下一条指令的地址，也叫函数调用返回地址。当一个函数被调用时，LR寄存器会存储调用该函数的下一条指令的地址，当函数执行完毕后，程序会跳转到LR寄存器中存储的地址继续执行。\n- PC寄存器：程序计数器，保存的是当前正在取指的指令的地址（arm采用2级流水线，因此是当前正在执行指令的地址+8）。PC寄存器是ARM中的程序计数器，用于存储下一条将要执行的指令的地址。\n\n此外，还有两个比较重要的状态寄存器：\n- CPSR：程序状态寄存器，在任何处理器模式下被访问。它包含了条件标志位、中断禁止位、当前处理器模式标志以及其他的一些控制和状态位。CPSR在用户级编程时用于存储条件码。\n- SPSR：程序状态保存寄存器，每一种处理器模式下都有一个状态寄存器SPSR,SPSR用于保存CPSR的状态，以便异常返回后恢复异常发生时的工作状态。当特定的异常中断发生时，这个寄存器用于存放当前程序状态寄存器的内容。在异常中断退出时，可以用SPSR来恢复CPSR。由于用户模式和系统模式不是异常中断模式，所以他没有SPSR。当用户在用户模式或系统模式访问SPSR，将产生不可预知的后果。\n\n二者常用于MRS或MSR指令,用于spsr中的值转移到寄存器或把寄存器的内容加载到spsr中，如:\n\n```\nmrs r0, spsr                /* 读取spsr寄存器 */\nmsr spsr_cxsf, r0            /* 恢复spsr */\n```\n\nARM进入异常模式后，SPSR自动保存进入异常前的CPSR的值，以便异常返回后恢复异常发生时的工作状态。\n\n## LED点灯示例\n```\n.global _start  /* 全局标号 */\n\n/*\n * 描述：\t_start函数，程序从此函数开始执行此函数完成时钟使能、\n *\t\t  GPIO初始化、最终控制GPIO输出低电平来点亮LED灯。\n */\n_start:\n\t/* 例程代码 */\n\t/* 1、使能所有时钟 */\n\tldr r0, =0X020C4068 \t/* CCGR0 */\n\tldr r1, =0XFFFFFFFF  \n\tstr r1, [r0]\t\t\n\t\n\tldr r0, =0X020C406C  \t/* CCGR1 */\n\tstr r1, [r0]\n\n\tldr r0, =0X020C4070  \t/* CCGR2 */\n\tstr r1, [r0]\n\t\n\tldr r0, =0X020C4074  \t/* CCGR3 */\n\tstr r1, [r0]\n\t\n\tldr r0, =0X020C4078  \t/* CCGR4 */\n\tstr r1, [r0]\n\t\n\tldr r0, =0X020C407C  \t/* CCGR5 */\n\tstr r1, [r0]\n\t\n\tldr r0, =0X020C4080  \t/* CCGR6 */\n\tstr r1, [r0]\n\t\n\n\t/* 2、设置GPIO1_IO03复用为GPIO1_IO03 */\n\tldr r0, =0X020E0068\t/* 将寄存器SW_MUX_GPIO1_IO03_BASE加载到r0中 */\n\tldr r1, =0X5\t\t/* 设置寄存器SW_MUX_GPIO1_IO03_BASE的MUX_MODE为5 */\n\tstr r1,[r0]\n\n\t/* 3、配置GPIO1_IO03的IO属性\t\n\t *bit 16:0 HYS关闭\n\t *bit [15:14]: 00 默认下拉\n     *bit [13]: 0 kepper功能\n     *bit [12]: 1 pull/keeper使能\n     *bit [11]: 0 关闭开路输出\n     *bit [7:6]: 10 速度100Mhz\n     *bit [5:3]: 110 R0/6驱动能力\n     *bit [0]: 0 低转换率\n     */\n    ldr r0, =0X020E02F4\t/*寄存器SW_PAD_GPIO1_IO03_BASE */\n    ldr r1, =0X10B0\n    str r1,[r0]\n\n\t/* 4、设置GPIO1_IO03为输出 */\n    ldr r0, =0X0209C004\t/*寄存器GPIO1_GDIR */\n    ldr r1, =0X0000008\t\t\n    str r1,[r0]\n\n\t/* 5、打开LED0\n\t * 设置GPIO1_IO03输出低电平\n\t */\n\tldr r0, =0X0209C000\t/*寄存器GPIO1_DR */\n   ldr r1, =0\t\t\n   str r1,[r0]\n\n/*\n * 描述：\tloop死循环\n */\nloop:\n\tb loop \t\t\t\t\n```\n","categories":["嵌入式(Linux开发)"]},{"title":"意外修改/usr/sudo所属组和权限后的恢复方法","url":"/2025/02/18/意外修改-usr-sudo所属组和权限后的恢复方法/","content":"## 问题来源\n使用`arm-linux-gnueabihf-gcc`交叉编译时，提示权限不足，尝试修改目标编译文件和sudo权限，意外对/usr/bin使用了`sudo chmod 777 /usr/bin`命令。\n## Solution\n在无法获得root用户名和密码的情况下，参考一下方式解决：\n1. 重启电脑按住Shift不放进入grub，选择Ubuntu Advanced Options\n2. 选择recovery mode，进入恢复模式\n3. Recovery menu中选择root，回车\n4. `chown root:root   /usr/bin/sudo`，`chmod 4755  /usr/bin/sudo`\n5. `chown root:root   /usr/lib/sudo/sudoers.so`，`chmod 4755  /usr/lib/sudo/sudoers.so`\n6. `reboot`，重新进入系统\n\n谨慎对待Linux中重要文件的权限组和所属用户组问题。\n","categories":["嵌入式(Linux开发)"]},{"title":"Cpp中的虚函数与纯虚函数","url":"/2025/02/15/Cpp中的虚函数与纯虚函数/","content":"## 虚函数\n```\nclass Animal {\npublic:\n\tvirtual void speak() {\n\t\tstd::cout << \"Animal speaks\" << std::endl;\n\t}\n};\n```\n虚函数在基类中使用`virtual`关键字声明成员函数，并允许子类重写该函数，以提供特定于子类的实现。通俗一点的讲：\n- 如果子类没有重写该函数（即提供虚函数的实现），将会自动调用基类的缺省虚函数实现\n- 如果子类重写了该函数，则调用重写后的实现\n\n创建虚函数时，虚函数所在类在申请内存时会同时生成虚函数指针`vptr`，该指针指向“虚函数表”`vtbl`，表中数据为函数指针，存储了对应虚函数具体实现所对应的位置。\n\n因此，虚函数的实现过程是：\n1. 通过对象内存中的虚函数指针`vptr`找到虚函数表`vtbl`\n2. 通过`vtbl`中的函数指针找到对应虚函数的实现区域并进行调用\n\n### 示例\n```\n#include <iostream>\n\nclass Animal {\npublic:\n    //声明虚函数\n\tvirtual void speak() {\n\t\tstd::cout << \"Animal speaks\" << std::endl;\n\t}\n};\n\nclass Cat : public Animal {\npublic:\n    //重写基类中声明的虚函数\n\tvoid speak() override {\n\t\tstd::cout << \"Meow\" << std::endl;\n\t}\n};\n\nclass Dog : public Animal {\npublic:\n    //重写基类中声明的虚函数\n\tvoid speak() override {\n\t\tstd::cout << \"Bark\" << std::endl;\n\t}\n};\n\n\nint main() {\n\tAnimal* cat = new Cat();\n\tcat->speak();   //这里的speak()来源是Cat类，而非Animal类\n\n\tAnimal* dog = new Dog();\n\tdog->speak();   //这里的speak()来源是Dog类，而非Animal类\n\n\treturn 0;\n}\n```\n\n由于`speak()`为虚函数，`cat->speak()`会调用`Cat::speak()`而非`Animal::speak()`。因为虚函数是动态绑定（运行时多态）的，其根据对象的实际类型（Cat）来决定调用哪个版本的`speak()`。\n\n## 纯虚函数\n```\nclass Animal {\npublic:\n\tvirtual void isalive() = 0; //纯虚函数\n};\n```\n在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象（“一个动物”是什么？）明显不合常理。而针对每种动物的方法又有所不同，此时需要使用多态特性，也就需要在基类中定义虚函数。\n\n纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数。\n\n定义纯虚函数是为了实现一个**接口**，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。对于动物这个基类而言，它必须是某一个种类，可以是鸟、狗、猫，但不能什么都不是。这个“种类”就可以作为纯虚函数在基类`Animal`中声明。\n\n*注意*：含有纯虚函数的类称之为**抽象类**，它不能生成对象（创建实例），只能创建它的派生类的实例。抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。\n\n抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。\n\n```\n#include <iostream>\n\nclass Animal {\npublic:\n\tvirtual void speak() {\n\t\tstd::cout << \"Animal speaks\" << std::endl;\n\t}\n\n    //一个动物要么是活的，要么是死的，子类中必须定义这个属性，因此是纯虚函数\n\tvirtual void isalive() = 0;\n};\n\nclass Cat : public Animal {\npublic:\n\tvoid speak() override {\n\t\tstd::cout << \"Meow\" << std::endl;\n\t}\n\n    //重写基类Animal中的isalive()纯虚函数\n\tvoid isalive() override {\n\t\tstd::cout << \"Cat is alive\" << std::endl;\n\t}\n};\n\nclass Dog : public Animal {\npublic:\n\tvoid speak() override {\n\t\tstd::cout << \"Bark\" << std::endl;\n\t}\n\n    //重写基类Animal中的isalive()纯虚函数\n\tvoid isalive() override {\n\t\tstd::cout << \"Dog is alive\" << std::endl;\n\t}\n};\n\n\nint main() {\n\tAnimal* cat = new Cat();\n\tcat->speak();\n\tcat->isalive();\n\n\tAnimal* dog = new Dog();\n\tdog->speak();\n\tdog->isalive();\n\n\treturn 0;\n}\n```\n\n如果这里使用`Animal* animal = new Animal()`，编译器将报错，因为`Animal`包含纯虚函数，已经是一个抽象类。","categories":["C++"]},{"title":"LVGL9.2移植至正点原子阿波罗STM32F429","url":"/2025/01/10/LVGL9.2移植至正点原子阿波罗STM32F429/","content":"*参考文献*：LVGL 移植到 STM32 通法 (https://www.cnblogs.com/Huae/p/18621614)\n工程文件：[Github](https://github.com/AkiChen891/LVGL_v9_blank)\n## 前言\nLVGL（Light and Versatile Graphics Library）是一个开源的图形库，旨在为嵌入式系统提供高效、灵活的图形用户界面（GUI）解决方案。它具有小巧的内存占用和高性能的渲染能力，支持多种硬件平台，包括单片机、DSP 和 ARM 处理器等。LVGL 支持丰富的控件（如按钮、标签、图标、滚动条等），并提供强大的主题、样式和动画功能，使得开发者能够轻松设计出美观且响应迅速的界面。此外，LVGL 还支持触摸屏、图形加速（如 DMA2D）、多线程等特性，非常适合用于嵌入式应用程序，如智能家居、工业控制、医疗设备等领域。\n\n本文将介绍一下最新的LVGL9.2在正点原子阿波罗STMF429IGT6开发板上的移植。正点原子自己的移植教程还是几年前的8.2版本，LVGL在这个版本之后对很多API进行了优化和裁剪，导致正点原子的教程现在已经不是很好用了。但是万变不离其宗，LVGL的主架构没有变，只需要一点细微的改变就可以进行移植。\n\n我使用的屏幕是正点原子7寸RGB屏，分辨率为1024 * 600.编译器为IAR EW 9.6\n\n在开始之前，确保你有：\n- 相关的外设\n- 正点原子例程提供的一系列外设驱动\n- LVGL9.2版本源码\n- **LVGL官方的文档**：[点击跳转](https://docs.lvgl.io/master/)\n\n我个人认为LVGL官方的文档非常重要，而且它甚至是有完整的官方授权的[中文版本](https://lvgl.100ask.net/master/index.html)的。大多数东西都可以在上面找到。\n\n## 准备工作\n### 拷贝外设驱动\n将所有和显示屏、触摸屏、SDRAM等有关的外设驱动加入工程。换句话说，你的工程需要做到在没有LVGL的环境下也能够通过最基本的显示函数在屏幕上显示东西的状态。如果你的工程在没有LVGL的环境下都没法通过正点原子例程里提供的函数显示东西，那显然是没有办法继续的。\n\n### 拷贝LVGL库至工程文件夹\nLVGL下载并解压之后，文件夹根目录内会包含很多文件夹及文件。在不需要demo或例程的情况下，我们只需要用到其中的这些文件/文件夹：\n- examples文件夹中的porting文件夹\n- src文件夹\n- lv_conf_template.h\n- lvgl.h\n\n在工程文件夹根目录创建一个lvgls文件夹：\n![](/images/lvgl/lvgl1.png)\n\n然后：\n1. 创建一个子文件夹，名为lvgl\n2. 创建一个子文件夹，名为lvgl_app\n3. 将之前提到的lv_conf_template.h重命名为lv_conf.h，移动到lvgls文件夹的根目录\n4. 打开examples/porting文件夹，复制lv_port_disp_template.c、lv_port_disp_template.h、lv_port_indev_template.c、lv_port_indev_template.h四个文件到lvgls文件夹根目录，并且重命名四个文件，去掉\"_template\"。这是后面要用到的显示屏和触摸屏注册文件\n5. 把src文件夹和lvgl.h复制到lvgls/lvgl文件夹中\n\n现在的lvgls文件夹是这样的：\n![](/images/lvgl/lvgl2.png)\nlvgl文件夹：\n![](/images/lvgl/lvgl3.png)\n\n### 添加LVGL库文件至工程\n将以下文件全部添加进入工程（可以一股脑全部加，也可以按照原本的文件结构自己慢慢加）：\n- src文件夹中的所有c文件，**除了**：\n    - draw中的nxp、renesas、sdl\n    - drivers文件夹\n- lv_port_disp.c和lv_port_indev.c\n\n（千万别忘了src文件夹根目录下还有个lv_init.c）\n\n然后，添加头文件目录，到src为止就可以.\n\n我的添加完之后的工程结构长这个样子：\n![](/images/lvgl/lvgl4.png)\n\n### 修改Stack和Heap大小\nLVGL需要至少2KB的Stack和Heap。\n![](/images/lvgl/lvgl5.png)\n\n## 代码修改\n### 定时器\nLVGL需要一个tick源来为其提供心跳，这里使用基本定时器TIM6完成，PSC为10-1，ARR为6000-1.在tim.c中添加如下的回调函数：\n```\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n{\n  if (htim == &htim6)\n  {\n    lv_tick_inc(1);   /* LVGL systick */\n  }\n}\n```\n别忘了在定时器初始化时打开TIM6的Time base，让定时器开始工作。\n### lv_conf.h\n启用宏：`#if 1 /*Set it to \"1\" to enable content*/`\n检查以下关键信息：\n- `/*Color depth: 1 (I1), 8 (L8), 16 (RGB565), 24 (RGB888), 32 (XRGB8888)*/#define LV_COLOR_DEPTH 16`：颜色深度，默认为RGB565\n- `#define LV_MEM_SIZE (64U * 1024U)          /*[bytes]*/`缓冲区大小\n，默认64KB\n\n其他的东西理论上你看不懂也没关系，可以暂时不动，日后可以对照着注释慢慢研究。\n\n### lv_port_disp.c\n- 设置屏幕分辨率：\n```\n#ifndef MY_DISP_HOR_RES\n    #warning Please define or replace the macro MY_DISP_HOR_RES with the actual screen width, default value 320 is used for now.\n    #define MY_DISP_HOR_RES    1024\n#endif\n\n#ifndef MY_DISP_VER_RES\n    #warning Please define or replace the macro MY_DISP_VER_RES with the actual screen height, default value 240 is used for now.\n    #define MY_DISP_VER_RES    600\n#endif\n```\n注意，这里必须根据自己使用的屏幕分辨率来设置！如果尺寸设置的比实际屏幕小会导致实际的图像占不满整个屏幕，如果设置的比实际大会导致花屏、撕裂或干脆无法显示\n\n- 设置缓冲区\n```\n\nvoid lv_port_disp_init(void)\n{\n    /*-------------------------\n     * Initialize your display\n     * -----------------------*/\n    disp_init();\n\n    /*------------------------------------\n     * Create a display and set a flush_cb\n     * -----------------------------------*/\n    lv_display_t * disp = lv_display_create(MY_DISP_HOR_RES, MY_DISP_VER_RES);\n    lv_display_set_flush_cb(disp, disp_flush);\n\n    /* Example 1\n     * One buffer for partial rendering*/\n    LV_ATTRIBUTE_MEM_ALIGN\n    static uint8_t buf_1_1[MY_DISP_HOR_RES * 10 * BYTE_PER_PIXEL];            /*A buffer for 10 rows*/\n    lv_display_set_buffers(disp, buf_1_1, NULL, sizeof(buf_1_1), LV_DISPLAY_RENDER_MODE_PARTIAL);\n\n    // /* Example 2\n    //  * Two buffers for partial rendering\n    //  * In flush_cb DMA or similar hardware should be used to update the display in the background.*/\n    // LV_ATTRIBUTE_MEM_ALIGN\n    // static uint8_t buf_2_1[MY_DISP_HOR_RES * 10 * BYTE_PER_PIXEL];\n\n    // LV_ATTRIBUTE_MEM_ALIGN\n    // static uint8_t buf_2_2[MY_DISP_HOR_RES * 10 * BYTE_PER_PIXEL];\n    // lv_display_set_buffers(disp, buf_2_1, buf_2_2, sizeof(buf_2_1), LV_DISPLAY_RENDER_MODE_PARTIAL);\n\n    // /* Example 3\n    //  * Two buffers screen sized buffer for double buffering.\n    //  * Both LV_DISPLAY_RENDER_MODE_DIRECT and LV_DISPLAY_RENDER_MODE_FULL works, see their comments*/\n    // LV_ATTRIBUTE_MEM_ALIGN\n    // static uint8_t buf_3_1[MY_DISP_HOR_RES * MY_DISP_VER_RES * BYTE_PER_PIXEL];\n\n    // LV_ATTRIBUTE_MEM_ALIGN\n    // static uint8_t buf_3_2[MY_DISP_HOR_RES * MY_DISP_VER_RES * BYTE_PER_PIXEL];\n    // lv_display_set_buffers(disp, buf_3_1, buf_3_2, sizeof(buf_3_1), LV_DISPLAY_RENDER_MODE_DIRECT);\n\n}\n```\n我这里设置的是单缓冲区，实际按照自己需求来就可以。如果不是干那些高刷新率的活，单缓冲足够用了。原例程提供了三个缓冲区方式，分别是单缓冲、双缓冲和全尺寸双缓冲，选择合适的一个之后注释掉其他的几个就可以。\n\n- 显示设备初始化\n```\n/*Initialize your display and the required peripherals.*/\nstatic void disp_init(void)\n{\n    /*You code here*/\n    lcd_init();\n    lcd_display_dir(1);\n}\n```\n在这里添加屏幕的初始化函数。\n\n- 设置刷屏\n```\n/*Flush the content of the internal buffer the specific area on the display.\n *`px_map` contains the rendered image as raw pixel map and it should be copied to `area` on the display.\n *You can use DMA or any hardware acceleration to do this operation in the background but\n *'lv_display_flush_ready()' has to be called when it's finished.*/\nstatic void disp_flush(lv_display_t * disp_drv, const lv_area_t * area, uint8_t * px_map)\n{\n    if(1) {\n        /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/\n        lcd_color_fill(area->x1, area->y1, area->x2, area->y2, (uint16_t *)px_map);\n\n    }\n    /*IMPORTANT!!!\n     *Inform the graphics library that you are ready with the flushing*/\n    lv_display_flush_ready(disp_drv);\n}\n```\n用正点原子例程中的lcd_color_fill()函数替代原来默认的画点函数。\n\n### lv_port_indev.c\n- 修改初始化函数，添加触摸屏的初始化函数\n```\nstatic void touchpad_init(void)\n{\n    /*Your code comes here*/\n    tp_dev.init();\n}\n```\n- 修改触摸屏按下的识别动作\n```\n/*Return true is the touchpad is pressed*/\nstatic bool touchpad_is_pressed(void)\n{\n    /*Your code comes here*/\n    tp_dev.scan(0);\n    if (tp_dev.sta & TP_PRES_DOWN) {\n        return true;\n    }\n    return false;\n}\n```\n- 修改坐标读取函数\n```\n/*Get the x and y coordinates if the touchpad is pressed*/\nstatic void touchpad_get_xy(int32_t * x, int32_t * y)\n{\n    /*Your code comes here*/\n\n    (*x) = tp_dev.x[0];\n    (*y) = tp_dev.y[0];\n}\n```\n### main.c\n初始化一系列外设，对于lvgl相关的头文件则要按顺序初始化：\n```\n  lv_init();\n  lv_port_disp_init();\n  lv_port_indev_init();\n```\n在while(1)主循环中添加time_handler\n```\n  while (1)\n  {\n    /* USER CODE END WHILE */\n\n    /* USER CODE BEGIN 3 */\n    lv_timer_handler();\n    delay_ms(5);\n  }\n```\n\n到这里为止，可以加一点自己的测试代码，然后编译烧录，LVGL就能正常显示了。\n\n![](/images/lvgl/lvgl6.png)\n\n如果碰到问题欢迎站内私信。","categories":["嵌入式（裸机开发）"]},{"title":"数组中的解题技巧","url":"/2025/01/02/数组中的解题技巧/","content":"## 双指针\n双指针能够将$O(n^2)$复杂度的算法降低为$O(n)$，并且常见于原地算法。两个指针能够在一个for循环内完成两个for循环的工作。\n\n### 同向指针\n[283.移动零](https://leetcode.cn/problems/move-zeroes)\n\n```\nvoid moveZeroes(int* nums, int numsSize) {\n    int slow = 0;\n\n    for (int i = 0; i < numsSize; i++)\n    {\n        if (nums[i] != 0)       //不要判断nums[i] == 0，否则会很麻烦\n        {\n            nums[slow] = nums[i];\n            slow++;\n        }\n    }\n\n    for (int i = slow; i < numsSize; i++)\n    {\n        nums[i] = 0;\n    }\n}\n```\n在这里，slow作为慢指针，用于指示去掉0之后的“新元素”，而循环中的`i`作为快指针，负责处理遍历。快指针走的比慢指针快，因此慢指针对元素做的原地处理不会和后面的快指针操作发生冲突。\n\n[27.移除元素](https://leetcode.cn/problems/remove-element)\n```\nint removeElement(int* nums, int numsSize, int val) {\n    //int fast = 0;\n    int slow = 0;\n\n    for (int i = 0; i < numsSize; i++)\n    {\n        if (nums[i] != val)\n        {\n            nums[slow] = nums[i];\n            slow++; \n        }\n    }\n\n    return slow;\n}\n```\n思路和上一题相同。主要判断条件都是“不等于”，因为slow要指向的对象是待储存元素（slow要重新在数组内为这些元素分配位置），而不是等于`val`的元素。\n\n[26.删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array)\n\n```\nint removeDuplicates(int* nums, int numsSize) {\n    int current_pos = 1;\n    for (int i = 1; i < numsSize; i++)\n    {\n        if(nums[i] != nums[i-1])    \n        {\n            nums[current_pos] = nums[i];    \n            current_pos++;\n        }\n    }\n\n    return current_pos;\n}\n```\n思路也是一致的，判断出当前元素是否和前一个不一致，如果不一致说明这个元素要保留，slow就会指向这个元素。\n\n[349.两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)\n这题的分为两个部分：排序+双指针。双指针法只需要一次循环，前提是数组必须经过排序。排序完后的数组是升序的，两个数组分别使用两个指针从首位开始向后遍历并比较。以这两个数组为例：\n```\n[4,9,5]\n[9,4,9,8,4]\n```\n排序之后的结果为\n```\n[4,5,9]\n[4,4,8,9,9]\n```\n两个指针分别开始遍历，如果指针1指向值大于指针2指向值，说明指针2位置偏左，对其++；如果指针1指向值小于指针2指向值，则说明指针1偏左，对其++；如果指针1和指针2指向值大小相等，该值属于交集，提出并保存在result中。\n\n这个做法会带来重复存入的问题，比如上面的算例中，result会先后存入两个4。为了避免该情况发生，在存入时需要做过滤，条件为result中待存入位置的前一个数不能等于当前要存入的这个数（`result[k-1] != nums1[i]`。如果待存入位置是result的第一位，则不用判断，直接存入`k == 0`。因为两个数组事先已经排过序，所以这个判断逻辑一定是正确的，不存在漏判断的问题。\n```\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint compare(const void *a, const void *b){\n    return *(int *)a - *(int *)b;\n}\n\nint* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {\n    qsort(nums1, nums1Size, sizeof(int), compare);\n    qsort(nums2, nums2Size, sizeof(int), compare);\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int* result = malloc(sizeof(int) * (nums1Size < nums2Size ? nums1Size : nums2Size));\n\n    while (i < nums1Size && j < nums2Size){\n        if (nums1[i] > nums2[j]){\n            j++;\n        }\n        else if (nums1[i] < nums2[j]){\n            i++;\n        }\n        else if (nums1[i] == nums2[j]){\n            if (k == 0 || result[k - 1] != nums1[i]){\n                result[k++] = nums1[i];\n            }\n            i++;\n            j++;\n        }\n    }\n\n    *returnSize = k;\n    return result;\n}\n```\n\n\n\n## 排序\n### 冒泡排序\n```\nvoid bubble_sort(int* nums, int numsSize)\n{\n    for (int i = 0; i < numsSize - 1; i++)\n    {\n        for (int j = 0; j < numsSize - 1 - i; j++)\n        {\n            if (nums[j] > nums[j + 1])\n            {\n                int temp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = temp;\n            }\n        }\n    }\n}\n```\n\n### 快速排序\n```\n\n```\n\n## 其他\n### Boyer-Moore 投票算法（众数问题）\nBoyer-Moore 投票算法是一种用于寻找**众数（Majority Element）**的高效算法。众数定义为一个数组中出现次数超过总长度一半的元素。该算法的时间复杂度为 O(n)，空间复杂度为 O(1)，非常高效。核心思想是利用计数器（count）维护当前候选元素的“优势”，如果某个元素在整个数组中出现次数超过一半，算法最终能锁定这个元素。\n\n步骤为： \n\n1. **候选阶段**：\n   - 从数组的第一个元素开始，假设它是众数候选人（`candidate`）。\n   - 遍历数组，如果当前元素与候选人相同，增加计数器（`count++`）；如果不同，减少计数器（`count--`）。\n   - 当计数器为零时，重新选择下一个元素作为新的候选人。\n\n2. **确认阶段**（可选，视问题需求而定）：\n   - 如果题目明确保证数组中一定有众数，则跳过此步骤，候选人即为众数。\n   - 如果不保证众数存在，需要再遍历一次数组，验证候选人的出现次数是否超过数组的一半。\n\n[169.多数元素](https://leetcode.cn/problems/majority-element)\n```\nint majorityElement(int* nums, int numsSize) {\n    int count = 0;      /* 计数器 */\n    int candidate = 0;  /* 候选人 */\n\n    for (int i = 0; i < numsSize; i++){\n        if (count == 0){        /* 如果计数器为0，选中当前元素为候选人 */\n            candidate = nums[i];\n            count = 1;\n        }else if (nums[i] == candidate){    /* 如果当前元素为候选人 */\n            count++;\n        }else{\n            count--;\n        }\n    }\n\n    return candidate;\n}\n```\n\n","categories":["数据结构"]},{"title":"FLASH、EEPROM和FLASH模拟EEPROM","url":"/2025/01/02/FLASH、EEPROM和FLASH模拟EEPROM/","content":"## FLASH和EEPROM\n**FLASH存储器**和**EEPROM**（电可擦可编程只读存储器）都属于**非易失性存储器**，但它们在工作原理、使用方式、应用场景等方面有一些区别。\n\n### **FLASH存储器**\n**FLASH**（闪存）是一种非易失性存储器，能够在没有电源的情况下保存数据。它的工作原理类似于EEPROM，但在数据擦除和写入的方式上有所不同。\n\n#### 特点：\n1. **大容量**：FLASH存储器一般提供比EEPROM更大的存储容量，通常从几兆字节（MB）到几百兆字节（甚至几个GB）。\n2. **块擦除**：FLASH存储器以**块**（通常为几KB到几MB）为单位进行擦除，擦除操作需要清空整个块，而不能像EEPROM那样按字节擦除。这使得FLASH的擦写次数比EEPROM更低，一般在10,000到100,000次之间。\n3. **写入速度较快**：相比EEPROM，FLASH的写入速度更快，适用于需要快速写入的应用场景。\n4. **应用广泛**：FLASH主要用于存储大容量数据，广泛应用于固态硬盘（SSD）、U盘、存储卡、智能手机、嵌入式设备等。\n5. **编程和擦除**：FLASH可以通过电气方式编程和擦除，但擦除和编程过程比EEPROM要复杂得多，且无法像EEPROM那样轻松按字节更新数据。\n\n#### 类型：\n- **NAND Flash**：主要用于大容量存储，速度快，成本低，广泛用于移动存储设备（如U盘、SD卡、SSD等）。\n- **NOR Flash**：速度较慢但可按字节进行读写，主要用于代码存储，适合嵌入式系统。\n\n### **EEPROM vs FLASH**\n| 特性               | **EEPROM**                        | **FLASH**                           |\n|--------------------|-----------------------------------|-------------------------------------|\n| **存储容量**       | 较小，一般为几KB到几MB             | 较大，可以达到几GB                  |\n| **数据擦除方式**   | 按字节擦除                         | 按块擦除（大块范围，一般几KB至几MB）|\n| **写入速度**       | 较慢，尤其在单个字节写入时         | 较快，适合大块数据写入             |\n| **擦写次数**       | 较多，通常达到100,000次以上        | 较少，通常为10,000到100,000次      |\n| **应用场景**       | 存储配置参数、序列号、校准数据等  | 存储操作系统、应用程序、数据文件等 |\n| **价格**           | 较贵，尤其在小容量时               | 相对便宜，适用于大容量存储         |\n\n- **EEPROM**通常用于存储少量的数据，比如设备配置、用户设置等，需要频繁的、字节级的读写操作。它的主要优点是可以单独字节擦写，但容量较小，写入速度较慢。\n- **FLASH**则适用于大容量的存储需求，广泛用于存储操作系统、应用程序、媒体文件等。由于其按块擦除的特性，写入速度较快，但擦写次数较少，适合大数据量的存储。\n\n对于嵌入式系统来说，**EEPROM**适用于需要频繁更新的小量数据，而**FLASH**则适合存储较大的程序或数据集。\n\n## STM32F429中的FLASH\n### 组织架构\n![MCU自带FLASH组织](/images/arm/flash1.png)\nSTM32F429 本身没有自带 EEPROM，但是 STM32F429 具有 IAP（在应用编程）功能，所以我们可以把它的 FLASH 当成 EEPROM 来使用。对于F429IGT6来说，其FLASH容量为1024KB。FLASH模块分为：\n- 主存储器：该部分用来存放代码和数据常数（如 const 类型的数据）。分为两个 Bank，每个 Bank 分为 12 个扇区，前 4 个扇区为 16KB 大小，第五个扇区是 64KB 大小，剩下的 7 个扇区都是 128K大小，总共 1M 字节。两个 Bank 就是 2M 字节。不同容量的 STM32F429，拥有的扇区数不一样。以STM32F429IGT6为例，只有 Bank1，拥有 12 个扇区，1M 字节容量。主存储器的起始地址一般为 0X08000000，B0、B1 都接 GND 的时候，就是从0X08000000 开始运行代码的。\n- 系统存储器：主要用来存放 STM32F429的 bootloader代码，此代码在出厂时已经固化在 STM32F429 内，专门用来给主存储器下载代码。当 B0 接 V3.3，B1 接 GND 的时候，从该存储器启动（即进入串口下载模式）。\n- OTP区域（一次性可编程区域）：共 528 字节，被分成两个部分，前面 512字节（32 字节为1块，分成16块），可以用来存储一些用户数据（一次性，写完一次，永远不可以擦除），后面 16 字节，用于锁定对应块。\n- 选项字节：用于配置读保护、BOR 级别、软件/硬件看门狗以及器件处于待机或停止模式下的复位。\n\n在执行闪存写操作时，任何对闪存的读操作都会锁住总线，在写操作完成后读操作才能正\n确地进行；即在进行写或擦除操作时，不能进行代码或数据的读取操作。\n\n### 读取\n为了准确读取 Flash 数据，必须根据 CPU 时钟 (HCLK) 频率和器件电源电压在 Flash 存取控制寄存器 (FLASH_ACR) 中正确地设置等待周期数 (LATENCY)。当电源电压低于 2.1V 时，必须关闭预取缓冲器。\n\n![ACLK时钟频率和对应的FLASH等待周期](/images/arm/flash2.png)\n\n等待周期通过FLASH_ACR寄存器的LATENCY[2:0]三个位设置。\n\nSTM32读取FLASH很简单，例如要从地址addr读取一个字（32位），只需要一句话：\n\n```\nData = *(volatile uint32_t *)faddr;\n```\n\n将 faddr 强制转换为 `volatile uint32_t` 指针，然后取该指针所指向的地址的值，即得到了 faddr 地址的值。类似的，将上面的 `volatile uint32_t` 改为 `volatile uint8_t`，即可读取指定地址的一个字节。此处的 `volatile` 关键字告诉编译器该地址的内容可能随时改变，因此禁止编译器对该地址做任何优化。通常用于表示硬件寄存器或外设的内存地址，因为这些内容的值可能由外部事件（如外部硬件）改变。\n\n### 编程和擦除\n执行任何 Flash编程操作（擦除或编程）时，CPU时钟频率（HCLK）不能低于 1MHz。在对 STM32F429 的 Flash 执行写入或擦除操作期间，任何读取 Flash 的尝试都会导致总线阻塞。只有在完成编程操作后，才能正确处理读操作。这意味着，写/擦除操作进行期间不能从 Flash 中执行代码或数据获取操作。\n\nSTM32F429 用户闪存的编程一般由 6 个 32 位寄存器控制，他们分别是：\n- FLASH 访问控制寄存器(FLASH_ACR)\n- FLASH 秘钥寄存器(FLASH_KEYR)\n- FLASH 选项秘钥寄存器(FLASH_OPTKEYR)\n- FLASH 状态寄存器(FLASH_SR)\n- FLASH 控制寄存器(FLASH_CR)\n- FLASH 选项控制寄存器(FLASH_OPTCR)\n\nSTM32F429复位后，FLASH 编程操作是被保护的，不能写入 FLASH_CR寄存器；通过写入特定的序列（`0X45670123` 和 `0XCDEF89AB`）到 FLASH_KEYR 寄存器才可解除写保护，只有在写保护被解除后，我们才能操作相关寄存器。\n\nFLASH_CR 的解锁序列为：\n1. 写 `0X45670123` 到 FLASH_KEYR\n2. 写 `0XCDEF89AB` 到 FLASH_KEYR\n\n通过这两个步骤，即可解锁 FLASH_CR，如果写入错误，那么 FLASH_CR 将被锁定，直到下次复位后才可以再次解锁。\n\nSTM32F429 闪存的编程位数可以通过 FLASH_CR 的 PSIZE 字段配置，PSIZE 的设置必须\n和电源电压匹配：\n![编程/擦除并行位数与电压关系](/images/arm/flash3.png)\n\n当开发板电压为3.3V时，`PSIZE`为`10`，并行位数32位。也就是擦除或编程都需要以32位为基础进行。\n\nFLASH在编程时必须要求目标写入地址的FLASH已经被擦除（值为`0xFFFFFFFF`），否则将无法写入。\n\nF429的FLASH标准编程步骤如下：\n1. 检查FLASH_CR中的BSY位，确保总线空闲\n2. 将FLASH_CR寄存器的PG位置1，激活FLASH编程\n3. 针对所需存储地址（主存储器块或 OTP 区域内）执行数据写入操作：\n    - 并行位数为x32时按字写入（PSIZE=02）\n4. 等待BSY位清零\n\n*注意*：\n    - 编程前确保写入地址已经擦除\n    - 先解锁FLASH_CR后编程\n\n扇区擦除步骤如下：\n1. 检查FLASH_CR的LOOK是否解锁，如果没有则先解锁\n2. 检查FLASH_CR中的BSY位，确保总线空闲\n3. FLASH_CR的SER位置1，并从主存储块的12个扇区中选择要擦除的扇区（SNB）\n4. FLASH_CR寄存器中STRT位置1，触发擦除\n5. 等待BSY位清零\n\n### 寄存器\n#### FLASH_ACR - Flash访问控制寄存器\n![FLASH_ACR](/images/arm/flash4.png)\n重点为LATENCY[2:0]位，应根据MCU电压和频率设置，否则死机。\n\n#### FLASH_KEYR - Flash密钥寄存器\n![FLASH_KEYR](/images/arm/flash5.png)\n用于解锁FLASH_CR，必须按顺序写入KEY1和KEY2\n\n#### FLASH_CR - Flash控制寄存器\n![FLASH_CR](/images/arm/flash6.png)\n- LOCK位：用于指示 FLASH_CR 寄存器是否被锁住，该位在检测到正确的解锁序列后，硬件将其清零。在一次不成功的解锁操作后，在下次系统复位之前，该位将不再改变。\n- PG位：用于选择编程操作，在往 FLASH 写数据的时候，该位需要置 1。\n- SER位：位用于选择扇区擦除操作，在扇区擦除的时候，需要将该位置 1。\n- PSIZE[1:0]位：设置编程宽度，一般设置 PSIZE =2 即可（32 位）。\n- STRT位：该位用于开始一次擦除操作。在该位写入 1 ，将执行一次擦除操作。\n- SNB[3:0]位：用于选择要擦除的扇区编号，取值范围为 0~15。\n\n#### FLASH_SR - Flash状态寄存器\n![FLASH_SR](/images/arm/flash7.png)\n- BSY位：确认BANK是否正在执行编程操作\n\n## 代码\n### 读取\n```\n /**\n * @brief       从指定地址读取一个字（32位）\n * @param       faddr   : 读取地址\n * @retval      读取到的数据（32位）\n */\nuint32_t stmflash_read_word(uint32_t faddr)\n{\n    return *(volatile uint32_t *)faddr;\n}\n\n/**\n* @brief 从指定地址开始读出指定长度的数据\n* @param raddr : 起始地址\n* @param pbuf : 数据指针\n* @param length: 要读取的字(32)数,即 4 个字节的整数倍\n* @retval 无\n*/\nvoid stmflash_read(uint32_t raddr, uint32_t *pbuf, uint32_t length)\n{\n    uint32_t i;\n\n    for (i = 0; i < length; i++)\n    {\n        pbuf[i] = stmflash_read_word(raddr);\n        raddr += 4;\n    }\n}\n```\n### 写入\n写入相对来说复杂一点，首先要判断写入地址是否正确（不能超出FLASH地址范围，不能不是4的倍数），判断通过后，解锁FLASH，禁用数据缓存，然后判断待写入地址范围是否为`0xFFFFFFFF`。如果是，表明该地址已经被擦除；如果不是，表明该地址需要先擦除，再写入。\n```\nvoid stmflash_write(uint32_t waddr, uint32_t *pbuf, uint32_t length)\n{\n    FLASH_EraseInitTypeDef flash_erase_init;\n    HAL_StatusTypeDef flashstatus = HAL_OK;\n    uint32_t sector_error = 0;\n    uint32_t addrx = 0;\n    uint32_t endaddr = 0;\n\n    if (waddr < STM32_FLASH_BASE || waddr % 4 || waddr > (STM32_FLASH_BASE + STM32_FLASH_SIZE)) return;     /* 地址非法 */\n\n    HAL_FLASH_Unlock();\n\n    FLASH->ACR &= ~(1 << 10);       /* 禁用数据缓存 */\n    addrx = waddr;                  /* 写入起始地址*/\n    endaddr = waddr + length * 4;   /* 写入结束地址 */\n\n    if (addrx < 0x1FFF0000)  /* 主存储区*/\n        while (addrx < endaddr)\n        {\n            if (stmflash_read_word(addrx) != 0xFFFFFFFF)        /* 当前地址不为0xFFFFFFFF则表示需要擦除此地址 */\n            {\n                flash_erase_init.TypeErase = FLASH_TYPEERASE_SECTORS;\n                flash_erase_init.Sector = stmflash_get_flash_sector(addrx);\n                flash_erase_init.NbSectors = 1;\n                flash_erase_init.VoltageRange = FLASH_VOLTAGE_RANGE_3;\n\n                if (HAL_FLASHEx_Erase(&flash_erase_init, &sector_error) != HAL_OK) break;\n            }\n            else\n            {\n                addrx += 4;\n            }\n            FLASH_WaitForLastOperation(FLASH_WAITETIME);\n        }\n    flashstatus = FLASH_WaitForLastOperation(FLASH_WAITETIME);\n    if (flashstatus == HAL_OK)\n    {\n        while (waddr < endaddr)\n        {\n            if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, waddr, *pbuf) != HAL_OK) break;\n            waddr += 4;\n            pbuf++;\n        }\n    }\n    FLASH->ACR |= 1 << 10;     /* 启用数据缓存 */\n\n    HAL_FLASH_Lock();\n}\n```\n\n这里有几个需要注意的点：\n1. 擦除和写入期间必须禁用数据缓存，否则缓存器中的缓存内容和新的内容可以不一致导致bug。禁用数据缓存通过位操作`FLASH->ACR &= ~(1 << 10)`实现，`1 << 10`表示`1`左移10位，`~`表示取反。\n2. 擦除操作通过`HAL_FLASHEx_Erase()`实现，HAL库对于该函数的定义为：\n```\n/**\n  * @brief  Perform a mass erase or erase the specified FLASH memory sectors\n  * @param[in]  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that\n  *         contains the configuration information for the erasing.\n  *\n  * @param[out]  SectorError pointer to variable  that\n  *         contains the configuration information on faulty sector in case of error\n  *         (0xFFFFFFFFU means that all the sectors have been correctly erased)\n  *\n  * @retval HAL Status\n  */\nHAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)\n```\n形参1为存储擦除配置的结构体，形参2为存储报错信息的变量。\n结构体格式为：\n```\n/**\n  * @brief  FLASH Erase structure definition\n  */\ntypedef struct\n{\n  uint32_t TypeErase;   /*!< Mass erase or sector Erase.\n                             This parameter can be a value of @ref FLASHEx_Type_Erase */\n\n  uint32_t Banks;       /*!< Select banks to erase when Mass erase is enabled.\n                             This parameter must be a value of @ref FLASHEx_Banks */\n\n  uint32_t Sector;      /*!< Initial FLASH sector to erase when Mass erase is disabled\n                             This parameter must be a value of @ref FLASHEx_Sectors */\n\n  uint32_t NbSectors;   /*!< Number of sectors to be erased.\n                             This parameter must be a value between 1 and (max number of sectors - value of Initial sector)*/\n\n  uint32_t VoltageRange;/*!< The device voltage range which defines the erase parallelism\n                             This parameter must be a value of @ref FLASHEx_Voltage_Range */\n\n} FLASH_EraseInitTypeDef;\n```\n3. 全部擦除完成并等待`FLASH_WaitForLastOperation(FLASH_WAITETIME)`传回`HAL_OK`后，才可以开始进行。写入函数为`HAL_FLASH_Program`：\n```\n/**\n  * @brief  Program byte, halfword, word or double word at a specified address\n  * @param  TypeProgram  Indicate the way to program at a specified address.\n  *                           This parameter can be a value of @ref FLASH_Type_Program\n  * @param  Address  specifies the address to be programmed.\n  * @param  Data specifies the data to be programmed\n  *\n  * @retval HAL_StatusTypeDef HAL Status\n  */\nHAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)\n```\n形参1用于指定写入的是字节（8位）、半个字（16位）、字（32位）或双字（64位）；形参2为写入地址，形参3为待写入数据。连续写入时，形参3一般设置为指针，每次循环对相应地址+1处理。\n4. 写入完成后，启用数据缓存，FLASH上锁。\n","categories":["嵌入式（裸机开发）"]},{"title":"CAN及其应用","url":"/2024/12/28/CAN及其应用/","content":"## 简介\n\nCAN 总线由德国BOSCH公司开发，是一种多主控消息广播系统，其最大信号传输速率为1Mbps。与USB或以太网等传统网络不同，CAN 不会在中央总线主控的监督下从节点A向节点B点对点发送大量数据包。在CAN网络中，许多短消息（如温度或发动机转速）会广播到整个网络，从而确保系统每个节点的数据一致性。CAN 是国际标准化组织 (ISO) 定义的串行通信总线，最初是为汽车行业开发的，旨在用双线总线取代复杂的线束。该规范要求具有较高的抗电气干扰能力以及自我诊断和修复数据错误的能力。这些特性使得 CAN 在楼宇自动化、医疗和制造业等各种行业中广受欢迎。\n\nCAN具有以下特点：\n- **多主控制**。在总线空闲时，所有单元都可以发送消息（多主控制），而两个以上的单元同时开始发送消息时，根据标识符（Identifier以下称为ID）决定优先级。ID并不是表示发送的目的地址，而是表示访问总线的消息的优先级。两个以上的单元同时开始发送消息时，对各消息ID的每个位进行逐个仲裁比较。仲裁获胜（被判定为优先级最高）的单元可继续发送消息，仲裁失利的单元则立刻停止发送而进行接收工作。\n\n- **系统的柔软性**。与总线相连的单元没有类似于“地址”的信息。因此在总线上增加单元时，连接在总线上的其它单元的软硬件及应用层都不需要改变。\n\n- **通信速度较快，通信距离远**。最高1Mbps（距离小于40M），最远可达10KM（速率低于5Kbps）。\n\n- **具有错误检测、错误通知和错误恢复功能**。所有单元都可以检测错误（错误检测功能），检测出错误的单元会立即同时通知其他所有单元（错误通知功能），正在发送消息的单元一旦检测出错误，会强制结束当前的发送。强制结束发送的单元会不断反复地重新发送此消息直到成功发送为止（错误恢复功能）。\n\n- **故障封闭功能**。CAN可以判断出错误的类型是总线上暂时的数据错误（如外部噪声等）还是持续的数据错误（如单元内部故障、驱动器故障、断线等）。由此功能，当总线上发生持续数据错误时，可将引起此故障的单元从总线上隔离出去。\n\n- **连接节点多**。CAN总线是可同时连接多个单元的总线。可连接的单元总数理论上是没有限制的。但实际上可连接的单元数受总线上的时间延迟及电气负载的限制。降低通信速度，可连接的单元数增加；提高通信速度，则可连接的单元数减少。\n\nCAN 协议经过 ISO 标准化后有两个标准：ISO11898 标准（高速 CAN）和 ISO11519-2 标准（低速 CAN）。其中 ISO11898 是针对通信速率为 125Kbps~1Mbps 的高速通信标准，而ISO11519-2 是针对通信速率为 125Kbps 以下的低速通信标准。\n\n下文默认介绍ISO11898-2标准下的CAN，也就是高速CAN。\n\n## 物理层\n![高速CAN总线](/images/arm/CAN1.png)\n高速CAN总线呈现闭环结构，总共由两根线（CAN_High和CAN_Low）组成，总线两端各串联120Ω电阻，用于阻抗匹配。每个挂载节点拥有独立的CAN控制器（通常集成于MCU内）和CAN收发器（通常为外部IC）。\n\n![高速CAN物理层特性](/images/arm/CAN2.png)\n\n与RS485类似，CAN通过差分信号传输数据，以降低共模噪声的干扰，通过CAN总线上两根线之间的电位差来判断总线电平。总线电平分为显性（Dominant）电平和隐性（Recessive）电平。当总线上任何设备传输显性 (0) 时，高速 CAN 信号会将 CANH 线驱动至 3.5 V，将 CANL 线驱动至 1.5 V；而如果没有设备传输显性，则终端电阻会将两条线被动地返回到隐性 (1) 状态，标称差分电压为 0 V。（接收器将任何小于 0.5 V 的差分电压视为隐性。）显性差分电压的标称值为 2 V。显性共模电压 (CANH+CANL)/2 必须在共模的 1.5 至 3.5 V 范围内，而隐性共模电压必须在共模的 ±12V 范围内。\n\n也就是说，下文中：\n- 显性电平：逻辑 0\n- 隐性电平：逻辑 1\n\n可见，显性电平的“显性”具有“优先”的意味，即总线上只要有一个单元输出显性电平，总线上即为显性电平。而隐性电平的“隐性”具有“包容”的意味，只有所有的单元都输出隐性电平，总线上才为隐性电平。\n\n## 协议\nCAN协议通过5种类型的帧进行：\n- 数据帧：用于发送单元向接收单元传送数据\n- 遥控帧：用于接收单元向具有相同ID的发送单元请求数据\n- 错误帧：用于当检测出错误时向其它单元通知错误\n- 过载帧：用于接收单元通知其尚未做好接收准备\n- 间隔帧：用于将数据帧及遥控帧与前面的帧分离开来\n\n数据帧和遥控帧还分为标准格式和扩展格式两种，标准格式的标识符（Identifier）为11位，扩展格式为29位。\n\n### 标准格式下的数据帧\n![高速CAN标准格式位标识](/images/arm/CAN3.png)\n![高速CAN标准格式位标识](/images/arm/CAN4.png)\n*注意*：下方D表示显性电平（逻辑0），R表示隐性电平（逻辑1），D/R表示逻辑电平视配置而定。\n\n数据帧由7个段构成，分别为：\n- 帧起始\n- 仲裁段：表示该帧优先级\n- 控制段：表示数据字节数和保留位\n- 数据段：数据内容，一帧一般可发送0-8个字节\n- CRC段：校验帧传输正确性\n- ACK段：确认是否正常接收\n- 帧结束\n\n#### 帧起始（1位）\n- SOF：1位，显性电平，帧起始（Start of Frame），单个显性帧起始 (SOF) 位标记消息的开始，用于在空闲后同步总线上的节点。\n\n#### 仲裁段（11位）\n- Identifier：11位（扩展下为29位），即标识符，又名仲裁段，标准CAN模式下为 11 位，用于确定消息的优先级。二进制值越低，优先级越高。\n\n*注意：无论是标准格式还是扩展格式，都禁止ID的高7位都为隐性，即禁止设定ID为1111111XXXX。*\n\n- RTR：1位，用于标识是否为远程帧（0：数据帧；1：远程帧）\n\n#### 控制段（6位）\n- IDE：1位，标识符选择位（0：使用标准ID；1：使用扩展ID）\n- r0：1位，显性电平，保留位（可能用于未来的标准修订）\n- DLC：4位，标识当前正在传输的数据的字节数，高位在前\n\n*注意*：对于DLC位，通常只允许传输0-8，但接收方对DLC=9~15的情况并不视作错误\n\n| 数据字节数 | DLC3 | DLC2 | DLC1 | DLC0 |\n|------------|------|------|------|------|\n| 0          | D    | D    | D    | D    |\n| 1          | D    | D    | D    | R    |\n| 2          | D    | D    | R    | D    |\n| 3          | D    | D    | R    | R    |\n| 4          | D    | R    | D    | D    |\n| 5          | D    | R    | D    | R    |\n| 6          | D    | R    | R    | D    |\n| 7          | D    | R    | R    | R    |\n| 8          | R    | D    | D    | D    |\n\n表中D和R实际上就是0和1.比如8个字节所对应的RDDD实际上就是二进制的1000.\n\n#### 数据段（0-64位）\n数据段最多传输8字节数据，从最高位（MSB）开始输出。\n\n#### CRC段（16位）\n- CRC顺序：15位，循环冗余校验上一个传输的数据\n- CRC界定符：1位，隐性电平，用于分割\n\n*CRC 顺序是根据多项式生成的 CRC 值，CRC 的计算范围包括帧起始、仲裁段、控制段、数据段。接收方以同样的算法计算 CRC 值并进行比较，不一致时会通报错误。*\n\n#### ACK段（2位）\n- ACK槽（ACK Slot）：1位\n- ACK界定符：1位，隐性电平\n\n*注意*：对于ACK Slot，其工作方式为：\n- 对于发送单元：发送单元在ACK Slot发送1个隐性位\n- 对于接收单元：接收到正确信息的单元在ACK Slot发送显性位，通知发送单元正常接收结束。该动作称作“发送 ACK”或者“返回 ACK”。\n\n#### 帧结束（7位）\n表示帧结束，由7个隐性位构成。\n\n\n### 错误帧\n*WIP*\n\n## 位时序\n由发送单元在非同步的情况下发送的每秒钟的位数称为位速率。一个位可分为4段：\n- 同步段（SS）\n- 传播时间段（PTS）\n- 相位缓冲段1（PBS1）\n- 相位缓冲段2（PBS2）\n这些段又由可称为 Time Quantum（以下称为 Tq）的最小时间单位构成。\n\n1位分为4个段，每个段又由若干个Tq构成，这称为位时序。\n\n1位由多少个Tq构成、每个段又由多少个Tq构成等，可以任意设定位时序。通过设定位时序，多个单元可同时采样，也可任意设定采样点。\n\n![段及其作用](/images/arm/can5.png)\n\n![1个位的构成](/images/arm/CAN6.png)\n图中的采样点是指读取总线电平并将其作为位值的点，位于PBS1结束处。\n\n## 仲裁\nCAN本质是半双工通信，因为总线上同一时刻只允许一个信号传输，ID优先级不够的信号会在仲裁时失去发送权。具体为：\n- 若总线空闲：最先开始发送消息的单元取得发送权\n- 若多个单元同时发送：各发送单元从仲裁段的第一位开始进行仲裁，连续输出显性电平（逻辑0）最多的单元可继续发送\n\n![CAN总线仲裁过程](/images/arm/CAN7.png)\n\n## STM32F4的CAN控制器\n### 基本信息与标识符滤波器\nSTM32F4自带的是bxCAN，即基本扩展CAN，其支持CAN协议2.0A和2.0B。CAN2.0A只能处理标准数据帧，扩展帧的内容会识别错误；而CAN2.0B Active可以处理标准数据帧和扩展数据帧；CAN2.0B Passive只能处理标准数据帧，忽略扩展帧。\n\nF429自带两个CAN控制器：CAN1和CAN2.两个CAN分别拥有自己的发送邮箱和接收FIFO，但二者共用28个滤波器，其分配方式通过`CAN_FMR`寄存器设置。滤波器用于选择性接收符合特定条件的 CAN 消息，通过对 CAN 报文的标识符（ID）进行筛选，只接收满足条件的报文，将不相关的报文丢弃。这可以避免 MCU 对所有接收到的 CAN 报文进行处理，从而提升系统效率。\n\n滤波器有两种工作模式：\n- **标识符掩码模式（Identifier Mask Mode）：**\n  - 通过掩码定义哪些位需要匹配。\n  - 灵活性高，适合处理某些位通配的场景。\n  - 掩码中的每一位可以设置为：\n    - **\"0\"：** 忽略对应位。\n    - **\"1\"：** 匹配对应位。\n  - 例：目标只接收以`0x2A`（`101010`）为前六位的标识符，则配置过滤器的标识符为`0x2A0`（`10101000000`），掩码为`0xFC0`（`11111100000`），接收到的ID与掩码进行按位比较，只匹配掩码为1的位。\n\n- **标识符列表模式（Identifier List Mode）：**\n  - 直接指定一组标识符，只有匹配这些标识符的消息才会通过。\n  - 适合明确的标识符匹配。\n  - 例：指定`0x1A5`为期望标识符，则只有接收到的ID等于`0x1A5`时该消息才会被允许通过。\n\n### 发送\nCAN 控制器有 3 个发送邮箱（Tx Mailbox），用于存储待发送的消息。发送时，将消息写入空闲邮箱，然后硬件根据仲裁机制将消息发送到总线上。仲裁失败的消息会被重新加入发送队列，直到成功发送。\n\n![CAN通过邮箱发送](/images/arm/CAN8.png)\n\n正常发送流程为：\n1. 配置CAN发送帧，包括：\n        - 消息的标识符（11位或29位）\n        - 帧类型（数据帧或远程帧）\n        - 填充待发送数据\n        - 声明待发送数据长度\n2. 检查邮箱状态\n        - 确保至少有一个发送邮箱空闲（`TME=1`）\n3. 邮箱请求发送\n        - 设置CAN_TIxR的TXRQ位为`1`\n4. 邮箱挂号\n        - `RQCP=0`,`TXOK=0`,`TME=0`\n        - 等待成为最高优先级\n5. 预定发送\n        - 已成为最高优先级\n        - 等待CAN总线空闲\n6. 发送\n7. 发送成功\n        - `RQCP=1`,`TXOK=1`,`TME=1`\n        - 回到邮箱空闲状态\n7. 发送失败\n        - `RQCP=1`,`TXOK=0`,`TME=1`\n        - 回到邮箱空闲状态\n\n### 接收\nCAN接收到的有效报文，被存储在3级邮箱深度的FIFO中。FIFO完全由硬件来管理，从而节省了 CPU 的处理负荷，简化了软件并保证了数据的一致性。应用程序只能通过读取FIFO输出邮箱，来读取 FIFO 中最先收到的报文。\n\nCAN的接收有2个FIFO，我们每个滤波器组都可以设置其关联的 FIFO，通过 `CAN_FFA1R` 的设置，可以将滤波器组关联到FIFOO/FIFO1.\n\n*有效报文：指那些正确被接收的（直到EOF都没有错误）且通过了标识符过滤的报文。*\n\n![CAN通过FIFO接收](/images/arm/CAN9.png)\n\nFIFO接收到的报文数可以通过查询`CAN_RFxR`的FMP寄存器得到。\n\n*注意*：必须在FIFO溢出之前读出至少1个报文，否则下个报文到来时FIFO将溢出，导致最早收到的报文丢失。每读出1个报文，相应的挂号就减1，直到FIFO为空。\n\n### 位时间特性\n不同于原本的CAN协议，STM32把传播时间段（PTS）和相位缓冲段（PBS1）合并，所以STM32的CAN一个位只有3段：\n- 同步段（SYNC_SEG）\n- 时间段1（BS1）\n- 时间段2（BS2）\n\n![STM32中的CAN位时序](/images/arm/CAN10.png)\n\n图中给出了CAN波特率的计算公式，只需要知道CAN_BTR中BRP、TS1和TS2的设置就可以计算。\n\n### 寄存器\n*WIP*","categories":["嵌入式（裸机开发）"]},{"title":"STM32中的SPI","url":"/2024/12/17/STM32中的SPI/","content":"## SPI简介\n### 接口、工作原理与传输方式\nSPI接口共有四个Pin:\n- MISO（Master In / Slave Out）主设备数据输入，从设备数据输出。\n- MOSI（Master Out / Slave In）主设备数据输出，从设备数据输入。\n- SCLK（Serial Clock）时钟信号，由主设备产生。\n- CS（Chip Select）从设备片选信号，由主设备产生。\n\nSPI的工作原理：在主机和从机都有一个串行移位寄存器，主机通过向它的 SPI 串行寄存器写入一个字节来发起一次传输。串行移位寄存器通过 MOSI 信号线将字节传送给从机，从机也将自己的串行移位寄存器中的内容通过 MISO 信号线返回给主机。这样，两个移位寄存器中\n的内容就被交换。外设的写操作和读操作是同步完成的。如果只是进行写操作，主机只需忽略接收到的字节。反之，若主机要读取从机的一个字节，就必须发送一个空字节引发从机传输。\n\nSPI的传输方式：\n- 全双工：任何时刻，主机与从机之间都可以同时进行数据的发送和接收\n- 单工：数据传输是固定单向的\n- 半双工：允许数据在两个方向上传输，但同一时刻只能传输一个方向的数据（如IIC）\n\nSPI依据CPOL和CPHA的不同状态分成了4种模式。其中CPOL和CPHA分别是：\n- CPOL（Clock Polarity，时钟极性）：定义为主从机没有数据传输时，SCL线的电平状态。假如空闲状态下SCL线为高电平，则`COPL=1`；若为低电平，则`COPL=0`\n- CPHA（Clock Phase，时钟相位）：数据采样时刻，即在时钟信号的哪个边沿上数据被传输或采样。若`CPHA=0`，则数据在时钟的第一个边沿（即时钟信号的上升沿或下降沿）采样，数据在第二个边沿（另一个相反的边沿）被传输；若`CPHA=1`，则数据在时钟的第二个边沿（与CPHA = 0时不同）采样，数据在第一个边沿传输。\n\n按照CPOL和CPHA的不同，SPI的四种模式分别为：\n\n| SPI工作模式 | CPOL | CPHA | SCL空闲状态 | 采样边沿 | 采样时刻 |\n|---------|------|------|---------|------|------|\n| 0       | 0    | 0    | LOW     | 上升沿  | 奇数边沿 | \n| 1       | 0    | 1    | LOW     | 下降沿  | 偶数边沿 | \n| 2       | 1    | 0    | HIGH    | 下降沿  | 奇数边沿 |  \n| 3       | 1    | 1    | HIGH    | 上升沿  | 偶数边沿 | \n\n实际应用中，通常使用**模式0**和**模式3**，即都在奇数边沿采样。\n\n### SPI寄存器\nSPI通常需要用到以下16位寄存器：\n- SPI控制寄存器（SPI_CR1）：控制主设备模式选择，传输方向，数据格式，时钟极性、时钟相位和使能等。\n- SPI状态寄存器（SPI_SR）：用于查询SPI当前状态\n- SPI数据寄存器（SPI_DR）：双寄存器，包含发送缓存与接收缓存\n\n## NOR Flash （W25Q256）\n### 简介\nNOR Flash 是一种非易失性存储器，广泛应用于嵌入式系统中，尤其是在需要快速读取数据的场景。它与 NAND Flash 的主要区别在于存储单元的结构和读写性能。NOR Flash 使用并行的地址和数据总线，其存储单元是基于 NOR 门（一个逻辑门）。这种结构使得它能够按字节（Byte）直接读取数据。由于 NOR Flash 支持按字节随机访问，因此在读取速度上优于 NAND Flash。它适合于存储固件、代码等经常读取的应用。其写入操作较慢，通常需要先将整个块（block）擦除后才能进行写入。每个单元的擦写次数有限，通常为数万到数十万次，因此在需要频繁写入的场景中，NOR Flash 的耐用性较差。NOR Flash 主要应用于嵌入式系统，如存储引导程序、固件（BIOS）等。它也广泛应用于汽车、智能设备、消费电子等领域，用作存储启动代码、配置数据等。对于低功耗设备，NOR Flash 适合用于电池供电且不频繁写入的应用。总的来说，NOR Flash 主要优势是其快速的读取能力，适合存储代码和配置等经常读取的内容，而写入和擦除操作较为缓慢。\n\nNOR与NAND在数据写入前都需要有**擦除**操作。\n\nNM25Q128 支持标准的 SPI，还支持双输出/四输出的 SPI，最大 SPI 时钟可以到 104Mhz（双输出时相当于 208Mhz，四输出时相当于 416M）。\n\n![W25Q256 IC引脚](/images/arm/spi1.png)\n\n- CS：片选引脚，低电平有效\n- DO：MISO引脚\n- WP：写保护引脚。高电平时可读可写，低电平时只读\n- DI：MOSI引脚\n- CLK：串行时钟引脚\n- HOLD：保持引脚，低电平有效\n\n对于W25Q256的存储架构而言，从大到小可以分为这么几级：\n- 256个块（Block），每个64K字节\n    + 每个块分为16个扇区（Sector），每个4K字节\n        - 每个扇区分为16个页（Page），每个256字节\n\nW25Q256的最小擦除单位为一个扇区，也就是每次必须擦除4K个字节。这样我们需要给W25Q256开辟一个至少4K字节的缓存区，这样对SRAM要求比较高，要求芯片必须有4K以上的SRAM才能很好的操作。\n\n### 状态寄存器（Status Register）\nW25Q256拥有3个状态寄存器，分别为SR1，SR2和SR3.具体作用可参见手册7.1节。下面是比较重要的一些寄存器位：\n![SR1](/images/arm/spi5.png)\n- S0：BUSY位，只读。置1表示设备忙（有操作正在进行），置0表示设备空闲，准备好接收其他指令。\n- S1：写使能锁存器（WEL），只读。置1表示写使能，置0表示写禁用。\n\n![SR3](/images/arm/spi6.png)\n- S17：ADP位。置0时，设备启动将会引导至3字节地址模式，该模式下若要访问128Mb以外的flash则必须启用附加地址寄存器（Extended Addr Reg）；置1时，设备启动引导至4字节地址模式。\n\n### 指令与工作时序\n#### 写使能（Write Enable）- 06H\n写使能指令用于将SR1的WEL位置1.该指令必须在所有页操作（Page Program）、扇区擦除、块擦除、芯片擦除和写入状态寄存器操作前调用。\n\n![写使能指令时序](/images/arm/spi6.png)\n\n```\n /**\n* @brief IC 写使能 Write Enable\n* @param NULL\n* @retval NULL\n*/\nvoid w25q256_write_enable(void)\n{\n    NORFLASH_CS(0);     \n\n    uint8_t code = 0x06;\n    HAL_SPI_Transmit(&hspi5, (uint8_t *)&code, 1, 1000);\n\n    NORFLASH_CS(1);\n}\n```\n\n#### 写禁用（Write Disable） - 04H\n该指令会将SR1-WEL置0.一般情况下，WEL位会在所有页操作（Page Program）、扇区擦除、块擦除、芯片擦除、写入状态寄存器操作和IC复位后自动置为0.\n```\n /**\n* @brief IC 关闭写使能 Write Disable\n* @param NULL\n* @retval NULL\n*/\nvoid w25q256_write_disable(void)\n{\n    NORFLASH_CS(0);\n\n    uint8_t code = 0x04;\n    HAL_SPI_Transmit(&hspi5, (uint8_t *)&code, 1, 1000);\n\n    NORFLASH_CS(1);\n}\n```\n\n#### 读取状态寄存器 - 05H/35H/15H\n该指令用于读取状态寄存器中的值，`05H`用于读取SR1，`35H`读取SR2，`15H`读取SR3.该指令可以在任何时候被调用，通过位操作用于确认BUSY位是否为0（`&0x01`），以确认IC是否准备好接收另一条指令。\n```\n/**\n* @brief 读取IC状态寄存器 Read Status Register\n * @note        SR-1\n *              BIT7  6   5   4   3   2   1   0\n *              SPR   RV  TB BP2 BP1 BP0 WEL BUSY\n *              SPR:默认为0，保护位，配合WP使用\n *              TB,BP2,BP1,BP0:FLASH区域写保护设置\n *              WEL:写使能锁定\n *              BUSY:忙标记为（1：忙；0：空闲）\n *              默认:0x00\n *\n *              SR-2\n *              BIT7  6   5   4   3   2   1   0\n *              SUS   CMP LB3 LB2 LB1 (R) QE  SRP1\n *\n *              SR-3\n *              BIT7      6    5    4   3   2   1   0\n *              HOLD/RST  DRV1 DRV0 (R) (R) WPS ADP ADS\n* @param sr:状态寄存器编号\n* @retval rxbyte：接收到的8位寄存器值\n*/\nuint8_t w25q256_read_status_reg(uint8_t sr)\n{\n    uint8_t rxbyte, readsr = 0;\n\n    NORFLASH_CS(0);\n\n    switch (sr)\n    {\n        case 1:\n            readsr = 0x05;      /* SR1读指令 */\n            break;\n        \n        case 2:\n            readsr = 0x35;      /* SR2读指令 */\n            break;\n        \n        case 3:\n            readsr = 0x15;      /* SR3读指令 */\n            break;\n    }\n\n    HAL_SPI_Transmit(&hspi5, (uint8_t *)&readsr, sizeof(readsr), 1000);   /* 主机发送对应指令 */\n    HAL_SPI_Receive(&hspi5, (uint8_t *)&rxbyte, sizeof(rxbyte), 1000);\n\n    NORFLASH_CS(1);\n\n    return rxbyte;\n}\n```\n```\n/**\n * @brief       等待空闲\n * @param       NULL\n * @retval      NULL\n */\nstatic void norflash_wait_busy(void)\n{\n    while ((w25q256_read_status_reg(1) & 0x01) == 0x01);               /* 等待BUSY位清空 */\n}\n```\n\n#### 进入/退出4字节地址模式 - B7H/E9H\n4字节地址启用时，存入/读取数据时寻址地址为32位而非24位，可以访问128Mb以外的Flash。\n```\n/**\n* @brief 进入4字节地址模式 Enter 4-Byte Address Mode\n* @note 允许使用32位地址以访问128Mb以外区域\n* @param NULL\n* @retval NULL\n*/\nvoid w25q256_enter_4byte_mode(void)\n{\n    uint8_t code = 0xB7;\n\n    NORFLASH_CS(0);\n    HAL_SPI_Transmit(&hspi5, &code, 1, 1000);\n    NORFLASH_CS(1);\n}\n```\n```\n /**\n* @brief 退出4字节地址模式 Exit 4-Byte Address Mode\n* @note 非4字节地址模式下要访问128Mb以外区域需要使用拓展地址寄存器（Extended Addr Reg）\n* @param NULL\n* @retval NULL\n*/\nvoid w25q256_exit_4byte_mode(void)\n{\n    uint8_t code = 0xE9;\n\n    NORFLASH_CS(0);\n    HAL_SPI_Transmit(&hspi5, &code, 1, 1000);\n    NORFLASH_CS(1);\n}\n```\n#### 读操作（32位地址模式） - 13H\n![W25Q256 读操作（32位地址模式）时序](/images/arm/spi2.png)\n读操作时序包含以下步骤：\n1. 拉低CS电平，激活片选\n2. MOSI发送13H，然后发送待读取32位地址\n3. 从机在CLK下降沿从MISO发送对应地址的数据\n4. 拉高CS电平，传输停止\n\n```\n /**\n* @brief 读取数据(32位地址模式) Read Data(4Byte Addr Mode)\n* @note 参见datasheet 8.2.10\n* @param pbuf:接收缓存区地址 \n* @param addr：目标地址\n* @param datalen：接收长度（字节）\n* @retval NULL\n*/\nvoid w25q256_read_data_4byte_mode(uint8_t *pbuf, uint32_t addr, uint16_t datalen)\n{\n    uint8_t read_data_code = 0x13;\n\n    NORFLASH_CS(0);\n    HAL_SPI_Transmit(&hspi5, &read_data_code, 1, 1000);     /* 发送32位模式读指令 */\n    HAL_SPI_Transmit(&hspi5, (uint8_t *) &addr, 4, 1000);   /* 发送32位目标内存地址 */\n    HAL_SPI_Receive(&hspi5, pbuf, datalen, 1000);   /* 接收读取值 */\n    NORFLASH_CS(1);\n}\n```\n#### 页编程（Page Program） - 02H\n*参见*：datasheet 8.2.25\n![W25Q256 页写操作时序](/images/arm/spi3.png)\n\n页面编程指令允许在先前擦除的 (FFh) 内存位置对 1 字节到 256 字节（一页）的数据进行编程。必须先执行写使能指令，设备才会接受页面编程指令（WEL= 1）。\n\n如果要编程整个 256 字节页面，则最后一个地址字节（8 个最低有效地址位）应设置为 0。如果最后一个地址字节不为零，并且时钟数超过剩余页面长度，则寻址将绕回到页面的开头。在某些情况下，可以编程少于 256 个字节（部分页面），而不会对同一页面内的其他字节产生任何影响。\n\n*注意*：执行部分页面编程的一个条件是时钟数不能超过剩余的页长度。如果向设备发送了超过 256 个字节，寻址将绕回到页面的开头并覆盖先前发送的数据。\n```\n\n```\n\n\n\n\n\n\n![W25Q256 扇区擦除时序](/images/arm/spi4.png)\nW25Q256扇区大小为4K字节，擦除扇区后所有扇区位全部置1，即扇区字节为`FFH`。\n1. 主机发送“写使能”指令\n2. 确定SPI总线状态：读取状态寄存器的BUSY位，等待BUSY位为0后，继续下一步\n3. 主机拉低CS引脚\n4. 主机从MOSI发送`20H`到从机，然后发送24位扇区地址\n5. 主机拉高CS引脚，读取寄存器状态，等待扇区擦除完成\n\nW25Q256还有整个IC擦除的操作，只需发送`C7H`到IC即可实现整片擦除。\n","categories":["嵌入式（裸机开发）"]},{"title":"STM32中的I2C通信【AP3216C光传感器】","url":"/2024/12/13/STM32中的I2C通信【AP3216C光传感器】/","content":"## AP3216C \n### 简介\nAP3216C 是敦南科技推出的一款三合一环境传感器， 它包含了：数字环境光传感器（ALS）、接近传感器（PS）和一个红外 LED（IR）。该芯片通过 IIC 接口和 MCU 连接，并支持中断（INT）输出。AP3216C 的特点如下：\n- IIC 接口，支持高达 400KHz 通信速率\n- 支持多种工作模式（ALS、PS+IR、ALS+PS+IR 等）\n- 内置温度补偿电路\n- 工作温度支持-30~80℃\n- 环境光传感器具有 16 位分辨率\n- 接近传感器具有 10 位分辨率\n- 红外传感器具有 10 位分辨率\n- 超小封装（4.1*2.4*1.35mm）\n\n因为以上一些特性，AP3216C 被广泛应用于智能手机上面，用来检测光强度（自动背光控制），和接近开关控制（听筒靠近耳朵，手机自动灭屏功能）。\n\n### 写寄存器\n![AP3216C写寄存器时序](/images/arm/3216c1.png)\n先发送 AP3216C 的地址（7 位，为`0X1E`，左移一位后为 `0X3C`），最低位 W=0 表示写数据，随后发送 8 位寄存器地址，最后发送 8 位寄存器值。其中：S，表示 IIC 起始信号；W，表示读/写标志位（W=0 表示写，W=1 表示读）；A，表示应答信号；P，表示 IIC 停止信号。\n\n### 读寄存器\n![AP3216C寄存器说明](/images/arm/3216c2.png)\n\n*注意*：AP3216C的读取间隔至少需要大于112.5ms（一次ALS+PS+IR转换的时间）\n\n## 工程\n### ap3216c.h\n```\n #include \"sys.h\"\n #include \"main.h\"\n\n #ifndef __AP3216C_H\n #define __AP3216C_H\n\n #define AP3216C_ADDR 0x3C  /* 原设备地址为0x1E，左移一位为0x3C*/\n\n #endif\n\n uint8_t ap3216c_init(void);\n uint8_t ap3216c_write_one_byte(uint8_t reg, uint8_t data);\n uint8_t ap3216c_read_one_byte(uint8_t reg);\n void ap3216c_read_data(uint16_t *ir, uint16_t *ps, uint16_t *als);\n ```\n ### ap3216c.c\n```\n#include \"main.h\"\n #include \"sys.h\"\n #include \"ap3216c.h\"\n #include \"custom_i2c.h\"\n #include \"delay.h\"\n\n /**\n* @brief 初始化 AP3216C\n* @param 无\n* @retval 返回值:0,初始化成功; 1,初始化失败\n*/\nuint8_t ap3216c_init(void)\n{\n    uint8_t temp = 0;\n    iic_init();\n\n    ap3216c_write_one_byte(0x00, 0x04);     /* 软复位AP3216C */\n    delay_ms(50);                           /* IC复位至少需要11.5ms */\n    ap3216c_write_one_byte(0x00, 0x03);     /* ALS+PS+IR功能激活 */\n    temp = ap3216c_read_one_byte(0x00);     /* 读取刚刚写入的0x03指令 */\n    if (temp == 0x03) return 0;             /* IC初始化成功 */\n    else return 1;                          /* IC初始化失败 */\n}\n\n/**\n* @brief AP3216C 写入一个字节\n* @param reg : AP3216C目标寄存器地址\n* @param data : 待写入数据\n* @retval 0, 成功;\n          1, 失败;\n*/\nuint8_t ap3216c_write_one_byte(uint8_t reg, uint8_t data)\n{\n    iic_start();\n    \n    iic_send_byte(AP3216C_ADDR | 0x00);     /* 发送设备地址，最低位为0，写命令 */\n\n    if (iic_wait_ack())     /* 等待应答*/\n    {\n        iic_stop();         /* 等待应答失败则直接停机 */\n        return 1;\n    }\n\n    iic_send_byte(reg);     /* 发送目标寄存器地址（指针）*/\n    iic_wait_ack();         /* 等待应答 */\n    iic_send_byte(data);    /* 发送待写入数据 */\n\n    if (iic_wait_ack())     /* 等待应答*/\n    {\n        iic_stop();         /* 等待应答失败则直接停机 */\n        return 1;\n    }\n\n    iic_stop();\n    return 0;\n}\n\n/**\n* @brief AP3216C 读取一个字节\n* @param reg : 待读取寄存器地址\n* @retval 读到的数据\n*/\nuint8_t ap3216c_read_one_byte(uint8_t reg)\n{\n    uint8_t result;\n\n    iic_start();\n\n    iic_send_byte(AP3216C_ADDR | 0x00);     /* 发送设备地址，最低位为0，写命令*/\n    iic_wait_ack();\n\n    iic_send_byte(reg);     /* 发送待读取寄存器地址 */\n    iic_wait_ack();\n\n    iic_start();            /* 准备开始读取，重新启动IIC以切换模式 */\n    iic_send_byte(AP3216C_ADDR | 0x01);     /* 发送设备地址，最低位为1，读命令*/\n    iic_wait_ack();\n    result = iic_read_byte(0);              /* 读取一个字节，读完后发送NACK，表示读取结束 */\n    iic_stop();\n    \n    return result;      /* 返回读取结果 */\n}\n\n/**\n* @brief 读取 AP3216C 的数据\n* @note 读取原始数据，包括 ALS,PS 和 IR\n* 如果同时打开 ALS,IR+PS 的话两次数据读取的时间间隔要大于 112.5ms\n* @param ir : IR 传感器值\n* @param ps : PS 传感器值\n* @param als : ALS 传感器值\n* @retval 无\n*/\nvoid ap3216c_read_data(uint16_t *ir, uint16_t *ps, uint16_t *als)\n{\n    uint8_t rx_buf[6];      /* 读取缓冲区 */\n    uint8_t i;\n\n    for (i = 0; i < 6; i++) /* 循环6次以读取6个寄存器的值 */\n    {\n        rx_buf[i] = ap3216c_read_one_byte(0x0A + i);\n    }\n\n    /* 提取IR传感器值 */\n    if (rx_buf[0] & 0x80)   /* 判断IR第7位是否为1 */\n    {\n        *ir = 0;            /* 第7位若为1则IR数据无效 */\n    }\n    else\n    {\n        /* rx_buf[1] << 2：0x0B（IR高位）数据左移2位，给低位数据留出空余*/\n        /* rx_buf[0] & 0x03：提取0x0A（IR低位）数据的第0位和第1位，也就是IR的最低2位*/\n        /* 二者进行或运算得到IR的最终值 */\n        *ir = ((uint16_t)rx_buf[1] << 2) | (rx_buf[0] & 0x03);  \n    }\n\n    /* 提取ALS传感器值 */\n    *als = rx_buf[2] | ((uint16_t)rx_buf[3] << 8);\n\n    /* 提取PS传感器值 */\n    if (rx_buf[4] & 0x40)   /* 判断0x0E第6位是否为1*/\n    {\n        *ps = 0;            /* PS数据无效 */\n    }\n    else\n    {\n        /* (rx_buf[4] & 0x0F)：取0x0E的3:0位，也就是PS的低4位 */\n        /* ((uint16_t)(rx_buf[5] & 0x3F) << 4):取0x0F的5:0位然后左移4位，给低4位留位置 */\n        /* 二者进行或运算得到PS的最终值 */\n        *ps = ((uint16_t)(rx_buf[5] & 0x3F) << 4) | (rx_buf[4] & 0x0F);\n    }\n}\n```\n### main.c\n```\n  /* USER CODE BEGIN 2 */\n  while (ap3216c_init())    /* AP3216C初始化失败 */\n  {\n    uint8_t txbuf[] = \"ap3216c init failed!\\n\";\n    HAL_UART_Transmit_IT(&huart1, txbuf, sizeof(txbuf));\n    led_red(1);\n  }\n  /* USER CODE END 2 */\n```\n\n```\nwhile (1)\n  {\n    /* USER CODE END WHILE */\n    ap3216c_read_data(&ir, &ps, &als);\n\n    uint8_t txbuf[23];\n\n    sprintf(txbuf, \"ir:%d, ps:%d, als:%d\\r\\n\", ir, ps, als);\n    HAL_UART_Transmit_IT(&huart1, (uint8_t *)txbuf, sizeof(txbuf));\n\n    led_green_toggle();\n    delay_ms(120);    /* 延时120ms以保证AP3216C采样正确 */\n    /* USER CODE BEGIN 3 */\n\n  }\n```\n### 测试\n![串口打印结果](/images/arm/3216c3.png)","categories":["嵌入式（裸机开发）"]},{"title":"RNN：原理、组成与简单实现","url":"/2024/12/12/RNN：原理、组成与简单实现/","content":"## 传统RNN\n循环神经网络（RNN）最早可以追溯到1980年代末，当时的研究者希望设计一种能够处理时间序列数据或具有时序依赖关系的数据的神经网络模型。RNN的设计灵感来自生物神经网络的工作原理，它模拟了大脑神经元的反馈机制，通过递归连接来捕捉数据中前后时刻的依赖关系。\n\n### 历史\nRNN的初期发展可追溯到1986年，David Rumelhart 和 Geoffrey Hinton 等人提出了反向传播算法，并在此基础上构建了简单的RNN模型。最初的RNN能够通过训练学习输入数据的时序模式。RNN 跟传统神经网络最大的区别在于每次都会将前一次的输出结果，带到下一次的隐藏层中，一起训练。\n\n### 工作原理\n以一个最简单的语序为例：用户输入了一句“what time is it”，首先需要对这句话进行分词：\n\n![第一步：分词](/images/DL/rnn1.gif)\n\n将分词结果按顺序输入RNN。首先输入“what”：\n\n![第二步：输入\"what\"](/images/DL/rnn2.gif)\n\n按顺序输入剩下的分词，第三步输入“time”。按照RNN的结构，输入\"time\"时，之前输入的\"what\"会对RNN的输出产生影响（隐藏层中有一半是黑色的）\n\n![第三步：输入\"time\"](/images/DL/rnn3.gif)\n\n以此类推，每一个历史输入都会对未来输出产生影响，直观显示为每一个圆形隐藏层中都包含了之前所有历史输入所指代的颜色。\n\n![第四步：历史输入会影响未来输出](/images/DL/rnn4.gif)\n\n最后需要输出结果（此处是判断这句话的意图）时，只需要输出最后一层的结果。\n\n### 组成和基本结构\nRNN的核心组成部分是**循环结构**，它使得网络能够记住之前时刻的信息，并通过这种“记忆”来影响当前时刻的计算。RNN的基本结构可以通过以下几个部分来理解：\n\n#### 1. 输入层（Input Layer）\n输入序列数据，通常表示为一个时间步的输入向量 $ x_t $。例如，在自然语言处理任务中，输入可以是一个词向量；在时间序列预测任务中，输入可以是某一时刻的传感器数据。\n\n#### 2. 隐层（Hidden Layer）\n隐藏层由多个神经元组成，每个神经元的输出不仅受到当前输入的影响，还受到前一时刻隐层状态的影响。该层的计算过程可以表示为：\n$$\nh_t = f(W_{xh}x_t + W_{hh}h_{t-1} + b_h)\n$$\n其中，$ h_t $ 是当前时刻的隐层状态，$ x_t $ 是当前输入，$ h_{t-1} $ 是前一时刻的隐层状态，$ W_{xh} $ 和 $W_{hh} $ 是权重矩阵，$ b_h $ 是偏置项，$ f $ 是激活函数（如tanh或ReLU）。\n\n#### 3. 输出层（Output Layer）\n输出层用于生成预测结果，通常可以表示为：\n$$\ny_t = g(W_{hy}h_t + b_y)\n$$\n其中，$ y_t $ 是当前时刻的输出，$ W_{hy} $ 是从隐层到输出的权重矩阵，$ b_y $ 是输出层的偏置项，$ g $ 是输出的激活函数（例如softmax或sigmoid，取决于任务）。\n\n\n### 应用\nRNN在时间序列数据处理中的优势是能够**捕捉时间序列的动态变化和时序依赖关系**，因此它特别适用于处理和预测具有时序特征的数据。\n\nRNN的缺点也很明显，即短期的记忆影响较大，长期的记忆影响较小。若整个时间序列非常长，RNN甚至可能丢失很久之前的历史输入。同时，训练RNN也需要大量的成本，并且很容易带来梯度消失和梯度爆炸问题。这就引出了后来的变种：门控循环单元（GRU）与长短期记忆网络（LSTM）。\n\n## 门控循环单元（GRU）\n*参考文献：Cho, K., Van Merriënboer, B., Bahdanau, D., & Bengio, Y. (2014). On the properties of neural machine translation: encoder-decoder approaches. arXiv preprint arXiv:1409.1259.*\n### 来源\nGRU被用于解决传统RNN的梯度异常问题。这种梯度异常问题在序列问题中是非常常见的，比如：\n- 早期观测值对预测所有未来观测值具有非常重要的意义。 考虑一个极端情况，其中第一个观测值包含一个校验和， 目标是在序列的末尾辨别校验和是否正确。 在这种情况下，第一个词元的影响至关重要。 我们希望有某些机制能够在一个记忆元里存储重要的早期信息。 如果没有这样的机制，我们将不得不给这个观测值指定一个非常大的梯度， 因为它会影响所有后续的观测值。\n- 一些特征或现象没有相关的观测值。 例如，在对网页内容进行情感分析时， 可能有一些辅助HTML代码与网页传达的情绪无关。 我们希望有一些机制来跳过隐状态表示中的此类词元。\n- 序列的各个部分之间存在逻辑中断。 例如，书的章节之间可能会有过渡存在， 或者证券的熊市和牛市之间可能会有过渡存在。 在这种情况下，最好有一种方法来重置我们的内部状态表示。\n\n### 工作原理\nGRU与传统RNN的关键区别在于，GRU支持隐状态的门控。这意味着模型有专门的机制来确定应该何时更新隐状态， 以及应该何时重置隐状态。 这些机制是可学习的，并且能够解决了上面列出的问题。 例如，如果第一个序列数据变化现象非常重要（如发电机故障中匝间短路的那一瞬间）， 模型将学会在第一次观测之后不更新隐状态。同样，模型也可以学会跳过不相关的临时观测。最后，模型还将学会在需要的时候重置隐状态。 \n\n#### 重置门（Reset Gate）\n重置门用于决定当前时刻的输入数据在计算当前状态时对之前状态的影响程度。即它决定在计算新的候选隐藏状态时，前一时刻的隐层状态应该有多大的影响。\n\n公式表示为：\n$$\nr_t = \\sigma(W_r x_t + U_r h_{t-1} + b_r)\n$$\n其中，$r_t$ 是重置门的输出，$W_r$ 和 $U_r$ 是权重矩阵，$x_t$ 是当前时刻的输入，$h_{t-1}$ 是前一时刻的隐藏状态，$b_r$ 是偏置项，$\\sigma$ 是sigmoid激活函数。\n\n当 $r_t$ 接近0时，表示前一时刻的隐藏状态对当前时刻的影响很小，网络将“重置”之前的记忆。\n\n#### 更新门（Update Gate）\n更新门控制着当前时刻的隐藏状态应该如何更新，它决定了当前时刻的输出应保留多少来自上一时刻的状态，多少来自当前输入的候选隐藏状态。更新门的值接近1时，意味着当前时刻的隐藏状态保留更多来自前一时刻的记忆；而接近0时，意味着更多的依赖于当前输入。\n\n公式表示为：\n$$\nz_t = \\sigma(W_z x_t + U_z h_{t-1} + b_z)\n$$\n其中，$z_t$ 是更新门的输出，$W_z$ 和 $U_z$ 是权重矩阵，$x_t$ 是当前时刻的输入，$h_{t-1}$ 是前一时刻的隐藏状态，$b_z$ 是偏置项。\n\n![GRU中计算重置门和更新门](/images/DL/gru-1.svg)\n\n#### 候选隐藏状态（Candidate Hidden State）\n候选隐藏状态是GRU网络根据当前输入和重置门的作用计算出来的，表示网络在当前时刻希望更新的“记忆”。它是基于当前输入和前一时刻的记忆状态计算的。\n\n公式表示为：\n$$\n\\tilde{h}_t = \\tanh(W_h x_t + U_h (r_t \\cdot h_{t-1}) + b_h)\n$$\n其中，$\\tilde{h}_t$ 是候选隐藏状态，$W_h$ 和 $U_h$ 是权重矩阵，$r_t$ 是重置门的输出，$\\cdot$ 表示按元素相乘（Hadamard积），$\\tanh$ 是tanh激活函数。\n\n![GRU中计算候选隐藏状态](/images/DL/gru-2.svg)\n\n\n#### 最终隐藏状态（Final Hidden State）\n最终的隐藏状态是当前时刻候选隐藏状态和上一时刻的隐藏状态的加权平均。加权系数由更新门 $z_t$ 控制，表示信息应该更新多少，保留多少。\n\n公式表示为：\n$$\nh_t = (1 - z_t) \\cdot \\tilde{h}_t + z_t \\cdot h_{t-1}\n$$\n其中，$h_t$ 是当前时刻的最终隐藏状态，$\\tilde{h}_t$ 是候选隐藏状态，$z_t$ 是更新门，$h_{t-1}$ 是前一时刻的隐藏状态。\n\n![GRU中计算最终隐藏状态](/images/DL/gru-3.svg)\n\n### 简单应用\nGRU十分适合用于时间序列数据的特征识别、提取和预测，尤其是较长时间内的时间序列。\n下面是一个用于预测未来一段时间内天气状况的模型，其使用五个GRU层，用于对四个不同变量（最高温、最低温、降水量与风速）进行回归任务。数据集来自于[Kaggle](https://www.kaggle.com/datasets/ananthr1/weather-prediction)\n```\nimport pandas as pd\nimport numpy as np\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.model_selection import train_test_split\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras.layers import Input, GRU, Dense, Dropout\nimport tensorflow.keras.backend as K\nimport matplotlib.pyplot as plt\n\n# 1. 加载CSV文件，读取日期数据，并转换为日期格式\ndf = pd.read_csv('seattle-weather.csv', parse_dates=['date'])\n\n# 2. 处理缺失值，使用前向填充（前一个有效值填充）\ndf.fillna(method='ffill', inplace=True)\n\n# 3. 规范化数值特征\n# 使用 MinMaxScaler 将数据缩放到 0 和 1 之间\nscaler = MinMaxScaler()\nscaled_features = ['precipitation', 'temp_max', 'temp_min', 'wind']  # 需要规范化的特征\ndf[scaled_features] = scaler.fit_transform(df[scaled_features])\n\n# 4. 创建时间序列数据：输入X是过去window_size天的特征，y是目标列（temp_max, temp_min, precipitation, wind）\ndef create_sequences(df, window_size, target_columns):\n    X, y = [], []\n    for i in range(len(df) - window_size):\n        # 过去 window_size 天的数据作为输入\n        X.append(df.iloc[i:i + window_size][scaled_features].values)\n        # 当前天的目标特征作为输出\n        y.append(df.iloc[i + window_size][target_columns].values)  # 多目标回归\n    return np.array(X), np.array(y)\n\n# 设置时间窗口为15天，目标列为气温、降水量和风速\nwindow_size = 15\ntarget_columns = ['temp_max', 'temp_min', 'precipitation', 'wind']  # 目标列：温度、降水量和风速\nX, y = create_sequences(df, window_size, target_columns)\n\n# 5. 划分训练集和测试集，采用80%的数据用于训练，20%用于测试\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)\n\n# 6. 转换数据格式\nX_train, y_train = np.array(X_train), np.array(y_train)\nX_test, y_test = np.array(X_test), np.array(y_test)\n\n# 将目标值数据类型转换为 float32，以便模型训练\ny_train = y_train.astype(np.float32)\ny_test = y_test.astype(np.float32)\n\n# 输出训练集和测试集的形状，确保数据格式正确\nprint(\"X_train shape:\", X_train.shape)\nprint(\"X_test shape:\", X_test.shape)\nprint(\"y_train shape:\", y_train.shape)\nprint(\"y_test shape:\", y_test.shape)\n\n# 7. 构建共享底层GRU网络 + 多目标回归模型\n\n# 输入层，形状为 (window_size, 4)，即过去15天的4个特征\ninput_layer = Input(shape=(window_size, len(scaled_features)))\n\n# 构建多层GRU网络，每层后面都添加Dropout层，以防止过拟合\nx = GRU(256, return_sequences=True)(input_layer)  # 第1层GRU，返回所有时间步的输出\nx = Dropout(0.2)(x)  # Dropout，丢弃20%的神经元\n\nx = GRU(256, return_sequences=True)(x)  # 第2层\nx = Dropout(0.2)(x)  # Dropout\n\nx = GRU(128, return_sequences=True)(x)  # 第3层\nx = Dropout(0.2)(x)  # Dropout\n\nx = GRU(128, return_sequences=True)(x)  # 第4层\nx = Dropout(0.2)(x)  # Dropout\n\nx = GRU(64)(x)  # 第5层，只返回最后一个时间步的输出\nx = Dropout(0.2)(x)  # Dropout\n\n# 4个目标列的独立输出层，每个输出层预测一个目标\ntemp_max_output = Dense(1, name='temp_max')(x)  # 输出温度最大值\ntemp_min_output = Dense(1, name='temp_min')(x)  # 输出温度最小值\nprecipitation_output = Dense(1, name='precipitation')(x)  # 输出降水量\nwind_output = Dense(1, name='wind')(x)  # 输出风速\n\n# 定义模型，输入为输入层，输出为4个目标特征\nmodel = Model(inputs=input_layer, outputs=[temp_max_output, temp_min_output, precipitation_output, wind_output])\n\n# 8. 编译模型\n\n# 定义加权损失函数\ndef weighted_loss(y_true, y_pred):\n    # 为每个目标特征设置权重\n    temp_max_weight = 1.0\n    temp_min_weight = 1.0\n    precipitation_weight = 10.0  # 为降水增加权重\n    wind_weight = 50.0  # 为风速增加权重\n\n    # 计算加权的损失\n    loss = K.mean(K.square(y_true - y_pred), axis=-1)  # 计算均方误差\n    weights = K.constant([temp_max_weight, temp_min_weight, precipitation_weight, wind_weight])\n\n    return K.mean(loss * weights, axis=-1)  # 计算加权后的损失\n\n# 编译模型，使用Adam优化器和均方误差作为损失函数\nmodel.compile(optimizer='adam',\n              loss='mean_squared_error',  # 对每个输出使用均方误差\n              metrics={  # 为每个目标列定义MAE和MSE指标\n                  'temp_max': ['mae', 'mse'],         # 针对 temp_max 输出定义 MAE 和 MSE\n                  'temp_min': ['mae', 'mse'],         # 针对 temp_min 输出定义 MAE 和 MSE\n                  'precipitation': ['mae', 'mse'],    # 针对 precipitation 输出定义 MAE 和 MSE\n                  'wind': ['mae', 'mse']              # 针对 wind 输出定义 MAE 和 MSE\n              })\n\n# 9. 训练模型\nhistory = model.fit(X_train, [y_train[:, 0], y_train[:, 1], y_train[:, 2], y_train[:, 3]],\n                    epochs=150, batch_size=32,  # 设置训练的轮次和每批次的样本数\n                    validation_data=(X_test, [y_test[:, 0], y_test[:, 1], y_test[:, 2], y_test[:, 3]]))  # 验证集数据\n\n# 10. 模型评估，返回损失值和每个目标特征的评估指标\nresults = model.evaluate(X_test, [y_test[:, 0], y_test[:, 1], y_test[:, 2], y_test[:, 3]])\n\n# results 返回的是一个列表，包含了损失值和各个目标特征的MAE和MSE\ntest_loss = results[0]\ntest_mae_temp_max = results[2]  # temp_max 对应的 MAE\ntest_mae_temp_min = results[4]  # temp_min 对应的 MAE\ntest_mae_precipitation = results[6]  # precipitation 对应的 MAE\ntest_mae_wind = results[8]  # wind 对应的 MAE\n\n# 输出评估结果\nprint(f'Test Loss (MSE): {test_loss:.4f}')\nprint(f'Test MAE for temp_max: {test_mae_temp_max:.4f}')\nprint(f'Test MAE for temp_min: {test_mae_temp_min:.4f}')\nprint(f'Test MAE for precipitation: {test_mae_precipitation:.4f}')\nprint(f'Test MAE for wind: {test_mae_wind:.4f}')\n\n# 11. 可视化训练过程\nplt.figure(figsize=(12, 6))\n\n# 绘制总体 Loss（MSE）\nplt.subplot(1, 2, 1)\nplt.plot(history.history['loss'], label='Train Loss')\nplt.plot(history.history['val_loss'], label='Val Loss')\nplt.title('Model Loss (MSE)')\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.legend()\n\n# 绘制每个输出的 MAE\nplt.subplot(1, 2, 2)\nplt.plot(history.history['temp_max_mae'], label='Train temp_max MAE')\nplt.plot(history.history['val_temp_max_mae'], label='Val temp_max MAE')\nplt.plot(history.history['temp_min_mae'], label='Train temp_min MAE')\nplt.plot(history.history['val_temp_min_mae'], label='Val temp_min MAE')\nplt.plot(history.history['precipitation_mae'], label='Train precipitation MAE')\nplt.plot(history.history['val_precipitation_mae'], label='Val precipitation MAE')\nplt.plot(history.history['wind_mae'], label='Train wind MAE')\nplt.plot(history.history['val_wind_mae'], label='Val wind MAE')\n```\n这个模型本质上执行了一个多变量回归任务，其中引入了weighted_loss函数，其通过为每个目标特征设置不同的权重，调整它们在总损失中的影响力，使得模型在训练时能够更加关注某些特征的预测准确性。这对于多目标回归任务尤为重要，特别是在特征的重要性或尺度差异较大的情况下，有助于提高模型的预测性能。\n\n模型在经过粗略调试之后输出了以下结果：\n\n![MSE和MAE指标随迭代次数变化](/images/DL/weather1.png)\n\n![预测结果与实际结果对比](/images/DL/weather2.png)\n\n可以看出对于最高气温和最低气温，模型给出了非常好的结果。这也跟GRU的特性有关，因为其能尽可能多地捕捉到变量与时间的关系。而对于那些变化和时间不呈非常明显关系的变量————比如降水量和风速————模型给出的结果并不是非常尽人意，即使这两个变量已经被添加了相当高的权重。尤其是降水量，其突变次数和趋势明显高于其他几个变量，模型也无法做出比较好的计算结果。\n\n这只是一个非常简单的应用，如果结合其他方法，预测准确度应当能达到一个比较高的值。\n","categories":["深度学习"]},{"title":"STM32中的I2C通信【24CXX EEPROM】","url":"/2024/12/07/STM32中的I2C通信【24CXX EEPROM】/","content":"## I2C简介\nI2C是由数据线SDA和时钟线SCL构成的串行总线，用于发送或接收数据。其中SDA用于传输数据。SCL用于同步时钟信号。I2C还有以下特征：\n1. 主从架构\n    - 主机（Master）：控制通信过程，生成时钟信号并启动通信\n    - 从机（Slave）：响应主机指令，按地址匹配参与通信\n2. 地址：每个从设备具有唯一的7位或10位地址，用于识别通信目标。主设备在通信开始时发送从设备地址，从设备响应后开始数据传输\n3. 半双工通信： 数据线支持双向通信，但同一时刻只允许数据单向传输\n4. 数据速率：\n    - 标准模式（Standard Mode）：最大速率100 kbps\n    - 快速模式（Fast Mode）：最大速率400 kbps\n    - 高速模式（High-Speed Mode）：最大速率3.4 Mbps\n5. 开漏设计：信号线通常采用开漏驱动，需要外部上拉电阻将信号线拉高到逻辑高电平。因此总线空闲时，SDA和DCL都为高电平。\n6. 多设备连接：可以有多个具备 IIC 通信能力的设备挂载在上面，同时支持多个主机和多个从机，连接到总线的接口数量只由总线电容 400pF 的限制决定。\n\n## I2C时序和读写操作\n### 时序信号\n![I2C总线时序图](/images/arm/i2c1.png)\n1. 起始信号：主机发出，为电平跳变信号而非恒电平信号。SCL为高电平期间，SDA由高电平跳变至低电平，总线被占用，准备数据传输\n2. 停止信号：主机发出，为电平跳变信号而非恒电平信号。SCL为高电平期间，SDA由低电平跳变至高电平，总线空闲\n3. 应答信号：发送器每发送一个字节，就在时钟脉冲 9 期间释放数据线，由接收器反馈一个应答信号。应答信号为低电平时，规定为有效应答位（ACK 简称应答位），表示接收器已经成功地接收了该字节。应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功\n4. 数据有效性：总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。数据在 SCL 的上升沿到来之前就需准备好。并在下降沿到来之前必须稳定\n5. 数据传输：总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在 SCL 串行时钟的配合下，在 SDA 上逐位地串行传送每一位数据。数据位的传输是边沿触发\n6. 空闲状态：SDA 和 SCL两条信号线同时处于高电平时，规定为总线的空闲状态。此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高\n\n### 写操作\n![I2C写操作通讯](/images/arm/i2c2.png)\n\n1. 主机发送起始信号，令总线上的所有从机等待接收数据\n2. 主机发送从机地址+'0'（写操作）组成的8位数据。从机接收到地址后，比对该地址是否为本机地址。若为本机地址，从机发送应答信号\n3. 主机向从机发送数据\n\n### 读操作\n![I2C读操作通讯](/images/arm/i2c3.png)\n\n1. 主机发送起始信号，令总线上的所有从机等待接收数据\n2. 主机发送从机地址+'1'（读操作）组成的8位数据。从机接收到地址后，比对该地址是否为本机地址。若为本机地址，从机发送应答信号\n3. 从机向主机发送数据\n\n若主机一直返回应答信号，那么从机可以一直发送数据，直到主机发送NACK信号为止。\n\n## 24C02时序\n24C02 是一个 2K bit 的串行 EEPROM 存储器，内部含有 256 个字节。在 24C02 里面还有一个 8 字节的页写缓冲器。该设备的通信方式为 IIC，通过其 SCL 和 SDA 与其他设备通信。\n\n![24C02引脚](/images/arm/24c021.png)\n\nWP为写保护引脚，高电平只读，低电平开放读写功能。24C02的设备地址共8位，包含不可编程部分和可编程部分，可编程部分根据硬件Pin A0、A1、A2决定；设备地址最后一位用于设置是读操作还是写操作。具体为：\n\n![24C02设备地址格式](/images/arm/24c022.png)\n\n本文中A0、A1、A2均接地，故24C02设备读操作地址为`0xA1`，写操作地址为`0xA0`。\n\n## 24C02读写操作\n\n![24C02写时序](/images/arm/24c023.png)\n\n主机在 IIC 总线发送第 1 个字节的数据为24C02的设备地址`0xA0`，用于寻找总线上的24C02，在获得24C02的应答信号之后，继续发送第 2 个字节数据，该字节数据是 24C02 的内存地址，再等到 24C02 的应答信号，主机继续发送第 3 字节数据，这里的数据即是写入在第 2 字节内存地址的数据。主机完成写操作后，可以发出停止信号，终止数据传输。这种写操作每次只能写入1字节数据。\n\n![24C02页写时序](/images/arm/24c024.png)\n\n写操作时，24C02可以使用页写时序，其和普通写时序的区别是页写时序只需要告知一次内存地址1，后面的数据会按照写入顺序存入内存地址2、内存地址3等，节省通信时间。\n\n![24C02读时序](/images/arm/24c025.png)\n\n24C02读取数据的过程是一个复合的时序，其中包含写时序和读时序。通常第一个通信过程为写时序，起始信号产生后，主机发送24C02设备地址`0xA0`，获取从机应答信号后，接着发送需要读取的内存地址；在随后的读时序中，起始信号产生后，主机发送24C02设备地址`0xA1`, 获取从机应答信号后，从机返回刚刚在写时序中传递的内存地址的数据，以字节为单位传输在总线上，假如主机获取数据后返回的是应答信号，那么从机会一直传输数据，当主机发出的是非应答信号并以停止信号发出为结束，从机结束传输。\n\n## 软件模拟I2C\nHAL库自带的硬件I2C函数比较复杂，多采用软件模拟I2C的方式操作GPIO以获得I2C时序。\n### custom_i2c.h（头文件）\n```\n/**\n ****************************************************************************************************\n * @file        custom_i2c.h\n * @author      Aki\n * @version     V1.0\n * @date        2024-12-11\n * @brief       软件IIC头文件\n ****************************************************************************************************\n */\n\n#ifndef __MYIIC_H\n#define __MYIIC_H\n\n#include \"sys.h\"\n\n\n/******************************************************************************************/\n/* 引脚定义 */\n\n#define IIC_SCL_GPIO_PORT               GPIOH\n#define IIC_SCL_GPIO_PIN                GPIO_PIN_4\n#define IIC_SCL_GPIO_CLK_ENABLE()       do{ __HAL_RCC_GPIOH_CLK_ENABLE(); }while(0)   /* PH口时钟使能 */\n\n#define IIC_SDA_GPIO_PORT               GPIOH\n#define IIC_SDA_GPIO_PIN                GPIO_PIN_5\n#define IIC_SDA_GPIO_CLK_ENABLE()       do{ __HAL_RCC_GPIOH_CLK_ENABLE(); }while(0)   /* PH口时钟使能 */\n\n/******************************************************************************************/\n/* IO操作 */\n\n#define IIC_SCL(x)        do{ x ? \\\n                              HAL_GPIO_WritePin(IIC_SCL_GPIO_PORT, IIC_SCL_GPIO_PIN, GPIO_PIN_SET) : \\\n                              HAL_GPIO_WritePin(IIC_SCL_GPIO_PORT, IIC_SCL_GPIO_PIN, GPIO_PIN_RESET); \\\n                          }while(0)       /* SCL */\n\n#define IIC_SDA(x)        do{ x ? \\\n                              HAL_GPIO_WritePin(IIC_SDA_GPIO_PORT, IIC_SDA_GPIO_PIN, GPIO_PIN_SET) : \\\n                              HAL_GPIO_WritePin(IIC_SDA_GPIO_PORT, IIC_SDA_GPIO_PIN, GPIO_PIN_RESET); \\\n                          }while(0)       /* SDA */\n\n#define IIC_READ_SDA     HAL_GPIO_ReadPin(IIC_SDA_GPIO_PORT, IIC_SDA_GPIO_PIN)        /* 读取SDA电平 */\n\n/******************************************************************************************/\n\nvoid iic_init(void);                        \nvoid iic_start(void);                       \nvoid iic_stop(void);                      \nvoid iic_ack(void);                        \nvoid iic_nack(void);                       \nuint8_t iic_wait_ack(void);                 \nvoid iic_send_byte(uint8_t data);          \nuint8_t iic_read_byte(unsigned char ack);   \n\n#endif\n```\n这里宏定义利用了两个小技巧：\n- 三目运算符：x ? ... : ... 是一个条件（三目）运算符。它的工作原理是：根据 x 的值（x 是一个表达式），判断执行哪一部分代码。如果 x 为 true（非零），执行冒号前的表达式；如果 x 为 false（零），执行冒号后的表达式。\n- `do { ... } while(0)`：确保宏只执行一次且不会干扰外部代码结构的惯用法。这样做可以确保宏在使用时，代码不会因缺少括号而引发语法错误。\n\n\n### custom_i2c.c\n#### 初始化\n```\n/** \n    @brief:IIC初始化\n    @param:NULL\n    @return:NULL\n**/\nvoid iic_init(void)\n{\n    GPIO_InitTypeDef gpio_init_struct;\n\n    IIC_SCL_GPIO_CLK_ENABLE();  /* SCL引脚时钟使能 */\n    IIC_SDA_GPIO_CLK_ENABLE();  /* SDA引脚时钟使能 */\n\n    /* SCL */\n    gpio_init_struct.Pin = IIC_SCL_GPIO_PIN;\n    gpio_init_struct.Mode = GPIO_MODE_OUTPUT_PP;    /* 推挽输出 */\n    gpio_init_struct.Pull = GPIO_PULLUP;            /* 上拉 */\n    gpio_init_struct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    HAL_GPIO_Init(IIC_SCL_GPIO_PORT, &gpio_init_struct);\n\n    /* SDA */\n    gpio_init_struct.Pin = IIC_SDA_GPIO_PIN;\n    gpio_init_struct.Mode = GPIO_MODE_OUTPUT_OD;    /* 开漏输出 */\n    HAL_GPIO_Init(IIC_SDA_GPIO_PORT, &gpio_init_struct);\n\n    iic_stop();     /* 停止总线上所有设备 */\n}\n```\n这里SDA线使用开漏输出，这意味着当SDA引脚输出低电平时，设备直接将线拉低（输出低电平）；而当设备输出高电平时，它并不直接将线拉高，而是将SDA引脚设置为高阻态（即不驱动该引脚。当一个设备希望发送数据时，如果它需要输出0（低电平），它会直接将SDA引脚拉低。当它需要发送1（高电平），它不会直接将SDA引脚拉高，而是让SDA引脚处于高阻态，让总线上的其他设备（如果有）通过拉高SDA线来实现高电平。这么做可以有效避免连接多个从机时发生电平冲突。STM32F429使用开漏模式时，必须外界上拉电阻。\n\n#### 延时\n```\n/** \n    @brief:IIC延时函数\n    @param:NULL\n    @return:NULL\n**/\nstatic void iic_delay(void)\n{\n    delay_us(2);    /* 读写速度在250Khz以内 */\n}\n```\n为获得稳定的读写结果，需限制读写速度，此处通过延时2us的形式实现。\n\n#### 起始信号与停止信号\n```\n/** \n    @brief:IIC起始信号\n    @param:NULL\n    @return:NULL\n**/\nvoid iic_start(void)\n{\n    IIC_SDA(1);\n    IIC_SCL(1);\n    iic_delay();\n    IIC_SDA(0);   /* START信号 */\n    iic_delay();\n    IIC_SCL(0);   /* 钳住总线，准备发送或接收数据（SCL只有低电平期间允许改变SDA状态） */\n    iic_delay();\n}\n\n\n/** \n    @brief:IIC停止信号\n    @param:NULL\n    @return:NULL\n**/\nvoid iic_stop(void)\n{\n    IIC_SDA(0);     /* STOP信号 */\n    iic_delay();\n    IIC_SCL(1);\n    iic_delay();\n    IIC_SDA(1);     /* 总线结束信号 */\n    iic_delay();\n}\n```\n![START和STOP时序](/images/arm/i2c4.png)\n\n根据IIC时序图，起始信号和停止信号分别为：\n\n- START：SCL高电平，SDA从1跳变至0\n- STOP：SCL高电平，SDA从0跳变至1\n\n上面的两个函数实现的就是这个功能，同时加入了延时来保证能得到稳定的电平。需要注意，停止信号发出时，SCL需要在SDA电平开始跳变前就保持高电平。\n\n#### 发送字节\n```\n/** \n    @brief:IIC发送一个字节\n    @param:data：要发送的数据\n    @return:NULL\n**/\nvoid iic_send_byte(uint8_t data)\n{\n    uint8_t t;\n\n    for (t = 0; t < 8; t++)\n    {\n        IIC_SDA((data & 0x80) >> 7);    /* 提取高位 */\n        iic_delay();\n        IIC_SCL(1);     /* 拉高SCL并维持高电平，开始发送 */\n        iic_delay();\n        IIC_SCL(0);     /* 发送结束，拉低SCL，准备下一位数据 */\n        data <<= 1;     /* 左移1位，循环发送 */\n    }\n    IIC_SDA(1);     /* 发送完成，释放SDA线 */\n}\n```\n![I2C发送时序](/images/arm/i2c5.png)\n\n发送字节时，由于一个时钟周期内I2C只能发送一位(bit)数据，因此发送需要循环8次，模拟8个时钟信号，才能把形参的8位数据都发送出去。也就是我们需要提取出形参的每一位并发送。这里使用了`(data & 0x80) >> 7`的方式。`(data & 0x80)`是将形参与`0x80`，也就是`10000000`进行与运算，然后右移7位，提取出形参的最高位。如果最高位是1，那么SDA就拉高；反之SDA则拉低。每个周期完成后，data左移1位，将原先是次高位的数移到最高位，重复这个过程8次。全部发送完成后，释放SDA线。\n#### 读取字节\n```\n/** \n    @brief:IIC读取一个字节\n    @param:ack: ack=1时，发送ack; ack=0时，发送nack\n    @return:接收到的数据\n**/\nuint8_t iic_read_byte(uint8_t ack)\n{\n    uint8_t i, receive = 0x00;\n\n    /* 1个字节共8位，单次接收1位，循环8次 */\n    for (i = 0; i < 8; i++)\n    {\n        receive <<= 1;      /* 输出时高位先输出，因此接收时先收到的数据是高位，要左移 */\n        IIC_SCL(1);         /* 拉高SCL，SDA准备接收 */\n        iic_delay();\n\n        if (IIC_READ_SDA)   /* 如果SDA为高电平 */\n        {\n            receive++;      /* 第0位（低位）置1 */\n        }\n\n        IIC_SCL(0);         /* 接收结束，拉低SCL */\n        iic_delay();\n    }\n\n    if (!ack)\n    {\n        iic_nack();         /* 发送nACK信号 */\n    }\n    else\n    {\n        iic_ack();          /* 发送ACK信号 */\n    }\n\n    return receive;\n}\n```\n在时序方面，I2C读取字节和写入字节是一致的。\n\n#### 应答信号（ACK）\n```\n/** \n    @brief:等待应答信号\n    @param:NULL\n    @return:1=失败；0=成功\n**/\nuint8_t iic_wait_ack(void)\n{\n    uint8_t waittime = 0;\n    uint8_t rack = 0;\n\n    IIC_SDA(1);     /* 主机释放SDA（外部器件此时可拉低SDA电平） */\n    iic_delay();\n    IIC_SCL(1);     /* 拉高SCL，从机此时可返回ACK */\n    iic_delay();\n\n    while (IIC_READ_SDA)    /* 等待应答 */\n    {\n        waittime++;\n\n        if (waittime > 250)\n        {\n            iic_stop();\n            rack = 1;\n            break;\n        }\n    }\n\n    IIC_SCL(0);     /* SCL=0，结束ACK检查 */\n    iic_delay();\n    return rack;\n}\n```\n等待应答信号一般用在写时序中，在`iic_send_byte`后调用。当读取到SDA为低电平时，表示ACK信号；SDA为高电平则为NACK信号。若等待超时，则主机会直接发出停止信号。若正常接收到ACK信号，主机拉低SCL线，返回flag。这一段内容对应总线时序图中的红圈3，也就是脉冲9。\n```\n/** \n    @brief:产生ACK应答\n    @param:NULL\n    @return:NULL\n    @note：ACK应答时，SDA拉低，SCL=0->1->0\n**/\nvoid iic_ack(void)\n{\n    IIC_SDA(0);     \n    iic_delay();\n    IIC_SCL(1);     \n    iic_delay();\n    IIC_SCL(0);     \n    iic_delay();\n    IIC_SDA(1);     \n    iic_delay();\n}\n\n/** \n    @brief:不产生ACK应答（NACK）\n    @param:NULL\n    @return:NULL\n    @note：NACK应答时，SDA拉高，SCL=0->1->0\n**/\nvoid iic_nack(void)\n{\n    IIC_SDA(1);\n    iic_delay();\n    IIC_SCL(1);\n    iic_delay();\n    IIC_SCL(0);\n    iic_delay();\n}\n```\n以上两个函数用于主机作为接收端时，在接收完数据后向从机返回ACK或NACK信号。二者对应的也是线时序图中的红圈3，也就是脉冲9。\n\n## 24CXX EEPROM 驱动\n### 写操作\n```\n/**\n* @brief 向 AT24CXX 指定地址写入一个数据\n* @param addr: 写入数据的目的地址\n* @param data: 要写入的数据\n* @retval 无\n*/\nvoid at24cxx_write_one_byte(uint16_t addr, uint8_t data)\n{\n    iic_start();       /* IIC起始信号 */\n\n    if (EE_TYPE > AT24C16)  /* 容量大于24C16时分2个字节发送目标内存地址 */\n    {\n        iic_send_byte(0xA0);    /* 发送写命令，从机设备地址为0xA0，最低位为0表示写入 */\n        iic_wait_ack();         /* 发送完一个字节后等待ACK */\n        iic_send_byte(addr >> 8);   /* 发送高位内存地址 */\n    }\n    else\n    {\n        iic_send_byte(0xA0 + ((addr >> 8) << 1));   /* 发送器件0xA0 + 高位a8/a9/a10地址，写数据 */\n    }\n\n    iic_wait_ack();\n    iic_send_byte(addr % 256);  /* 发送低位内存地址 */\n    iic_wait_ack();\n\n    iic_send_byte(data);    /* 发送1个字节 */\n    iic_wait_ack();\n    iic_stop();\n    delay_ms(10);       /* EEPROM写入速度慢，必须等待写入完成再写下一个 */\n}\n```\n24CXX的写操作主要包含三个步骤：写入设备地址，写入目标内存地址，写入待传输数据。设备地址之前已经介绍过，高7位为固定地址，低1位为`'0'`时表示写操作。\n- 若EEPROM容量大于24C16，比如24C32和24C64，EEPROM总的字节数分别为4096和8192，对应寻址线为12根和13根，即内存地址是12位和13位的，显然发送内存地址时就需要分高字节和低字节两次发送。\n- 若EEPROM容量小于或等于24C16，则寻址线最多为11根，内存地址最多是11位的。通过`iic_send_byte(0xA0 + ((addr >> 8) << 1))`，可以让主机下发读写命令时自带3位高地址，剩下的8位地址只需要合在一起在低位发送即可，也就是`iic_send_byte(addr % 256)`。\n\n这种设备地址低位和内存地址高位相结合的设计可以看作是EEPROM和独特设计，用来节省资源。\n\n### 读操作\n```\n/**\n* @brief 在 AT24CXX 指定地址写入一个数据\n* @param addr: 写入数据的目的地址\n* @param data: 要写入的数据\n* @retval 无\n*/\nuint8_t at24cxx_read_one_byte(uint16_t addr)\n{\n    uint8_t temp = 0;\n    iic_start();\n\n    /* 根据不同的 24CXX 型号, 发送高位地址\n    * 1, 24C16 以上的型号, 分 2 个字节发送地址\n    * 2, 24C16 及以下的型号, 分 1 个低字节地址 + 占用器件地址的 bit1 ~ bit3 位\n    * 用于表示高位地址, 最多 11 位地址\n    * 对于 24C01/02, 其器件地址格式(8bit)为: 1 0 1 0 A2 A1 A0 R/W\n    * 对于 24C04, 其器件地址格式(8bit)为: 1 0 1 0 A2 A1 a8 R/W\n    * 对于 24C08, 其器件地址格式(8bit)为: 1 0 1 0 A2 a9 a8 R/W\n    * 对于 24C16, 其器件地址格式(8bit)为: 1 0 1 0 a10 a9 a8 R/W\n    * R/W : 读/写控制位 0,表示写; 1,表示读;\n    * A0/A1/A2 : 对应器件的 1,2,3 引脚(只有 24C01/02/04/8 有这些脚)\n    * a8/a9/a10: 对应存储整列的高位地址, 11bit 地址最多可以表示 2048 个位置,\n    * 可以寻址 24C16 及以内的型号\n    */\n\n   if (EE_TYPE > AT24C16)       /* 24C16以上型号分2个字节发送地址 */\n   {\n        iic_send_byte(0xA0);    /* 最低位为0，表示写入*/\n        iic_wait_ack();         /* 发送完一个字节后等待ACK信号 */\n        iic_send_byte(addr >> 8);       /* 发送高字节地址 */\n   }\n   else\n   {\n        /* 发送器件0xA0 + 高位a8/a9/a10地址，写数据 */\n        iic_send_byte(0xA0 + ((addr >> 8) << 1));\n   }\n\n   iic_wait_ack();\n   iic_send_byte(addr % 256);       /* 发送低位地址*/\n   iic_wait_ack();\n\n   iic_start();                     /* 重新发送起始信号*/\n   iic_send_byte(0xA1);             /* 进入接收模式，最低位为1，表示读取*/\n   iic_wait_ack();\n   temp = iic_read_byte(0);         /* 接收一个字节数据 */\n   iic_stop();\n\n   return temp;\n}\n```\n`iic_send_byte(addr % 256)`用来提取内存地址的低8位。也可以用`addr &= 0x00FF`来代替。\n\n### 检测工作状态\n```\n/**\n* @brief 检查 AT24CXX 是否正常\n* @note 检测原理: 在器件的末地址写入 0X55, 然后再读取, \n* 如果读取值为 0X55 则表示检测正常. 否则,则表示检测失败.\n* @param 无\n* @retval 检测结果\n* 0: 检测成功\n* 1: 检测失败\n*/\nuint8_t at24cxx_check(void)\n{\n    uint8_t temp;\n    uint16_t addr = EE_TYPE;                /* 目标内存地址为EEPROM末地址 */\n    temp = at24cxx_read_one_byte(addr);     /* 避免每次开机都写入*/\n\n    if (temp == 0x55)                       /* 读取数据正常 */\n    {\n        return 0;\n    }\n    else                                    /* 第一次初始化时 */\n    {\n        at24cxx_write_one_byte(addr, 0x55); /* 先写入 */\n        temp = at24cxx_read_one_byte(255);  /* 再读取 */\n        if (temp == 0x55) return 0;\n    }\n\n    return 1;\n}\n```\n这种操作和RTC实验很类似，利用EEPROM掉电后内存不丢失的特性，固定在第一次写入时于内存末地址写入`0x55`，然后再去读一下看看是否写入成功，以此来检测芯片是否正常工作。\n\n\n## 应用\n实现一个简单的应用：按下KEY1，向EEPROM的首地址写入字符串，写入成功串口打印“write ok”；按下KEY0，读取EEPROM首地址内容，串口打印读取结果\n\n```\n/* USER CODE BEGIN 2 */\n  while (at24cxx_check())\n  {\n    led_red_toggle();\n    delay_ms(500);\n  }\n  /* USER CODE END 2 */\n\n/* USER CODE BEGIN WHILE */\n  while (1)\n  {\n    /* USER CODE END WHILE */\n\n    /* USER CODE BEGIN 3 */\n    uint8_t key;\n    uint8_t writeok[] = \"write ok\\n\";\n    uint8_t txbuf[] = \"mua\\n\";\n    uint8_t rxbuf[5];\n    uint8_t readok[15];\n\n    key = key_scan(0);\n\n    if (key == KEY1_pressed)    /* 如果KEY1被按下 */\n    {\n      at24cxx_write(0, txbuf, sizeof(txbuf));\n      HAL_UART_Transmit_IT(&huart1, writeok, sizeof(writeok));\n      delay_ms(50);\n    }\n\n    if (key == KEY0_pressed)    /* 如果KEY0被按下 */\n    {\n      at24cxx_read(0, rxbuf, sizeof(txbuf));\n      //sprintf(readok, \"result is %d\\n\", rxbuf[0]);\n      HAL_UART_Transmit_IT(&huart1, rxbuf, sizeof(rxbuf));\n    }\n\n    led_green(1);\n    delay_ms(10);\n  }\n  /* USER CODE END 3 */\n``` \n![串口打印结果](/images/arm/24c026.png)\n\n[Github项目地址](https://github.com/AkiChen891/STM32F429-24C02-EEPROM-TEST)\n\n## 小结\n总的来说，通过I2C操作EEPROM时的要点有：\n- 写入时：先写入设备地址+写操作指示符，然后写入目标内存地址，最后写入待写入数据\n- 读出时：起始信号，先写入设备地址+写操作指示符，从机ACK后写入目标内存地址；然后重新发出起始信号（**因为需要从写模式切换到读模式**），写入设备地址+读操作指示符，从机ACK后读出待读数据。读取完毕后，主机发送NACK，提示从机读取结束","categories":["嵌入式（裸机开发）"]},{"title":"STM32F4 内部温度传感器（Internal Temperature Sensor）","url":"/2024/12/04/STM32内部温度传感器采集/","content":"STM32F4系列MCU内置有温度传感器，用于采集片内温度，其绑定在ADC1的IN18通道，CubeMX中显示为\"Temperature sensor channel\"。\n\n## ADC配置\nADC的结构体`hadc1`配置如下：\n```\n  hadc1.Instance = ADC1;\n  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;\n  hadc1.Init.Resolution = ADC_RESOLUTION_12B;\n  hadc1.Init.ScanConvMode = DISABLE;\n  hadc1.Init.ContinuousConvMode = DISABLE;\n  hadc1.Init.DiscontinuousConvMode = DISABLE;\n  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;\n  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;\n  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;\n  hadc1.Init.NbrOfConversion = 1;\n  hadc1.Init.DMAContinuousRequests = DISABLE;\n  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;\n```\n- `ClockPrescaler`：预分频系数，默认为`PCLK2 / 4`，此例为`90 / 4 = 22.5`MHz\n- `Resolution`：ADC分辨率，可选有 12 位、10 位、8 位和 6 位。分辨率越高，转换数据精度越高，转换时间也越长；反之分辨率越低，转换数据精度越低，转换时间也越\n短。\n- `ScanConvMode`：是否使用扫描。多通道启用，单通道禁用。\n- `ContinuousConvMode`：启用为自动连续转换，禁用为单次转换。如果设置为单次转换，那么每次转换后都要人工介入才能开启新的转换\n- `DiscontinuousConvMode`：配置是否使用不连续的采样模式。该参数只有在`ScanConvMode`启用，且`ContinuousConvMode`关闭的情况下才有效\n- `ExternalTrigConv`：外部触发方式选择。若为软件触发则外部触发会关闭。\n- `ExternalTrigConvEdge`：外部触发极性选择（禁止触发检测、上升沿检测、下降沿检测或均可）\n- `DataAlign`：数据对齐方式，默认右对齐\n- `NbrOfConversion`：常规转换通道数目，范围1~16\n- `DMAContinuousRequests`：指定DMA请求是否以一次性模式执行（达到转换次数时DMA传输停止）或在连续模式下执行（DMA传输无限制，无论转换数量如何）。在连续模式下执行时，DMA必须配置在循环（Circular）模式，否则DMA传输缓冲区被填满时将发生溢出。\n- `EOCSelection`：指定转换结束后是否产生EOS中断或事件参数\n\nSTM32F429的ADC总转换时间可以通过下式计算：\n\n$$\nT_{conversion} = T_{sampling} + 12 \\times T_{adc}\n$$\n\n对于每个ADC通道，采样时间可以通过ADC_SMPR1（用于通道10-18）或ADC_SMPR2（用于通道0-9）寄存器的相应位来配置。例如，通道0的采样时间是通过ADC_SMPR2的SMPR2[2:0]位设置。采样时间也可在`adc.c`中用代码定义，通常默认为3个ADC周期（SMP=000），可获得最快的采样速度：\n```\n /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.\n  */\n  sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;\n  sConfig.Rank = 1;\n  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;\n```\n\n12个周期由ADC输入时钟ADC_CLK决定，其由APB2（ 即PCLK2）分频产生，在`ClockPrescaler`中可修改。\n\n若采样时间为3个ADC周期，则ADC转换总时间为15个ADC周期，APB2时钟频率为90MHz，PCLK2/4分频后为22.5MHz，那么转换时间就是0.6667us。\n\n## DMA配置\n启用DMA2，ADC1转换后的原始数据存储到16位缓冲区Rx_Buf中。由于ADC分辨率为12位，即采回的数据为12位，正好能够被16位缓冲区存下，便于后续观察和管理内存中的采样值。如果用32位缓冲区，一个区域会存两个采样值，不方便查看和后续的转换。\n\n## 采样\nADC直接采样会存在跳变或抖动，通常需要进行一定的软件滤波，最常见的方法是简单平均法。\n```\n/*\n    @ brief:ADC采样并取平均\n    @ param:times:平均次数\n    @ return:计算得到的平均值\n*/\nuint16_t adc1_get_average_value(uint8_t times)\n{\n  uint16_t temp_value = 0;\n  uint8_t t;\n\n  /* ADC 配置在单次模式，每次采样都需要手动重启ADC服务 */\n  HAL_ADC_Start_DMA(&hadc1, (uint32_t *) Rx_Buf, Rx_Buf_Size);  //强制转换Rx_Buf为32位以满足形参限制\n\n  /* 采样值取平均 */\n  for (t = 0; t < times; t++)\n  {\n    temp_value = temp_value + HAL_ADC_GetValue(&hadc1);\n    HAL_Delay(5);\n  }\n\n  /* 返回平均值 */\n  return temp_value / times;\n}\n```\n因分辨率为12位，ADC每次采样返回的数值即为12位无符号整型（十进制0~4095）。DMA将会传输每一次的采样值至缓冲区，为了能够更好的查看每一次返回的数值，该例程事先将缓冲区定义成了uint16_t类型，这样缓冲区数组的每一个单元正好能够存下一个采样值。在调用ADC采样函数时，只需要将其声明为uint32_t类型指针，这样DMA会按4个字节（32位）来传输数据。DMA本身并不关心传输的采样值到底是几位的，他只会读取4个字节的数据然后传递至内存，因此，每两个 uint16_t 数据（即 2 个采样值）会合并成一个 uint32_t，在内存中形成连续的数据块。\n\n以此类推，如果采样值为8位(uint8_t)，那么DMA每次将会打包4个采样值为一个uint32_t数值传回同样定义为uint8_t的缓冲区然后解包，缓冲区中的每个单元都显示一个采样值。\n\n然后进行温度的读取。温度传感器换算公式为（单位为摄氏度）：\n$$\nT = ((V_{sense}-V_{25})/AvgSlope) + 25\n$$\n式中参数取典型值，有$V_{25}=0.76$，$AvgSlope = 2.5mv/℃$\n采集温度：\n```\n/*\n    @ brief:采集温度\n    @ param:NULL\n    @ return:温度值（short）\n*/\ndouble read_temperature(void)\n{\n  uint16_t adc_value;\n  double temperature; //返回温度为双精度值\n\n  adc_value = adc1_get_average_value(10);\n\n  temperature = ((float)adc_value * 3.3 / 4096.0 - 0.76) / 0.0025 + 25.0;\n\n  return temperature;\n}\n```\n\n`main.c`：\n```\n  ic_temp = read_temperature();\n\n  uint8_t txbuf[15];\n  sprintf(txbuf, \"temp is: %.2f\\n\", ic_temp); //转换为字符串\n\n  HAL_UART_Transmit(&huart1, (uint8_t *)txbuf, strlen(txbuf), 0xFFFF);  //串口轮询发送温度值\n```\n\n## 结果\n![上位机接收](/images/arm/temp1.png)\n\n![内存监视结果](/images/arm/temp2.png)","categories":["嵌入式（裸机开发）"]},{"title":"STM32 UART在循环DMA模式下接收大量不定字长数据并进行乒乓缓存","url":"/2024/11/25/STM32 UART接收不固定字节数据/","content":"串口(uart)是一种低速的串行异步通信，适用于低速通信场景，通常使用的波特率小于或等于115200bps。\n\n对于小于或者等于115200bps波特率的，而且数据量不大的通信场景，一般没必要使用DMA，或者说使用DMA并未能充分发挥出DMA的作用。\n\n对于数量大，或者波特率提高时，必须使用DMA以释放CPU资源，因为高波特率可能带来这样的问题：\n\n+ 对于发送，使用循环发送，可能阻塞线程，需要消耗大量CPU资源“搬运”数据，浪费CPU\n\n+ 对于发送，使用中断发送，不会阻塞线程，但需浪费大量中断资源，CPU频繁响应中断；以115200bps波特率，1s传输11520字节，大约69us需响应一次中断，如波特率再提高，将消耗更多CPU资源\n\n+ 对于接收，如仍采用传统的中断模式接收，同样会因为频繁中断导致消耗大量CPU资源\n因此，高波特率场景下，串口非常有必要使用DMA。\n## 中断轮询模式(IT)\n使用`HAL_UARTEx_ReceiveToIdle_IT`函数，该函数会持续接收数据，直到缓冲区溢出或触发空闲事件。\n```\n/**\n  * @brief Receive an amount of data in interrupt mode till either the expected number of data is received or an IDLE event occurs.\n  * @note   Reception is initiated by this function call. Further progress of reception is achieved thanks\n  *         to UART interrupts raised by RXNE and IDLE events. Callback is called at end of reception indicating\n  *         number of received data elements.\n  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M = 01),\n  *         the received data is handled as a set of uint16_t. In this case, Size must indicate the number\n  *         of uint16_t available through pData.\n  * @param huart UART handle.\n  * @param pData Pointer to data buffer (uint8_t or uint16_t data elements).\n  * @param Size  Amount of data elements (uint8_t or uint16_t) to be received.\n  * @retval HAL status\n  */\nHAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)\n{\n  HAL_StatusTypeDef status;\n\n  /* 检查没有正在进行的接收过程 */\n  if (huart->RxState == HAL_UART_STATE_READY)\n  {\n    if ((pData == NULL) || (Size == 0U))\n    {\n      return HAL_ERROR;\n    }\n\n    /* 接收数据，直到空闲事件发生*/\n    huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;\n    huart->RxEventType = HAL_UART_RXEVENT_TC;\n\n    status =  UART_Start_Receive_IT(huart, pData, Size);\n\n    /* 检查接收是否成功开始 */\n    if (status == HAL_OK)\n    {\n      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\n      {\n        __HAL_UART_CLEAR_IDLEFLAG(huart);\n        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);\n      }\n      else\n      {\n        /* 如果在开始接收时已有错误待处理，则可能已引发中断并导致接收中止 */\n        status = HAL_ERROR;\n      }\n    }\n\n    return status;\n  }\n  else\n  {\n    return HAL_BUSY;\n  }\n}\n```\n\n### main.c\n```\n  /* USER CODE BEGIN 2 */\n  HAL_UARTEx_ReceiveToIdle_IT(&huart1, (uint8_t *)RxBuffer, RX_BUFFER_SIZE);\n  \n  /* USER CODE END 2 */\n```\n\n### usart.c\n每次接收完数据（指溢出或空闲后）进入该回调，将缓冲区数据传回上位机，然后重新准备下一次接收\n```\n/* USER CODE BEGIN 1 */\nvoid HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)\n{\n  //uint16_t index = Size;\n  //HAL_UARTEx_ReceiveToIdle_IT(&huart1, (uint8_t *)RxBuffer, RX_BUFFER_SIZE);\n  HAL_UART_Transmit_IT(&huart1, (uint8_t *)RxBuffer, sizeof(RxBuffer));\n  HAL_UARTEx_ReceiveToIdle_IT(&huart1, (uint8_t *)RxBuffer, RX_BUFFER_SIZE);\n}\n/* USER CODE END 1 */\n```\n\n## DMA模式（少量数据）\nDMA绕过CPU进行数据传输（外设-内存），因此可以节省CPU资源。DMA分为正常（Normal）模式和循环(Circular)模式，一般大规模数据传输时使用循环模式。\n使用` HAL_UARTEx_ReceiveToIdle_DMA`函数，仅需在最开始调用一次。当接收完成（达到指定字节数）或触发Idle事件时接收停止。每次接收事件完成后触发`HAL_UARTEx_RxEventCallback`中断回调。\n\n应用要求：输入一段文字，若MCU成功接收则回复“Wilco”。\n### main.c \n在loop前调用一次以启动接收：\n```\nHAL_UARTEx_ReceiveToIdle_DMA(&huart1, (uint8_t *)RxBuffer, RX_BUFFER_SIZE);\n```\n### usart.c\n```\n/* USER CODE BEGIN 1 */\nint count = 0;  //接收次数\nuint16_t index = 0; //接收数据量\nuint8_t Wilco[] = \"wilco\\n\";  //发送缓冲区\n\n/*\n  @name: UART接收中断回调函数\n*/\nvoid HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)\n{\n  index = Size;\n  count++;\n  HAL_UART_Transmit_IT(&huart1, (uint8_t *)Wilco, sizeof(Wilco));   //中断轮询发送以免DMA冲突\n/*   for (int i = 0; i < RX_BUFFER_SIZE; i++) \n  {\n    RxBuffer[i] = 0;  // 清空接收缓冲区（可选）\n  } */\n  HAL_UARTEx_ReceiveToIdle_DMA(&huart1, (uint8_t *)RxBuffer, RX_BUFFER_SIZE); //重新开启接收\n}\n/* USER CODE END 1 */\n```\n![](/images/arm/dma1.png)\n\n## DMA模式（大量数据）与乒乓缓存\n*参考文献*：\n\n[一个严谨的STM32串口DMA发送&接收（1.5Mbps波特率）机制](https://www.eet-china.com/mp/a28491.html)\n\n[STM32 HAL 库实现乒乓缓存加空闲中断的串口 DMA 收发机制，轻松跑上 2M 波特率](https://openatomworkshop.csdn.net/6744016a3a01316874d7817c.html?dp_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6OTAzMTMsImV4cCI6MTczMzczMzA5MywiaWF0IjoxNzMzMTI4MjkzLCJ1c2VybmFtZSI6Im0wXzUxMTQ5NzUyIn0.iiWrRqQwXcnrR4HqKAlmtbAKIr9u0HJiBW-IMTE2tQ0&spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7Ebaidujs_baidulandingword%7Eactivity-1-131576165-blog-110628262.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7Ebaidujs_baidulandingword%7Eactivity-1-131576165-blog-110628262.235%5Ev43%5Epc_blog_bottom_relevance_base1&utm_relevant_index=2)\n\n[MaJerla(Github)](https://github.com/MaJerle/stm32-usart-uart-dma-rx-tx)\n\nDMA在循环模式下工作时，如果在大规模传输数据时仍旧空闲中断（或传输完成中断）会有风险，因为当DMA传输数据完成，CPU介入开始拷贝DMA通道缓冲区数据时，如果此时UART继续有数据进来，DMA继续搬运数据到缓冲区，就有可能将数据覆盖，因为DMA数据搬运是不受CPU控制的，即使你关闭了CPU中断。\n\n因此严谨的做法需要建立双buffer，CPU和DMA各自使用一块内存交替访问，即**乒乓缓存**，处理流程为：\n\n1. DMA先将数据搬运到buf1，搬运完成通知CPU来拷贝buf1数据\n2. DMA将数据搬运到buf2，与CPU拷贝buf1数据不会冲突\n3. buf2数据搬运完成，通知CPU来拷贝buf2数据\n4. DMA继续开始拷贝新数据\n\nSTM32大多数型号不提供现成的双缓存机制，但提供“半满中断”，即数据搬运到buf大小的一半时，可以产生一个中断信号。基于这个机制，我们可以实现双缓存功能，只需将buf空间开辟大一点即可。\n\n1. DMA将数据搬运完成buf的前一半时，触发“半满中断”事件，Callback中通知CPU来拷贝buf前半部分数据\n2. DMA继续将数据搬运到buf的后半部分，与CPU拷贝buf前半部数据不会冲突\n3. buf后半部分数据搬运完成，触发“溢满中断”，Callback通知CPU来拷贝buf后半部分数据\n4. DMA循环拷贝新数据\n\n基于上述描述机制，DMA方式接收串口数据，有三种中断场景需要CPU去将buf数据拷贝到final中，分别是：\n\n- DMA通道buf溢满（传输完成）场景，触发满溢中断（`HAL_UARTEx_RxEventCallback`）\n- DMA通道buf半满场景，触发半满中断（`HAL_UART_RxHalfCpltCallback`）\n- 串口空闲中断场景，触发空闲中断（`UART_FLAG_IDLE`）\n\n![三种中断事件场景](/images/arm/rxhalf.png)\n\n![数据处理流程图](/images/arm/rxhalf1.png)\n\n也就是说，代码总共需要考虑以下几种情况：\n1. 数据量未达到半满，触发**空闲中断**\n2. 数据量达到半满，未达到满溢，先触发**半满中断**，后触发**空闲中断**\n3. 数据量刚好达到满溢，先触发**半满中断**，后触发**满溢中断**\n4. 数据量大于缓冲区长度，DMA循环覆盖溢出的字节\n\n对于情况1：在空闲中断中拷贝全部数据\n\n对于情况2：在半满中断中通知CPU拷贝一半的数据，DMA继续接收剩下的数据，最后在空闲中断中拷贝剩下的数据\n\n对于情况3：在半满中断中通知CPU拷贝一半的数据，DMA继续接收剩下的数据，最后在满溢中断中拷贝剩下的一半数据\n\n对于情况4：综合处理\n\n下面这个代码经过试验不太好使，空闲中断和满溢中断似乎有冲突，导致接收完成后MCU进不去满溢中断。\n```\n  /* USER CODE BEGIN USART1_IRQn 0 */\n  if (__HAL_UART_GET_FLAG(&huart1, UART_FLAG_IDLE))\n  {\n    __HAL_UART_CLEAR_FLAG(&huart1, UART_FLAG_IDLE);\n    HAL_UART_DMAStop(&huart1);\n    uint32_t temp = RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(&hdma_usart1_rx);  //已接收的数据大小\n\n    if (temp != 0)\n    //如果接收到了数据\n    {\n      uint8_t txbuffer[] = \"rx ok in idle IT\\n\";\n      HAL_UART_Transmit(&huart1, txbuffer, sizeof(txbuffer), 0xFFFF);\n\n      if (rx_half_flag == 0)\n      //如果半满中断尚未触发过（前半段）\n      {\n        for (int i = 0; i < temp; i++)\n        {\n          RX_final[final_index] = Rx_buffer[i];\n          final_index++;\n          HAL_UART_Receive_DMA(&huart1, Rx_buffer, RX_BUFFER_SIZE - temp);\n        }\n      }\n      else if (rx_half_flag)\n      //如果半满中断已触发过（后半段）\n      {\n        uint32_t temp_size = RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(&hdma_usart1_rx) - RX_BUFFER_SIZE / 2;\n        for (int i = RX_BUFFER_SIZE / 2; i < RX_BUFFER_SIZE / 2 + temp_size; i++)\n        {\n          RX_final[final_index] = Rx_buffer[i];\n          final_index++;\n        }\n        HAL_UART_Receive_DMA(&huart1, Rx_buffer, RX_BUFFER_SIZE/2 - temp_size);\n      }\n    }\n    else if (temp == RX_BUFFER_SIZE)\n    {\n      HAL_UART_Receive_DMA(&huart1, Rx_buffer, RX_BUFFER_SIZE);\n    }\n  }\n  ```\n  ```\n  /* USER CODE BEGIN 1 */\nvoid HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)\n{\n  if (huart->Instance == USART1)\n  {\n    rx_half_flag = 1;\n    \n    uint8_t sendbuffer[] = \"rxhalf IT\\n\";\n    HAL_UART_Transmit(&huart1, (uint8_t *)sendbuffer, sizeof(sendbuffer), 0xFFFF);\n\n    for (int i = 0; i < RX_BUFFER_SIZE / 2; i++)\n    {\n      RX_final[final_index] = Rx_buffer[i];\n      final_index++;\n    }\n\n    HAL_UART_Receive_DMA(&huart1, (uint8_t *) Rx_buffer, RX_BUFFER_SIZE / 2);\n  }\n}\n\nvoid HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)\n{\n  if (huart->Instance == USART1)\n  {\n    uint8_t sendbuffer[] = \"rx ok\\n\";\n    HAL_UART_Transmit(&huart1, (uint8_t *)sendbuffer, sizeof(sendbuffer), 0xFFFF);\n\n    for (int i = RX_BUFFER_SIZE / 2; i < RX_BUFFER_SIZE; i++)\n    {\n      RX_final[final_index] = Rx_buffer[i];\n      final_index++;\n    }\n\n    rx_half_flag = 0;\n  }\n  HAL_UART_Receive_DMA(&huart1, (uint8_t *) Rx_buffer, RX_BUFFER_SIZE);\n}\n/* USER CODE END 1 */\n```\n继续调试，删掉除打印测试信息以外的所有功能性代码：\n```\n  /* USER CODE BEGIN USART1_IRQn 0 */\n  uint32_t temp_size = 0;\n  if (__HAL_UART_GET_FLAG(&huart1, UART_FLAG_IDLE))\n  {\n    __HAL_UART_CLEAR_IDLEFLAG(&huart1);\n    HAL_UART_DMAStop(&huart1);\n    temp_size = RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(&hdma_usart1_rx);  //已接收数据长度\n\n    if (temp_size != 0)\n    {\n      uint8_t txbuf3[] = \"rxidle\\n\";\n      HAL_UART_Transmit(&huart1, txbuf3, sizeof(txbuf3), 0xFFFF);\n      \n    }\n  }\n  /* USER CODE END USART1_IRQn 0 */\n\n  /* USER CODE BEGIN 1 */\nvoid HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)\n{\n  if (huart->Instance == USART1)\n  {\n    uint8_t txbuf1[] = \"rxhalf\\n\";\n    HAL_UART_Transmit(&huart1, txbuf1, sizeof(txbuf1), 0xFFFF);\n  }\n}\n\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n{\n  if (huart->Instance == USART1)\n  {\n    uint8_t txbuf2[] = \"rxfull\\n\";\n    HAL_UART_Transmit(&huart1, txbuf2, sizeof(txbuf2), 0xFFFF);\n  }\n}\n/* USER CODE END 1 */\n\n```\n正常情况下，接收缓冲区大小为10，当发送“12”（实际为\"12\\r\\n“四个字节）时，应只触发空闲中断；发送“123”时，触发半满中断和空闲中断；发送“12345678”时，触发半满中断和满溢中断。但测试发现，发送“12345678”共计十个字节数据，也就是预期接收数据大小等于缓冲区大小时，只能触发一次半满中断，满溢中断无法触发。若禁用空闲中断，发送“12345678”时，半满中断和溢满中断都能触发，初步判断是空闲中断的问题。\n\n由于DMA配置在循环模式，当接收数据大小等于缓冲区大小时，RX总线仍会处于空闲状态，因为即将到来的新的数据会覆盖掉环形队列的第一项，因此实际上NVIC会先触发空闲中断，而空闲中断中有这一段代码：\n```\n    temp_size = RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(&hdma_usart1_rx);  //已接收数据长度\n\n    if (temp_size != 0)\n    {\n      uint8_t txbuf3[] = \"rxidle\\n\";\n      HAL_UART_Transmit(&huart1, txbuf3, sizeof(txbuf3), 0xFFFF);\n    }\n```\n当接收数据大小等于缓冲区大小时，`temp_size`实际上等于0，导致程序在空闲中断中直接跳过了满溢判断，开始下一次接收。因此需要单独对`temp_size == 0`这种情况进行处理：\n```\n  /* USER CODE BEGIN USART1_IRQn 0 */\n  uint32_t temp_size = 0;\n  if (__HAL_UART_GET_FLAG(&huart1, UART_FLAG_IDLE))\n  {\n    temp_size = RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(&hdma_usart1_rx); \n    idle_flag = 1;\n    __HAL_UART_CLEAR_IDLEFLAG(&huart1);\n    if (temp_size == 0) //满溢\n    {\n       //满溢回调\n    }\n    else if (temp_size != 0)  //非满溢\n    {\n      HAL_UART_DMAStop(&huart1);\n      uint8_t txbuf3[] = \"rxidle\\n\";\n      HAL_UART_Transmit(&huart1, txbuf3, sizeof(txbuf3), 0xFFFF);\n      HAL_UART_Receive_DMA(&huart1, Rx_buffer, RX_BUFFER_SIZE);\n    }\n  }\n  /* USER CODE END USART1_IRQn 0 */\n```\n这样，空闲中断在数据填满缓冲区时不会进行任何操作而直接跳出。只有当数据未填满缓冲区时才会进行原先的操作（主要是DMAStop这一步）。到这里，三个中断触发的逻辑总算是理顺了，接下来只需要进行搬运数据的处理就可以了。\n\n`usart.c`：\n```\n/* USER CODE BEGIN 1 */\nvoid HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)\n{\n  if (huart->Instance == USART1)\n  {\n    Rx_half_flag = 1; //半满标记\n    uint8_t txbuf1[] = \"rxhalf\\n\";\n    HAL_UART_Transmit(&huart1, txbuf1, sizeof(txbuf1), 0xFFFF);\n\n    Rx_buffer_head = Rx_buffer_tail;\n    Rx_buffer_tail = RX_BUFFER_SIZE / 2 - 1;\n\n    for (int i = Rx_buffer_head; i <= Rx_buffer_tail; i++)\n    {\n      Rx_final[Rx_final_index] = Rx_buffer[i];\n      Rx_final_index++;\n    }\n    \n  }\n}\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n{\n  if (huart->Instance == USART1)\n  {\n    Rx_half_flag = 0; //清除半满标记\n\n    uint8_t txbuf2[] = \"rxfull\\n\";\n    HAL_UART_Transmit(&huart1, txbuf2, sizeof(txbuf2), 0xFFFF);\n\n    Rx_buffer_head = Rx_buffer_tail + 1;\n    Rx_buffer_tail = RX_BUFFER_SIZE - 1;\n\n    for (int i = Rx_buffer_head; i <= Rx_buffer_tail; i++)\n    {\n      Rx_final[Rx_final_index] = Rx_buffer[i];\n      Rx_final_index++;\n    }\n  }\n}\n/* USER CODE END 1 */\n```\n\n中断服务函数：\n```\n/* USER CODE BEGIN USART1_IRQn 0 */\n  uint32_t temp_size = 0;\n  if (__HAL_UART_GET_FLAG(&huart1, UART_FLAG_IDLE))\n  {\n    temp_size = RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(&hdma_usart1_rx); //本次接收到的数据大小\n    //idle_flag = 1;\n    __HAL_UART_CLEAR_IDLEFLAG(&huart1); //清除Idle标记\n    if (temp_size == 0) //满溢\n    {\n       //满溢回调\n    }\n    else if (temp_size != 0)  //非满 ??\n    {\n      HAL_UART_DMAStop(&huart1);\n      \n      uint8_t txbuf3[] = \"rxidle\\n\";\n      HAL_UART_Transmit(&huart1, txbuf3, sizeof(txbuf3), 0xFFFF);\n\n      if (Rx_half_flag == 0)  //未半满，前半段触发空闲\n      {\n        Rx_buffer_head = Rx_buffer_tail;  \n        Rx_buffer_tail = Rx_buffer_tail + temp_size - 1; \n\n        //拷贝数据\n        for (int i = Rx_buffer_head; i <= Rx_buffer_tail; i++)\n        {\n          Rx_final[Rx_final_index] = Rx_buffer[i];\n          Rx_final_index++;\n        }  \n      }\n      else if (Rx_half_flag != 0) //已半满，后半段触发空闲\n      {\n        Rx_buffer_head = Rx_buffer_tail + 1;\n        Rx_buffer_tail = Rx_buffer_tail + temp_size - RX_BUFFER_SIZE / 2;\n\n        for (int i = Rx_buffer_head; i <= Rx_buffer_tail; i++)\n        {\n          Rx_final[Rx_final_index] = Rx_buffer[i];\n          Rx_final_index++;\n        }\n      }\n      temp_size = 0;\n      Rx_buffer_head = 0;\n      Rx_buffer_tail = 0;\n      Rx_half_flag = 0;\n      HAL_UART_Receive_DMA(&huart1,(uint8_t *) Rx_buffer, RX_BUFFER_SIZE);\n    }\n  }\n  /* USER CODE END USART1_IRQn 0 */\n```\n\n写到这里只处理了单次接收数据大小小于缓冲区长度的情况，可以发现代码量还是挺大的。尤其是这么写代码存在一个比较麻烦的逻辑：当DMA接收的数据量大于缓冲区大小`RX_BUFFER_SIZE`时，由于DMA工作在循环模式，那么溢出的数据会被DMA重新放到缓冲区的开始部分，从而覆盖原有的数据。要处理这部分数据势必要引入比较复杂的判断机制，还要实时更新队首和队尾的指针，导致整个程序变得比较复杂。\n\n好在HAL库除了普通的`HAL_UART_Receive_DMA()`和`HAL_UART_RxCpltCallback()`外，HAL库还提供了`HAL_UARTEx_RxEventCallback`回调。\n\n```\n/**\n  * @brief  Reception Event Callback (Rx event notification called after use of advanced reception service).\n  * @param  huart UART handle\n  * @param  Size  Number of data available in application reception buffer (indicates a position in\n  *               reception buffer until which, data are available)\n  * @retval None\n  */\n__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)\n{\n  /* Prevent unused argument(s) compilation warning */\n  UNUSED(huart);\n  UNUSED(Size);\n\n  /* NOTE : This function should not be modified, when the callback is needed,\n            the HAL_UARTEx_RxEventCallback can be implemented in the user file.\n   */\n}\n```\n该回调函数会在“advanced reception service”事件发生后触发，这里的所谓高级接收服务就包括之前需要分开判断的DMA半满中断、DMA满溢中断和空闲中断（实际上还有一个错误中断）。这三个中断触发后都会回调`HAL_UARTEx_RxEventCallback()`函数。在拷贝数据时，无需再单独进行中断回调类型的判断。由于DMA工作不依赖CPU，因此在该函数内要做的就是将缓冲区内的数据拷贝至目标地址。注意这里的形参`Size`表示缓冲区可用数据长度（从这个位置开始往后的位置都为空），而不是本次回调所接收的数据长度。\n\n![三种中断事件场景](/images/arm/rxhalf.png)\n\n再对照一下这张图，红色的部分就是`rx_size`，其值等于`Size`（缓冲区总的有效数据长度）减去`rx_buf_head`（头指针）。当缓冲区溢出并循环存储新数据至缓冲区开头时，`Size`会同步更新。\n\n原先的三个中断中的代码可以合到一个中实现：\n```\n/* USER CODE BEGIN 1 */\nvoid HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)\n{\n  uint8_t txbuf[] = \"rx done\\n\";\n  HAL_UART_Transmit_IT(&huart1, txbuf, sizeof(txbuf));\n\n  static uint8_t rx_buf_head = 0;\n  static uint8_t rx_size; //待处理数据长度\n \n  rx_size = Size - rx_buf_head;\n\n  for (uint16_t i = 0; i < rx_size; i++)\n  {\n      RxFinal[final_index++] = RxBuf[(rx_buf_head + i) % RxBufSize]; // 环形缓冲处理\n      if (final_index >= RxFinalSize) final_index = 0; // 避免 RxFinal 溢出\n  }\n\n  rx_buf_head = rx_buf_head + rx_size;\n\n  if (rx_buf_head >= RxBufSize) rx_buf_head = 0;\n}\n/* USER CODE END 1 */\n```\n这么写就无需判断到底是哪个中断触发的回调，只需要通过`Size`和头指针位置计算本次接收到的数据长度，然后按照队列逻辑按次序拷贝即可，因DMA循环而引起的溢出可通过取模操作来处理。\n\n\n\n验证：\n1. 输入“12345678\\r\\n”:![](/images/arm/test1.png)\n\n2. 输入“123456789abcdefghijklmn”：![](/images/arm/test2.png)\n\n3. 先输入\"123\"，再输入\"1234567“，再输入\"12\"，再输入\"123456789”：![](/images/arm/test3.png)\n\n验证成功。\n\n[Github项目地址](https://github.com/AkiChen891/STM32F429-UART-DMA-Ping-Pong-Cache)","categories":["嵌入式（裸机开发）"]},{"title":"线性系统理论期末考点","url":"/2024/10/22/线性系统理论期末考点/","content":"## 第七章 数学基础\n- 单模矩阵与单模变换\n- 互质性与互质性判据（秩判据）\n- 既约性与既约性判据（行次系数矩阵或列次系数矩阵）\n- 非既约矩阵的既约化\n- Smith标准形\n\n## 第八章 矩阵分式描述（MFD）\n- 左MFD与右MFD的求法\n- 真与严真的性质与判据\n    + 有理分式判别法（分子次数小于等于为真，小于分母次数为严真）\n    + $G(s)$阵判别法（s趋向无穷时$G(s)$等于常阵为真，等于零为严真）\n    + **列既约**右MFD列次系数判别法\n    + **行既约**左MFD行次系数判别法\n- 从非真MFD导出严真MFD（多项式除法导出有理分式部分并求出新的$R(s)$作为$N(s)$）\n- 不可简约MFD的性质与判据（互质性判据，判断有无同时降秩的$s$值）\n- 由可简约MFD求不可简约MFD的算法（以右MFD为例）\n    + 求gcrd表为$R(s)$\n    + 求$R(s)$的逆，表为$R^{-1}(s)$\n    + $D(s)$和$N(s)$分别右乘$R^{-1}(s)$得到新的$D(s)$和$N(s)$\n    + 组合，解毕\n\n## 第九章  传递函数矩阵的结构特性\n- 史密斯-麦克米伦形的形式与导出\n    + 求出所有元有理分式的最小公分母，表为$d(s)$\n    + 分子矩阵化为Smith标准形\n    + 消去公因子，解毕\n- M(s)的基本特性\n    + 唯一性\n    + 非保真性\n- 有限零点和有限极点\n    + *Rosenbrock*零极点定义（基于M(s)的判别法，只适用于有限复平面）\n    + 推论性定义\n        + 基于**不可简约**MFD：极点令$detD(s)$等于0，零点令$N(s)$降秩\n        + 基于状态空间方程：极点令$det(sI-A)=0$，零点令系统矩阵降秩\n    + 零点直观解释与其阻塞定理（书P479）\n- 结构指数\n    + 定义（书P480），来自于零极点集合，基于S-M形求解\n    + 含义（书P481）\n- 无穷远处的零点和极点\n    + 思路：引入$s=\\lambda^{-1}$，化为以$\\lambda$为变量的有理分式矩阵$H(\\lambda)$，求出其S-M形，然后按照有限零极点定义求解\n- 评价值\n    + 有限复平面的评价值求法（书P486）\n    + 由评价值构造S-M形（书P489）\n    + 无穷远处评价值求法（分母次数-分子次数，书P490）\n- S-M形的合成表达式（书P492）\n\n### 易错考点\n- 零极点推论性定义都基于**不可简约MFD**，如果题目给出的是可简约MFD，需要转化为不可简约MFD\n- 根据$G(s)$求评价值时，直接求各阶子式，子式中包含的分式所对应的$s$即为所求的零极点集合，不需要求$M(s)$再求零极点\n- $M(s)$中对角线各元素必须满足整除性，具体为分子次数随位置增加越来越大，分母次数越来越小\n- 求解$M(s)$过程中导出$N(s)$时，分母需首一化\n- 根据零点阻塞定理求对应的$x_0$和$u(t)$时，先由$Cx_0=0$确认非零初始状态$x_0$，然后由$(sI-A)x_0+Bu_0=0$求$u_0$\n- $s$在无穷远处的评价值即为对应的有理分式的分母次数减去分子次数\n- $s$在无穷远处的零点和极点即为$\\lambda=1/s$矩阵在$\\lambda=0$处的零点和极点\n\n## 第十章 传递函数矩阵的状态空间实现\n- 实现的定义与属性（唯一性、维数、最小实现）\n    + $G(s)=C(sI-A)^{-1}B$\n    + 实现维数：$dim(A)$\n    + 最小实现：所有实现中维数最小\n- 标量传递函数/传函矩阵的标准实现（要求$G(s)$严真）\n    + 能控标准形实现（书P528）\n        - 将$G(s)$表示为$\\frac{P(s)}{d(s)}$的形式，并全部展开\n        - $P(s)$按$s^n$系数拆开为$P_0(s)$、$P_1(s)$...\n        - 类似于标量传递函数能控形求解方式进行组合\n        - 能控形实现一般不保证能观性\n    + 能观标准形实现（书P530）\n- MFD的标准实现（要求MFD严真）\n    + 控制器形实现\n    + 观测器形实现\n\n### 易错考点\n- 控制器形和观测器形都要求MFD为**严真**，如果给出的MFD非严真，则需求其严真部分的MFD。在分离出$Q(s)$和$G_{sp}(s)$后，考虑$G_{sp}(s)=R(s)\\times D^{-1}(s)$，有$R(s)=G_{sp}(s)\\times D(s)$\n- 若MFD为不可简约，则该MFD的实现必为最小实现\n- 最小实现的形式不唯一但必定代数等价\n- 若题目要求判断是否为实现，则通过$G(s)=C(sI-A)^{-1}B$判断\n- 如果要求判断是否为最小实现\n    + 若已知状态空间方程，判断其是否同时满足能控且能观\n    + 若已知MFD，判断其是否为不可简约\n- 给定MFD的控制器形实现，判断实现维数时，所求维数即为$dim(A_c)=deg det D(s)$\n- 控制器形求解步骤\n    1. 确认MFD为右严真MFD，如非严真，将其严真化\n    2. 写出每行的列次数\n    3. 写出$D_{hc}$、$D_{lc}$、$N_{lc}$\n    4. 写出$A^{0}_c$、$B^{0}_c$\n    5. 由$A_c=A^{0}_c-B^{0}_c\\times D^{-1}_{hc}\\times D_{lc}$、$B_c=B^{0}_c\\times D^{-1}_{hc}$、$C_c=N_{lc}$\n\n## 第十一章 PMD\n- PMD的形式\n    - 同传递函数矩阵$G(s)$的关系\n        + $G(s)=R^{-1}(s)P(s)Q(s)+W(s)$\n    - 同状态空间描述的关系\n        + $P(s)=sI-A,Q(s)=B,R(s)=C$\n    - 同**严真**MFD的关系\n        + 右MFD：$P(s)=D(s),Q(s)=I,R(s)=N(s)$\n        + 左MFD：$P(s)=D_L(s),Q(s)=N_L(s),R(s)=I$\n- 不可简约PMD\n    - 判断不可简约条件\n        + $P(s),Q(s)$左互质\n        + $P(s),R(s)$右互质\n    - 不可简约PMD的构造（不可简约MFD构造的组合）\n- PMD的观测器形实现\n    1. 由PMD化左MFD\n    2. 判断左MFD行既约，后判断是否严真\n    3. 构造左MFD观测器形实现\n    4. 转化为PMD观测器形实现（书P579）\n    5. 判断是否为最小实现（PMD不可简约，MFD不可简约，完全能控和能观）\n- PMD的极点和零点\n    - PMD的极点（$detP(s)=0$）\n    - PMD的传输零点（系统矩阵降秩）\n    - 输入解耦零点（PQ行降秩）\n    - 输出解耦零点（PR列降秩）\n- 系统矩阵\n\n## 第十二章 线性时不变控制系统的复频域分析\n- 并联系统\n    + 完全能控 == $D_1(s)$和$D_2(s)$左互质\n    + 完全能观 == $D_{L1}(s)$和$D_{L2}(s)$右互质\n    + $G_1(s)$和$G_2(s)$无公共极点可推出$S_P$完全能控和完全能观\n- 串联系统\n    + 完全能控 == $D_2(s)$和$N_1(s)$左互质\n    + 完全能观 == $D_{L1}(s)$和$N_{L2}(s)$右互质\n- 输出反馈系统的能观/能控性（书P622）\n    + 完全能控 == $S_{12}$完全能控\n    + 完全能观 == $S_{21}$完全能观\n    + 若$S_2$为常阵，则$S_1$能控能观等价于整个系统能控能观\n    + $G_F(s)=G_1(s)[I+G_2(s)G_1(s)]^{-1}=[I+G_1(s)G_2(s)]^{-1}G_2(s)$\n- 直接输出反馈系统的稳定性分析\n    + 系统BIBO稳定 == 系统渐进稳定\n    + 系统以有理分式矩阵表征时\n        - 系统渐进/BIBO稳定 == $\\Delta_1(s)det[I+G_1(s)]=0$的根全部具有负实部\n    + 系统以不可简约右MFD表征时\n        - 系统渐进/BIBO稳定 == $\\Delta_1(s)det[D_1(s)+N_1(s)]=0$的根全部具有负实部\n    + 系统以不可简约左MFD表征时\n        - 系统渐进/BIBO稳定 == $\\Delta_1(s)det[D_{L1}(s)+N_{L1}(s)]=0$的根全部具有负实部\n- 带补偿器的输出反馈系统的稳定性\n    + 渐进稳定与BIBO稳定的等价条件\n        - 若$S_{12}$能控，$S_{21}$能观，二者等价\n        - 若不满足上一个条件，只能通过渐进稳定推出BIBO稳定\n    + $G_1(s)$和$G_2(s)$均以有理分式矩阵表征\n        - 渐进稳定 == $\\Delta_1(s)\\Delta_2(s)det[I+G_1(s)G_2(s)]=0$的根全部具有负实部\n    + $G_1(s)$和$G_2(s)$以不可简约左MFD和右MFD表征\n        - 渐进稳定 == $det[D_{L1}(s)D_2(s)+N_{L1}(s)N_2(s)]=0$的根均具有负实部\n    + $G_1(s)$和$G_2(s)$以不可简约右MFD和左MFD表征\n        - 渐进稳定 == $det[D_{L2}(s)D_1(s)+N_{L2}(s)N_1(s)]=0$的根均具有负实部\n    + 特殊情形\n        - 若反馈通路为常阵，则系统渐近稳定==BIBO稳定\n    \n\n\n"},{"title":"【矩阵论】矩阵分解","url":"/2024/10/20/【矩阵论】矩阵分解/","content":"\n## 满秩分解(Full Rank Factorization)\n将一个矩阵分解为两个较小矩阵的乘积，并且这两个矩阵的秩与原矩阵相同。满秩分解的目的是把矩阵表示为两个更简单矩阵的乘积，同时保持原矩阵的秩。\n### 前置定理\n- 任何非零矩阵都存在满秩分解\n- 满秩分解可分为**行满秩分解**和**列满秩分解**\n- 满秩分解不唯一\n### 行满秩分解步骤\n1. 对矩阵$A$进行行变换，化为行最简形$\\hat A$，即每一行的第一个非零元素为1，并且是其所在的列的唯一一个非零元素\n2. 标记每一个非零行的第一个非零元素所在的列，此处假设为1，2，3\n3. $B$为$A$的第1，2，3列，$C$为$\\hat A$的第1，2，3行\n4. $A=BC$即为行满秩分解\n### 列满秩分解步骤\n1. 对矩阵$A$进行列变换，化为列最简形$\\hat A$，即每一列的第一个非零元素为1，并且是其所在的行的唯一一个非零元素\n2. 标记每一个非零列的第一个非零元素所在的行，此处假设为1，2，3\n3. $C$为$A$的第1，2，3行，$B$为$\\hat A$的第1，2，3列\n4. $A=BC$即为列满秩分解\n\n## UR分解\n也被称为QR分解或正交三角分解。\n### 前置定理\n- 若$A$为列满秩矩阵，则$A$可以唯一地被分解为$A=UR$，其中$U$为列满秩矩阵，$R$为正线上三角阵。\n- UR分解是一种特殊的满秩分解。\n### 步骤\n1. 令$A=[\\alpha_1,\\alpha_2,\\alpha_3]$\n2. 将$[\\alpha_1,\\alpha_2,\\alpha_3]$正交化、单位化，重新组合，即得到$U$\n3. 根据$A=UR$，有$R=U^H A$，求出$R$\n4. UR分解即为$A=UR$\n\n## 奇异值分解\n奇异值分解的形式为：\n\n$$\nA=U\n\\begin{bmatrix}\n\\Delta & 0 \\\\\n0 & 0\\\n\\end{bmatrix}\nV^H\n$$\n\n### 前置定理\n- $A^H A$和$AA^H$均为半正定，特征值均为非负实数\n- $A^H A$和$AA^H$的非零特征值相同\n- 奇异值分解通常不唯一\n\n### 步骤（方法一）\n该方法由$AA^H$求$U_1$。\n1. 求出$AA^H$的全部非零特征值，由大到小排列，并以此为序写出奇异值矩阵$\\Delta$\n2. 求出$AA^H$的所有特征值对应的特征向量，正交化加单位化后组合，得到矩阵$U$\n3. 设$AA^H$有$n$个非零奇异值，则取出$U$的前$n$列，组合得到$U_1$\n4. 由$V_1=A^HU_1\\Delta^{-H}$，求得$V_1$\n5. 扩展$V_1$至$V$，其中新添加的列向量$V_2$应与$V_1$正交化、单位化\n6. 解毕\n\n### 步骤（方法二）\n该方法由$A^HA$求$V_1$。\n1. 求出$A^HA$的全部非零特征值，由大到小排列，并以此为序写出奇异值矩阵$\\Delta$\n2. 求出$A^HA$的所有特征值对应的特征向量，正交化加单位化后组合，得到矩阵$V$\n3. 设$A^HA$有$n$个非零奇异值，则取出$V$的前$n$列，组合得到$V_1$\n4. 由$U_1 = AV_1\\Delta^{-1}$，求得$U_1$\n5. 扩展$U_1$至$U$，其中新添加的列向量$U_2$应与$U_1$正交化、单位化\n6. 解毕\n\n## 谱分解\n谱分解不唯一。\n### 步骤\n1. 求特征值及其所对应的特征向量\n2. 无需进行正交化或单位化，组合特征向量，得到矩阵$P$\n3. 求$P^{-1}$\n\n若特征值无重根：\n\n4. 按照特征值次序$i$，依次取$P$的第$i$列和$P^{-1}$的第$i$列，二者相乘，得到$H_i$\n\n若特征值有重根：\n\n4. 按照特征值次序$i$，若某特征值有$n$重根，则在取列和行时一次性取$n$次，然后二者相乘，得到$H_i$\n\n5. 组合，证毕\n"},{"title":"数据结构笔记【2】","url":"/2024/10/11/数据结构笔记【2】/","content":"## 链式存储\n### 线性表之单链表\n将线性表的个元素分布在存储器的不同存储块，称为结点，通过地址或指针建立元素之间的联系。\n\n结点分为data域和next域，next域是一个指针，指向$a_i$的直接后继$a_{i+1}$的所在结点。next为NULL时表明该元素为链表最后一个元素。\n\n头结点：data不重要，专门用来标记第一个元素的结点地址\n\n结点类型描述:\n```\ntypedef struct node\n{\n    data_t data;    //数据域\n    struct node *next;  //结点的后继指针域\n}listnode, *linklist;   //linklist 是一个指向链表的指针类型，用于操作链表的头指针\n```\n所以有\n```\nlistnode A; // 定义一个结点\nlinklist p = &A;  // 定义一个链表头指针，并指向 A 结点\n```\n- 获取$a_i$:  p->data;\n\n- 获取$a_{i+1}$:  p->next->data;\n\n若指针p的值为NULL，则其不指向任何结点，此时取p->data或p->next是错误的\n\n#### 单链表的遍历\n线性存储中，遍历基于表尾标识符last完成，索引$i$从0循环到last视为遍历一次。\n\n链式存储中，节点之间由next进行后继连接，所以遍历应当从头节点开始，由`head = head->next`方式进行索引（指针）更新\n\n示例：\n\n```\n/*\n    * @brief: 遍历链表并打印其中的元素\n    * @param: H: 指向链表的指针\n    * @return: 遍历成功返回0，失败返回-1\n*/\nint list_show(linklist H)\n{\n    linklist p;\n\n    if (H == NULL) // 如果链表为空，直接返回 NULL\n    {\n        printf(\"H is NULL\\n\");\n        return -1;\n    }\n\n    p = H->next; //p 指向头结点的下一个节点 注意：这里不是线性存储，节点之间通过指针连接，不能写成p=H+1\n    while (p != NULL)\n    {\n        printf(\"%d \",p->data);\n        p = p->next;  //p指向下一个节点\n    }\n\n    return 0;\n}\n```\n\n#### 单链表获取指定位置的节点地址\n头节点只有Next域，没有data域；尾节点只有data域，Next域为NULL。\n\nlist_get()函数遍历到指定链表的pos位置，遍历到之后返回最后一个节点的指针。注意遍历可以有两种方式：\n- 从头节点开始，初始化p = head,i = -1，遍历到i < pos时结束，此时的pos是包含头节点在内的位置，比如链表{1,2,6,3}，元素2的位置是2，不是1；\n- 从头节点之后的第一个结点开始，初始化p = head->next; i = 0，遍历到i < pos时结束，此时的pos是不包含头节点在内的位置，比如链表{1,2,6,3}，元素2的位置是1；\n\n```\n/*\n    * @brief: 获取链表中指定位置的节点地址\n    * @param: H: 指向链表的指针\n    * @param: pos: 指定的位置\n    * @return: 插入成功返回找到的结点，失败返回NULL\n*/\nlinklist list_get(linklist H, int pos)\n{\n    linklist p; // 声明一个指向链表节点的指针，用于遍历链表\n    int i = -1; // 用于记录遍历位置，初始化为-1以考虑头结点\n\n    if (H == NULL) // 如果链表为空，直接返回 NULL\n    {\n        printf(\"H is NULL\\n\");\n        return NULL;\n    }\n\n    if (pos == -1) // 如果 pos == -1，返回头结点\n    {\n        return H;\n    }\n\n    p = H; // 从头结点的下一个节点开始遍历\n    while (i < pos) // 当 i 小于 pos 时继续循环\n    {\n        p = p->next; // 移动到下一个节点\n        if (p == NULL)  // 如果链表到达了末尾，且还没找到 pos，返回 NULL\n        {\n            printf(\"pos is invalid\\n\");\n            return NULL;\n        }\n        i++; // 记录当前遍历到的节点编号\n    }\n\n    return p; // 返回找到的节点\n}\n```\n#### 单链表的其他操作\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include \"linklist.h\"\n\n/*\n    * @brief: 创建一个空的链式线性表\n    * @param: 无\n    * @return: 返回链表的头指针\n*/\nlinklist list_create()\n{\n    linklist head = (linklist)malloc(sizeof(listnode));\n\n    if (head == NULL)\n    {\n        printf(\"memory allocation failed\\n\");\n        return NULL;\n    }\n    head->next = NULL;  // 初始化头结点的指针域为空，表示链表为空\n    return head;\n}\n\n/*\n    * @brief: 插入元素到链表中\n    * @param: head: 指向链表头结点的指针\n    * @param: value: 要插入的值\n    * @param: pos：插入位置，新的节点会放置在该位置之后\n    * @return: 插入成功返回0，失败返回-1\n*/\nint list_insert(linklist head, data_t value, int pos)\n{\n    if (head == NULL) return -1;  // 检查链表是否存在\n\n    // 如果要在第 0 位插入节点（头结点之后）\n    if (pos == 0)\n    {\n        linklist new_node = (linklist)malloc(sizeof(listnode));   //为新节点申请内存 \n        if (new_node == NULL)\n        {\n            printf(\"memory allocation failed\\n\");\n            return -1;\n        }\n\n        new_node->data = value;   // 新节点的数据域赋值\n        new_node->next = head->next;  // 新节点指向头结点后的第一个节点\n        head->next = new_node;  // 头结点的next指向新插入的节点\n        return 0;\n    }\n\n    // 否则查找 pos-1 位置的前驱节点\n    linklist prev_node = list_get(head, pos-1);\n    if (prev_node == NULL)\n    {\n        printf(\"Invalid position\\n\");\n        return -1;\n    }\n\n    // 为新节点申请内存\n    linklist new_node = (linklist)malloc(sizeof(listnode));   \n    if (new_node == NULL)\n    {\n        printf(\"memory allocation failed\\n\");\n        return -1;\n    }\n\n    new_node->data = value;  // 设置新节点的数据\n    new_node->next = prev_node->next;  // 新节点指向原链表在插入位置后的节点\n    prev_node->next = new_node;  // 前驱节点替换为新插入的节点\n\n    return 0;\n}\n\n\n/*\n    * @brief: 获取链表中指定位置的节点地址\n    * @param: H: 指向链表的指针\n    * @param: pos: 指定的位置\n    * @return: 插入成功返回找到的结点，失败返回NULL\n*/\nlinklist list_get(linklist H, int pos)\n{\n    linklist p; // 声明一个指向链表节点的指针，用于遍历链表\n    int i = -1; // 用于记录遍历位置，初始化为-1以考虑头结点\n\n    if (H == NULL) // 如果链表为空，直接返回 NULL\n    {\n        printf(\"H is NULL\\n\");\n        return NULL;\n    }\n\n    if (pos == -1) // 如果 pos == -1，返回头结点\n    {\n        return H;\n    }\n\n    p = H; // 从头结点开始遍历\n    while (i < pos) // 当 i 小于 pos 时继续循环\n    {\n        p = p->next; // 移动到下一个节点\n        if (p == NULL)  // 如果链表到达了末尾，且还没找到 pos，返回 NULL\n        {\n            printf(\"pos is invalid\\n\");\n            return NULL;\n        }\n        i++; // 记录当前遍历到的节点编号\n    }\n\n    return p; // 返回找到的节点\n}\n\n/*\n    * @brief: 遍历链表并打印其中的元素\n    * @param: H: 指向链表的指针\n    * @return: 遍历成功返回0，失败返回-1\n*/\nint list_show(linklist H)\n{\n    linklist p;\n\n    if (H == NULL) // 如果链表为空，直接返回 NULL\n    {\n        printf(\"H is NULL\\n\");\n        return -1;\n    }\n\n    p = H->next; //p 指向头结点的下一个节点 注意：这里不是线性存储，节点之间通过指针连接，不能写成p=H+1\n    while (p != NULL)\n    {\n        printf(\"%d \",p->data);\n        p = p->next;  //p指向下一个节点\n    }\n\n    return 0;\n}\n\n/*\n    * @brief: 遍历链表并查找指定的值\n    * @param: H: 指向链表的指针\n    * @return: 查找成功返回0，失败返回-1\n*/\nint list_search(linklist H, data_t value)\n{\n    if (H == NULL) // 如果链表为空，直接返回 NULL\n    {\n        printf(\"H is NULL\\n\");\n        return -1;\n    }\n\n    linklist p = H->next;\n    int i = 0; //初始化节点索引为-1\n\n    while (p != NULL)\n    {\n        if (p->data == value)\n        {\n            printf(\"search ok, pos is %d\\n\",i);\n        }\n        i++;\n        p = p->next;   //更新指针，指向下一个节点\n    }\n\n    return 0;\n}\n\n/*\n    * @brief: 合并两个链表，然后存储到新链表中\n    * @param: H1: 指向链表1的指针\n    * @param: H2: 指向链表2的指针\n    * @return: 返回表3\n*/\nlinklist list_merge(linklist H1, linklist H2)\n{\n    if (H1 == NULL || H2 == NULL) \n    {\n        printf(\"H1 or H2 is null\\n\");\n        return NULL;\n    }\n    \n    linklist H3 = list_create();    //创建新表\n\n    //拷贝H1至H3\n    linklist TempPtr1 = H1->next;   //声明TempPtr指向H1的下一个节点，跳过头节点\n    int count1 = 0;\n    while (TempPtr1 != NULL)\n    {\n        list_insert(H3, TempPtr1->data, count1);    //向H3插入H1的data\n        TempPtr1 = TempPtr1->next;  //更新指针\n        count1++;   //更新计数器\n    } \n\n    linklist TempPtr2 = H2->next;\n    int count2 = 0;\n    while (TempPtr2 != NULL)\n    {\n        list_insert(H3, TempPtr2->data, count1 + count2);\n        TempPtr2 = TempPtr2->next;\n        count2++;\n    }\n\n    return H3;\n}\n\n/*\n    * @brief: 删除两个链表中的重复部分，将剩余元素存在新表中\n    * @param: H1: 指向链表1的指针\n    * @param: H2: 指向链表2的指针\n    * @return: 返回表3\n    * @note: 仅适用于小链表，大链表可以用哈希表\n*/\nlinklist list_purge(linklist H1, linklist H2)\n{\n    if (H1 == NULL || H2 == NULL) \n    {\n        printf(\"H1 or H2 is null\\n\");\n        return NULL;\n    }\n\n    linklist H3 = list_create();\n\n    int is_common = 0;  //初始化标记，09为不重复，1为重复\n\n    linklist TempPtr1 = H1->next;   //初始化Ptr1指向H1的第一个有效节点\n    while (TempPtr1 != NULL)\n    {\n        linklist TempPtr2 = H2->next;   // 每次遍历TempPtr1时，重置TempPtr2，否则TempPtr2一旦遍历到NULL后不会返回\n        while (TempPtr2 != NULL)\n        {\n            if (TempPtr1->data == TempPtr2->data)\n            {\n                printf(\"common elements:%d\\n\",TempPtr2->data);\n                \n                is_common = 1;\n                list_insert(H3, TempPtr2->data, 0);\n            }\n            TempPtr2 = TempPtr2->next;  //更新TempPtr2\n        }\n\n        if (is_common == 0)  // 如果不是重复元素，插入到H3中\n        {\n            list_insert(H3, TempPtr1->data, 0);\n        }\n        TempPtr1 = TempPtr1->next;  //更新TempPtr1\n    }\n\n    return H3;\n}\n\n/*\n    * @brief: 删除指定位置的节点\n    * @param: H: 指向链表的指针\n    * @param: pos：待删除结点的位置\n    * @return: 成功返回0，失败返回-1\n*/\nint list_delete(linklist H, int pos)\n{\n    if (H == NULL) \n    {\n        printf(\"no such linklist\\n\");\n        return -1;\n    }\n\n    // 如果删除的位置是第一个节点\n    if (pos == 1)\n    {\n        linklist TempPtr = H->next; // 保存下一个节点\n        free(H); // 释放头节点\n        H = TempPtr; // 更新头指针\n        return 0;\n    }\n\n    // 获取待删除节点的前一个节点\n    linklist Prev_Node = list_get(H, pos - 1);\n    if (Prev_Node == NULL || Prev_Node->next == NULL)\n    {\n        printf(\"invalid position\\n\");\n        return -1;\n    }\n\n    // 获取待删除的节点\n    linklist TempPtr = Prev_Node->next;\n    Prev_Node->next = TempPtr->next; // 连接前后节点\n    free(TempPtr); // 释放被删除的节点\n\n    return 0;\n}\n\n/*\n    * @brief: 删除整个链表并释放内存\n    * @param: H: 指向链表的指针\n    * @return: 成功返回0，失败返回-1\n*/\nint list_free(linklist H)\n{\n    if (H == NULL)\n    {\n        printf(\"no such linklist\\n\");\n        return -1;\n    }\n\n    linklist TempPtr = H;\n\n    while (H != NULL)\n    {\n        TempPtr = H;    // 保存当前节点\n        H = H->next;    // 更新链表头指针为下一个节点\n        free(TempPtr);  // 释放当前节点\n    }\n\n    return 0;\n}\n\n/*\n    * @brief: 倒置链表\n    * @param: H: 指向链表的指针\n    * @return: 成功返回0，失败返回-1\n    * @note: 将节点拿出放到\n*/\nint list_reverse(linklist H)\n{\n    if (H == NULL)\n    {\n        printf(\"no such linklist\\n\");\n        return -1;\n    }\n\n    if (H->next == NULL)\n    {\n        printf(\"linklist is empty\\n\");\n        return -1;\n    }\n\n    //链表一分为二\n    linklist p = H->next->next;\n    H->next->next = NULL;\n\n    \n    while (p != NULL)\n    {\n        linklist q = p; // 暂存当前节点\n        p = p->next;    // 移动到下一个节点\n        q->next = H->next; // 将当前节点插入到链表头部（头插法）\n        H->next = q; // 更新头节点为新插入的节点\n    }\n\n    return 0;\n}\n\n/*\n    * @brief: 求链表相邻两节点data值之和为最大的第一结点的指针\n    * @param: H: 指向链表的指针\n    * @return: 成功返回指针，失败返回NULL\n*/\nint list_getmax(linklist H)\n{\n    if (H == NULL)\n    {\n        printf(\"no such linklist\\n\");\n        return -1;\n    }\n\n    if (H->next == NULL)\n    {\n        printf(\"linklist is empty\\n\");\n        return -1;\n    }\n\n    int sum_new, max = 0;\n    linklist p = H->next;\n    linklist max_p = H->next;\n    int sum = p->data + p->next->data;\n\n    while (p != NULL && p->next != NULL)\n    {\n        sum_new = p->data + p->next->data;\n        \n        if (sum_new >= max)\n        {\n            max = sum_new;\n            max_p = p;\n        }\n\n        p = p->next;\n    }\n    //printf(\"max sum is %d\",max);\n    return max;\n}\n```\n\n## 栈(Stack)\n和微机原理中栈的原理相同\n\n注意：\n- 先进后出\n- 注意栈顶指针的更新\n\n栈主要用于以下场景：\n- 函数调用：使用栈来保存当前函数的局部变量、返回地址等信息。当函数调用另一个函数时，新的函数信息被压入栈中，函数执行完毕后会从栈中弹出，返回上一个函数。\n- 撤销操作\n- 递归\n- 二叉树遍历\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include \"linear_stack.h\"\n#include <string.h>\n\n/*\n    @brief: 创建新的栈\n    @param: len: 栈的长度\n    @return: 指向栈的指针\n*/\nsqstack *stack_create(int len)\n{\n    if (len < 0)\n    {\n        printf(\"len is illegal\\n\");\n        return NULL;\n    }\n\n    sqstack *ss;\n\n    //申请用于放置结构体的内存\n    ss = (sqstack *)malloc(sizeof(sqstack));   \n    if (ss == NULL) {\n        printf(\"Failed to allocate memory for stack.\\n\");\n        return NULL;\n    }\n\n    //申请用于放置栈内数据的内存\n    ss->data = (data_t *)malloc(sizeof(data_t) * len);\n    if (ss->data == NULL) {\n        printf(\"Failed to allocate memory for stack data.\\n\");\n        free(ss);  \n        return NULL;\n    }\n\n    memset(ss->data, 0, len*sizeof(data_t));\n    ss->top = -1;\n    ss->maxlen = len;\n\n    return ss;\n}\n\n/*\n    @brief: 入栈\n    @param: s：对应栈指针 value：待入栈值\n    @return: 成功返回0，失败返回-1\n*/\nint stack_push(sqstack *s, data_t value)\n{\n    if (s == NULL)\n    {\n        printf(\"no such stack\\n\");\n        return -1;\n    }\n    if (s->top == s->maxlen - 1)\n    {\n        printf(\"stack is full\\n\");\n        return -1;\n    }\n\n    s->top++;\n    s->data[s->top] = value;\n\n    printf(\"stack push ok\\n\");\n    return 0;\n}\n\n/*\n    @brief: 判断栈是否为空\n    @param: s：对应栈指针\n    @return: 栈为空返回-1，非空返回0，函数非法返回-2\n*/\nint stack_empty(sqstack *s)\n{\n    if (s == NULL)\n    {\n        printf(\"no such stack\\n\");\n        return -2;\n    }\n\n    if (s->top == -1)\n    {\n        printf(\"stack is empty\\n\");\n        return -1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n/*\n    @brief: 判断栈是否为满\n    @param: s：对应栈指针\n    @return: 栈为满返回-1，非满返回0，函数非法返回-2\n*/\nint stack_full(sqstack *s)\n{\n    if (s == NULL)\n    {\n        printf(\"no such stack\\n\");\n        return -2;\n    }\n\n    if (s->top == s->maxlen - 1)\n    {\n        printf(\"stack is full\\n\");\n        return -1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n/*\n    @brief: 数据出栈\n    @param: s：对应栈指针\n    @return: 返回出栈值，如果栈为空或出错则返回-999\n*/\ndata_t stack_pop(sqstack *s)\n{\n    if (s == NULL)\n    {\n        printf(\"Stack not initialized\\n\");\n        return -999;  \n    }\n\n    if (s->top == -1)\n    {\n        printf(\"Stack is empty\\n\");\n        return -999;  \n    }\n     \n    data_t temp = s->data[s->top];\n    s->top--;\n    return temp;\n}\n\n/*\n    @brief: 清除栈内所有元素\n    @param: s：对应栈指针\n    @return: 成功返回0，失败返回-1\n*/\nint stack_clear(sqstack *s)\n{\n    if (s == NULL)\n    {\n        printf(\"Stack not initialized\\n\");\n        return -1;  \n    }\n\n    if (s->top == -1)\n    {\n        return 0;  \n    }\n\n    //一般的栈清空操作只会重置 top，但不释放内存\n    s->top = -1;\n    //free(s->data);\n    //s->data = NULL;\n\n    return 0;\n}\n\n/*\n    @brief: 释放整个栈的空间\n    @param: s：对应栈指针\n    @return: 成功返回0，失败返回-1\n*/\nint stack_free(sqstack *s)\n{\n    if (s == NULL)\n    {\n        printf(\"Stack not initialized\\n\");\n        return -1;  \n    }\n\n    free(s->data);\n    s->data = NULL;\n    free(s);\n\n    return 0;\n}\n```\n\n## 队列(Queue)\n### 基于数组的队列\n等同于现实生活中的“排队”，元素从列尾存入，列首取出\n\n双端队列：列首和列尾都可以进行存入和取出；或解释为：同一个队列共享列首和列尾\n\n队列多被用于：\n- 任务调度\n- 消息队列\n- IO请求管理（确保系统资源的有序访问）\n\n队列结构体一般为\n```\ntypedef int data_t;\n#define N 64\ntypedef struct \n{\n    data_t data[N];\n    int front, rear;    //rear为队尾后一个元素的下标\n}sequeue_t;\n```\n\n其中`rear`一般指示队尾元素的下一个位置，也就是下一个要入队的元素位置。用于处理队列为空或只有一个元素时的情况。头尾位置重合时，队列即为空。\n初始`front, rear = 0;`\n- 出队列：`x = sq[front++]`\n- 入队列：`sq[rear++] = x;`\n\n当队列中前几个元素出队时，会造成这些位置为空，从而浪费队列中的可存储空间。此时可以使用**循环队列**。\n为区别空队和满队，满队元素个数比数组元素个数少一个。\n\n```\n/*\n    @brief: 创建空队列\n    @param: 无\n    @return: 指向队列的指针\n*/\nsequeue queue_create()\n{\n    sequeue qq = (struct queue*)malloc(sizeof(struct queue));\n\n    if (qq == NULL)\n    {\n        printf(\"malloc failed\\n\");\n        return NULL;\n    }\n\n    qq->front = 0;\n    qq->rear = 0;\n\n    memset(qq->data, 0, sizeof(qq->data));\n\n    return qq;\n}\n\n/*\n    @brief: 遍历并打印队列\n    @param: q：队列指针\n    @return: 成功返回0，失败返回-1\n*/\nint queue_print(sequeue q)\n{\n    if (q == NULL)\n    {\n        printf(\"no such queue\\n\");\n        return -1;\n    }\n\n    if (q->front == q->rear)\n    {\n        printf(\"queue is empty\");\n        return -1;\n    }\n\n    for (int i = q->front; i < q->rear; i++)\n    {\n        printf(\"%d \", q->data[i]);\n    }\n\n    return 0;\n}\n\n/*\n    @brief: 元素入队\n    @param: q：队列指针 data：待入队元素\n    @return: 成功返回0，失败返回-1\n*/\nint enqueue(sequeue q, data_t data)\n{\n    if (q == NULL)\n    {\n        printf(\"no such queue\\n\");\n        return -1;\n    }\n\n    if ((q->rear + 1) % N == q->front)\n    {\n        printf(\"queue is full\\n\");\n        return -1;\n    }\n\n    q->data[q->rear] = data;\n    q->rear = (q->rear + 1) % N;    // rear 指针移动到队列边界时，通过取余使其返回到数组开头，实现循环\n\n    return 0;\n}\n\n/*\n    @brief: 元素出队\n    @param: q：队列指针\n    @return: 成功返回出队元素，失败返回-1\n    @note: 出队元素为队首的第一个元素\n*/\nint dequeue(sequeue q)\n{\n    if (q == NULL)\n    {\n        printf(\"no such queue\\n\");\n        return -1;\n    }\n\n    if (q->front == q->rear)\n    {\n        printf(\"queue is empty\");\n        return -1;\n    }\n\n    int temp = q->data[q->front];\n    q->front = (q->front + 1) % N;\n\n    return temp;\n}\n\n/*\n    @brief: 清空队列内元素，但不释放内存\n    @param: q：队列指针\n    @return: 成功返回0，失败返回-1\n    @note: \n*/\nint queue_clear(sequeue q)\n{\n    if (q == NULL)\n    {\n        printf(\"no such queue\\n\");\n        return -1;\n    }\n\n    q->front = 0;\n    q->rear = 0;\n\n    return 0;\n}\n```\n### 基于链式存储的队列\n插入操作在队尾进行，删除操作在队首进行，由队首指针和队尾指针控制队列操作\n\n结构体需要定义两个：节点结构体 和 队列结构体\n```\ntypedef int data_t;\n\ntypedef struct node\n{\n    data_t data;\n    struct node* next;\n}*linklist;\n\ntypedef struct queue\n{\n    linklist front;\n    linklist rear;\n};\n```\n- 初始化：创建空队列，front和rear指针都为空\n- 入队：在队尾新增一个节点，并更新当前队尾节点的next指针\n- 出队：更新front指针到待出队节点的下一个节点，然后删除原有队首节点\n\n与线性表不同的是，链式队列中rear指针一般指向最后队列的一个节点，而非最后一个节点的下一个节点。\n\n判断链式队列是否为空的条件只有一个：`front == NULL, rear == NULL`，不能使用`front==rear`判断，因为这里`front`和`rear`都是指针，并且`rear`指向的是最后一个节点，而非线性队列中的指向最后一个位置的下一个位置（待插入位置）。假设队伍中只有一个元素，这时候`front`和`rear`二者相同，但队列不为空。\n\n#### 创建新的链式队列\n```\n/*\n    @ brief：创建并初始化新的链式队列\n    @param：无\n    @return：成功指向新队列的指针，失败返回NULL\n*/\nstruct queue* queue_create()\n{\n    struct queue* q = (struct queue*)malloc(sizeof(struct queue));\n\n    if (q == NULL)\n    {\n        printf(\"malloc failed\\n\");\n        return NULL;\n    }\n\n    q->front = NULL;\n    q->rear = NULL;\n\n    return q;\n}\n```\n- 为队列申请内存，暂时先不申请节点的，因为这是一个空队列，目前还没有元素\n- 因为队列中没有节点，front和rear指针都为NULL\n\n#### 遍历队列\n```\n/*\n    @ brief：遍历链式队列并打印所有元素\n    @param：q：队列指针\n    @return：成功返回0，失败返回-1\n*/\nint queue_print(struct queue* q)\n{\n    if (q == NULL)\n    {\n        printf(\"no such queue\\n\");\n        return -1;\n    }\n\n    if (q->front == NULL)\n    {\n        printf(\"queue is empty\\n\");\n        return -1;\n    }\n\n    struct node* temp = q->front;\n\n    while (temp != NULL)\n    {\n        printf(\"%d\", temp->data);\n        temp = temp->next;\n    }\n\n    printf(\"\\n\");\n\n    return 0;\n}\n```\n- 在遍历时要用临时指针temp来代替front，如果直接用front指针的话，遍历一次之后front就回不去了，整个队列会被破坏\n- 尽量不要在遍历前用temp存储front指针，用front指针遍历完之后再front = temp这种形式返回回去的这种方法，在多线程的时候可能会有问题\n- 遍历结束的条件是当temp指针走到NULL之后，表明从队首节点到队尾节点全都扫描到了，而不是`temp(front)=rear`或者`temp(front)=rear->next`，因为链式队列中rear指针指向的是最后一个（队尾）节点\n\n#### 其他\n```\n/*\n    @ brief：创建并初始化新的链式队列\n    @param：无\n    @return：成功指向新队列的指针，失败返回NULL\n*/\nstruct queue* queue_create()\n{\n    struct queue* q = (struct queue*)malloc(sizeof(struct queue));\n\n    if (q == NULL)\n    {\n        printf(\"malloc failed\\n\");\n        return NULL;\n    }\n\n    q->front = NULL;\n    q->rear = NULL;\n\n    return q;\n}\n\n/*\n    @ brief：遍历链式队列并打印所有元素\n    @param：q：队列指针\n    @return：成功返回0，失败返回-1\n*/\nint queue_print(struct queue* q)\n{\n    if (q == NULL)\n    {\n        printf(\"no such queue\\n\");\n        return -1;\n    }\n\n    if (q->front == NULL)\n    {\n        printf(\"queue is empty\\n\");\n        return -1;\n    }\n\n    struct node* temp = q->front;\n\n    while (temp != NULL)\n    {\n        printf(\"%d \", temp->data);\n        temp = temp->next;\n    }\n\n    printf(\"\\n\");\n\n    return 0;\n}\n\n\n/*\n    @ brief：元素入队\n    @param：q：队列指针 val：待入队元素值\n    @return：成功返回0，失败返回-1\n*/\nint enqueue(struct queue* q, data_t val)\n{\n    if (q == NULL)\n    {\n        printf(\"no such queue\\n\");\n        return -1;\n    }\n    struct node* newnode = (struct node*)malloc(sizeof(struct node));\n\n    newnode->data = val;\n    newnode->next = NULL;\n\n    //判断原队列是否为空\n    if (q->rear == NULL)\n    {\n        q->front = newnode;\n        q->rear = newnode;\n    }\n    else\n    {  \n        q->rear->next = newnode;\n        q->rear = newnode;\n    }\n\n    return 0;\n}\n\n/*\n    @ brief：元素出队\n    @param：q：队列指针\n    @return：成功返回0，失败返回-1\n*/\nint dequeue(struct queue* q)\n{\n    if (q == NULL)\n    {\n        printf(\"no such queue\\n\");\n        return -1;\n    }\n\n    if (q->front == NULL)\n    {\n        printf(\"queue is empty\\n\");\n        return -1;\n    }\n\n    struct node* temp_node = q->front;\n    int temp = temp_node->data;\n    q->front = q->front->next;\n\n    // 如果队列为空，则需要更新 rear 为 NULL\n    if (q->front == NULL)\n    {\n        q->rear = NULL;\n    }\n\n    free(temp_node);\n\n    return temp;\n}\n\n/*\n    @ brief：清空队列并删除对应节点\n    @param：q：队列指针\n    @return：成功返回0，失败返回-1\n*/\nint queue_clear(struct queue* q)\n{\n    if (q == NULL)\n    {\n        printf(\"no such queue\\n\");\n        return -1;\n    }\n\n    if (q->front == NULL)\n    {\n        return 0;\n    }\n\n    //临时节点，用于储存待删除的节点而不影响后续节点的遍历\n    struct node* temp;  \n    \n    while (q->front != NULL)\n    {\n        temp = q->front;\n        q->front = q->front->next;\n        free(temp);\n    }\n\n    q->rear = NULL;\n\n    return 0;\n}\n```\n\n## 球钟问题（队列和栈的应用）\n球钟问题（Ball Clock Problem）是一种经典的算法和数据结构题目，主要用于考察队列和栈的结合运用。问题的基本情景是：\n假设有一个球钟系统，它通过小球来计时。系统中有 3 个轨道，每个轨道容量不同：\n- 分钟轨道（Min Track）：最多可容纳 4 个小球。\n- 五分钟轨道（Five-Min Track）：最多可容纳 11 个小球。\n- 小时轨道（Hour Track）：最多可容纳 11 个小球。\n\n运作机制：\n- 初始状态下有一组编号为 1 到 n 的小球，n 是球的总数，这些小球依次通过队列进行处理。\n- 每分钟，第一个小球从队列中取出，放到分钟轨道上。\n- 当分钟轨道满（即放入第5个小球时），轨道中的 4 个小球被依次放回队列，保持原来的顺序，而第 5 个小球则进入五分钟轨道。\n- 当五分钟轨道满（即放入第12个小球时），轨道中的 11 个小球被依次放回队列，第 12 个小球进入小时轨道。\n- 当小时轨道满（即放入第12个小球时），轨道中的 11 个小球被依次放回队列，第 12 个小球也回到队列的末尾。\n\n问题的一个常见考点是计算在给定的初始状态下，经过多少分钟后，小球队列的顺序会恢复到最初的状态。\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include \"queue.h\"\n#include \"linear_stack.h\"\n\n#define N 27\n\nint main()\n{\n    struct queue* main_queue = queue_create();\n    struct stack* minute = stack_create(4);\n    struct stack* five_minute = stack_create(11);\n    struct stack* hour = stack_create(11);\n\n    int time = 0;\n\n    //初始化主队列中的27个小球\n    for (int i = 1; i <= N; i++)\n    {\n        enqueue(main_queue, i);\n    }\n\n    while (!stack_full(hour))   //如果小时轨道未满，继续\n    {\n        while (!stack_full(five_minute))    //如果五分钟轨道未满，继续\n        {\n            while (!stack_full(minute))     //如果分钟轨道未满，继续\n            {\n                int ball = dequeue(main_queue);     //从主队列中获取小球\n                stack_push(minute, ball);           // 放入分钟栈中\n                time++;\n\n                if (stack_full(minute))             //如果分钟栈满了\n                {\n                    int count_min = 0;\n                    while (count_min < 4)    \n                    {\n                        int min_top_ball = stack_pop(minute);   //从分钟栈中弹出一个小球\n                        enqueue(main_queue, min_top_ball);      //该小球送入主队列\n                        count_min++;\n                    }\n\n                    stack_push(five_minute, ball);          //将一个小球推入五分钟栈\n                }\n            }\n            if (stack_full(five_minute))    //如果五分钟栈满了\n            {\n                int count_five_min = 0;\n                while (count_five_min < 11)  \n                {\n                    int five_min_top_ball = stack_pop(five_minute);     //从五分钟栈中弹出一个小球\n                    enqueue(main_queue, five_min_top_ball);     //送回主队列\n                    count_five_min++;\n                }\n\n                stack_push(hour, dequeue(main_queue));\n            }\n        }\n\n        if (stack_full(hour))\n        {\n            int count_hour = 0;\n            while (count_hour < 11)\n            {\n                int hour_top_ball = stack_pop(hour);\n                enqueue(main_queue, hour_top_ball);\n                count_hour++;\n            }\n        }\n    }\n\n    printf(\"钟表恢复到初始状态所需时间: %d 分钟\\n\", time);\n\n    return 0;\n}\n```","categories":["数据结构"]},{"title":"数据结构笔记【1】","url":"/2024/10/10/数据结构笔记【1】/","content":"### 数据的三种结构\n#### 逻辑结构\n包含：\n- 集合\n- 线性结构（一对一），如线性表、栈、队列\n- 树形结构 一个对多个\n- 图状结构 多个对多个\n\n#### 存储结构\n- 顺序存储：按照逻辑顺序存放于**连续**空间\n- 链式存储（重点）：放到存储区的不同位置，用地址（指针）方式建立逻辑上的联系\n- 索引存储：建立附加的索引表（电话簿）\n- 散列存储：依据数据元素的特殊字段（关键字key）计算元素的存放地址，然后按地址存放\n\n### 线性表\n线性表是包含若干数据元素的一个线性序列，记为\n$$\nL=(a_0,...,a_{i-1},a_i,a_{i+1},...,a_{n-1})\n$$\n\n$L$为表名，$a_i$为数据元素，$n$为表长，$n>0$时表为非空表，否则为空表\n\n线性表可以用二元组形式描述\n$$\nL=(D,R)\n$$\n即线性表$L$包含数据元素集合$D$和关系集合$R$\n\n- 关系符<$a_i$,$a_{i+1}$>为有序对\n- 表示任意两个相邻元素之间的先后次序\n\n$E.g.$ 有顺序表L={1,2,3,4,5,6}，若使用$L=(D,R)$表示，则$D={1,2,3,4,5,6}$,$R=<1,2>,<2,3>,...$\n\n线性表的特征：\n\n- 表头无前驱\n- 表尾无后继\n- 其余元素仅有一个直接前驱和直接后继\n\n顺序存储结构的特点：\n\n- 逻辑上相邻，则存储位置也相邻\n- 对元素的存取为随机存取或按地址存储\n- 存储密度高\n- 对表的插入和删除等运算的时间复杂度高\n\nC语言中，可借助一维数组类型来表述线性表的顺序存储结构\n\n```\n/*\n    * @brief:创建新线性表\n    * @param:无\n    * @return:线性表指针(sqlink类型)，申请失败返回NULL\n*/\nsqlink list_create()\n{\n    sqlink L;   //声明sqlink类型的表L\n    L = (sqlink)malloc(sizeof(sqlist));  // 为空表申请内存，返回分配的内存地址\n    \n    //判断内存是否申请成功\n    if (L == NULL)\n    {\n        printf(\"memory allocation failed\\n\");\n        return NULL;\n    }\n\n    memset(L, 0, sizeof(sqlist));   //L指向的sqlist结构体的内存清零\n    L->last = -1;   //表示线性表为空\n\n    return L;\n}\n\n/*\n    * @brief:清除线性表内的元素，全部置为零\n    * @param: L:指向表的指针\n    * @return:成功返回0，失败返回-1\n*/\nint list_clear(sqlink L)\n{\n    //判断是否是空表\n    if (L == NULL)\n    {\n        return -1;\n    }\n\n    memset(L, 0, sizeof(sqlist));   //L指向的sqlist结构体的内存清零\n    L->last = -1;   //last置为-1，表示线性表为空 \n\n    return 0;\n}\n\n/*\n    * @brief:判断线性表是否为空表\n    * @param: L:指向线性表的指针\n    * @return:空表返回1，非空表返回0\n*/\nint list_empty(sqlink L)\n{\n    //判断是否为空表\n    if (L->last == -1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n/*\n    * @brief:求线性表的长度(有效元素个数)\n    * @param: L:指向线性表的指针\n    * @return:表不存在返回-1，否则返回长度\n*/\nint list_length(sqlink L)\n{\n    if (L == NULL)\n    {\n        return -1;\n    }\n    return (L->last + 1);   //长度为表尾下标加1\n}\n\n/*\n    * @brief:向线性表内插入数值，插入后原位置向后的所有元素后移一位\n    * @param: L:指向线性表的指针 \n    * @param: value:待插入值 \n    * @param: pos:插入位置\n    * @return:插入成功返回0，失败返回-1\n*/\nint list_insert(sqlink L, data_t value, int pos)\n{\n    if (L == NULL) return -1;   //表不存在返回-1\n    //判断线性表是否满\n    if (L->last == N - 1)\n    {\n        printf(\"table is full\\n\");\n        return -1;\n    }\n    //检查插入位置是否正确，应属于[0,last]，如果是空表则不检查\n    if (pos < 0 || pos >= L->last + 1)\n    {\n        if (L->last != -1) \n        {\n            printf(\"pos is illegal\\n\");\n            return -1;\n        }\n\n    }\n    //向后移动原有元素，从最后一个元素开始\n    for (int i = L->last; i >= pos; i--)\n    {\n        L->data[i+1] = L->data[i];\n    }\n    //更新插入值和last\n    L->data[pos] = value;\n    L->last++;\n\n    return 0;    \n}\n\n/*\n    * @brief:遍历并打印线性表内元素\n    * @param: L:指向线性表的指针\n    * @return:成功返回0，失败返回-1\n*/\nint list_show(sqlink L)\n{\n    if (L == NULL) return -1;   //判断是否为有效表\n    if (L->last == -1) printf(\"table is empty\\n\");  //判断是否为空表\n    //遍历并打印\n    for (int i = 0; i <= L->last; i++)  //注意是小于等于，不然不显示表尾\n    {\n        printf(\"%d \",L->data[i]);\n    }\n\n    return 0;\n}\n\n/*\n    * @brief:删除全表，包括创建表时所分配的内存\n    * @param: L:指向线性表的指针\n    * @return:表不存在返回-1，成功返回0\n*/\nint list_delete(sqlink L)\n{\n    if (L == NULL) return -1;\n    free(L);    //释放为表L申请的内存\n    L = NULL;   //标记表L为无效表\n    return 0;\n}\n\n/*\n    * @brief:删除表中某一位置的元素\n    * @param: L：指向线性表的指针\n    * @param: pos：待删除元素位置\n    * @return:删除成功返回0，失败返回-1\n*/\nint list_delete_single(sqlink L, int pos)\n{\n    if (L == NULL) return -1;   //判断是否为无效表\n\n    //判断pos是否位于有效范围内 应为[0,last]\n    if (pos < 0 || pos > L->last)\n    {\n        printf(\"pos is illegal\\n\");\n        return -1;\n    }\n\n    //[pos+1,last]区间内已有元素前移\n    for (int i = pos + 1; i < L->last + 1; i++)\n    {\n       L->data[i-1] = L->data[i];   //数据前移，自动覆盖\n    }\n\n    //更新last\n    L->last--;   \n\n    return 0;\n}\n\n/*\n    * @brief:合并两个线性表，L2全表元素置于L1元素之后\n    * @param: L1：指向待合并线性表L1的指针\n    * @param: L1：指向待合并线性表L2的指针\n    * @return:合并成功返回0，失败返回-1\n*/\nint list_merge(sqlink L1, sqlink L2)\n{\n    int count = 0;\n    if (L1 == NULL || L2 == NULL) return -1;\n\n    //判断合并后L1是否越界\n    if (L1->last + 1 + L2->last + 1 > N) printf(\"table is too big\\n\");\n\n    //L2的第i位加到L1的last+1+i位置，总共传递L2->last个数\n    for (int i = 0; i <= L2->last; i++)\n    {\n        L1->data[L1->last+1+i] = L2->data[i];\n        count++;    //计数\n    }\n\n    //更新L1->last为原last值+传递完成的元素个数\n    L1->last = L1->last + count;\n\n    return 0;\n}\n\n/*\n    * @brief:查询线性表中是否存在某一元素\n    * @param: L：指向待查询线性表L的指针\n    * @param: value：待查询值\n    * @return:值对应的元素存在返回1，不成功返回-1\n*/\nint list_locate(sqlink L, data_t value)\n{\n    int i = 0;\n\n    //搜索L中是否有元素等于value\n    for (i = 0 ; i <=L->last; i++)\n    {\n        if (L->data[i] == value) return 1;\n    }\n\n    return -1;\n}\n\n/*\n    * @brief:查找L1和L2中是否有相同的元素，将不同的元素存于新表L3\n    * @param: L1：指向待合并线性表L1的指针\n    * @param: L2：指向待合并线性表L2的指针\n    * @return:合并成功返回0，失败返回-1\n*/\nsqlink list_mergetonewtable(sqlink L1, sqlink L2)\n{\n    sqlink L3 = list_create();  //创建新表L3\n    int i = 0;\n    int ret;\n\n    if (L1 == NULL || L2 == NULL) \n    {\n        printf(\"no such table\");\n        return NULL;\n    }\n    //遍历L2内元素\n    while (i <= L2->last)\n    {\n        ret = list_locate(L1, L2->data[i]);   //查找L1中是否有L2中的第i个元素，即判断是否重复\n        //某元素不重复则向L3插入\n        if (ret == -1)\n        {\n            list_insert(L3, L2->data[i], L3->last+1);   //按顺序向L3插入非重复值\n        }\n        i++;    //更新索引\n    }\n    return L3;\n}\n\n/*\n    * @brief:清除线性表内的重复元素，清除后所有元素前移补空\n    * @param: L：指向待合并线性表L1的指针\n    * @return:操作成功返回0，失败返回-1\n*/\nint list_purge(sqlink L)\n{\n    if (L == NULL) return -1;\n\n    for (int i = 0; i <= L->last; i++)  //遍历线性表\n    {\n        for (int j = i + 1; j <= L->last; j++)  //从索引i+1开始，如果i+1及之后的元素和data[i]相等，判断为重复\n        {\n            if (L->data[i] == L->data[j])\n            {\n                printf(\"The repeated elements are:%d\\n\",L->data[i]);\n                list_delete_single(L, j);   //删除重复的第j个元素\n                j--;    //回退索引，防止跳过未检查的元素\n            }\n        }\n    }\n    return 0;\n} \n```\n#### 线性表的顺序存储缺点\n- 要求系统提供一大片连续存储空间\n- 插入、删除等运算需要遍历整个内存，运算耗时，且元素可能在存储器中成片移动\n","categories":["数据结构"]},{"title":"十九阶同步发电机组模型降阶研究","url":"/2024/09/14/十九阶同步发电机组模型降阶研究/","content":"## 摘要\n本文介绍了一个二阶同步电机模型库，可用于电力系统动态性能分析和控制设计任务。这些模型的结构与经典模型相似，因为它们由两个动态状态组成，即功率夹角和角速度。然而，与经典模型不同，这些模型的应用范围不仅限于第一次摆动稳定性分析；例如，它们还可用于暂态稳定性研究。这些模型是通过使用奇异摄动技术系统地简化十九阶同步发电机组模型而开发的，并通过将其电压、频率和相位曲线与高阶模型和经典模型的电压、频率和相位曲线进行比较来验证。\n\n## 介绍\n同步电机的动态模型可用于电力系统分析、控制设计任务，每种应用都需要能够捕捉与预期用途相关的动态现象的模型。这导致文献中同步电机模型的激增，这些模型的复杂度、计算成本和状态空间维度各不相同。其中一种模型是之前研究提倡的所谓经典模型，这是一种二阶动态模型，可以捕捉电机相位和角速度的动态。\n\n从分析上看，经典模型是最简单的同步机动力学模型，但它具有某些局限性，限制了其应用于第一次摆动稳定性分析，即第一秒的稳定性分析。因此，如果我们考虑到电力系统在第一次摆动时可能稳定，但在后续摆动时不稳定，那么很明显，经典模型虽然简单，但对于超过一秒时间间隔的电力系统任务来说并不可靠。例如，发电机同步方案的设计需要一个模型来捕捉整个同步周期内发电机相位、频率和电压幅度的动态。二阶模型（如经典模型）应该能够满足要求，但如果同步周期超过一秒，第一次摆动稳定性约束可能会使其不适用。另一方面，虽然现有的高阶模型（如双轴模型和单轴模型）显然更准确，因此对电力系统仿真非常有用，但它们也更加复杂且计算成本高昂。因此，高阶模型通常难以分析此类控制设计任务。因此，需要开发既具有经典模型的简单性，又具有经典模型所缺乏的时间广度的模型。\n\n本文的主要贡献是开发了二阶同步发电机模型，与经典模型相比，该模型具有相同的状态空间维度，在长时间间隔内更精确，并且适​​用于更广泛的应用。使用奇异摄动分析作为主要工具，本文提出的二阶模型是通过以下方式推导出来的：(i) 识别高阶模型中最快的动态状态；(ii) 为它们开发近似流形方程（代数方程）；(iii) 用代数方程替换这些状态的微分方程。\n\n我们开发所提出的机器模型的方法是基于中的开发，其中使用快速动态状态的零阶和一阶流形近似来开发降阶模型。\n\n本文的其余部分安排如下。在第二部分中，我们介绍了一个同步机和一个高阶模型，该模型被用作开发降阶模型的起点；我们还讨论了经典模型。在第三部分中，我们使用奇异摄动分析从高阶模型开发了一个二阶模型库。最后，在第四部分中，我们使用数值示例验证了开发的二阶模型，在第五部分中，我们评论了所给出结果的含义。\n\n## 准备工作\n本节首先介绍本文采用的同步电机高阶模型。此外，还讨论了该模型的时间尺度特性。之后，我们介绍所谓的经典模型，并描述如何从高阶模型开发出该模型。\n\n### 高阶同步发电机模型\n本节中介绍的高阶同步机模型基于参考文献中的开发成果。模型中包含的组件包括：(i) 三个阻尼绕组，(ii) 绕线式转子结构同步发电机，(iii) IEEE DC1A 型励磁系统，以及 (iv) 伍德沃德柴油调速器 (DEGOV1)，与柴油发动机耦合，作为原动机。接下来，我们提供描述这些组件动态行为的数学表达式。（请注意，该模型采用 Park 变换后的dq0坐标系呈现，所有参数和变量均经过缩放，并使用单位系统进行归一化）。\n\n#### 阻尼绕组模型\n令 $\\psi_{kq}$ 和 $\\psi_{fq}$ 表示交轴阻尼绕组和交轴稳定绕组的磁链，令 $\\psi_{kd}$ 和 $\\psi_{fd}$ 分别表示直轴阻尼绕组和励磁绕组的磁链，令 A 和 B 分别表示定子输出电流的 q 轴和 d 轴分量。那么，阻尼绕组动力学可以描述如下：\n\n$$\nT_q'' p\\psi_{kq}=-\\psi_{kq}-(X_q'-X_k)I_q-E_d'\\\\\nT_d''p\\psi_{kd}=-\\psi_{kd}-(X_d'-X_k)I_d+E_q'(t)\n$$\n以及\n\n$$\nT_q'p\\psi_{fq}=-\\psi_{fq}+(X_q-X_q')(I_q-\\frac{X_q'-X_q''}{(X_q'-X_k)^2}(\\psi_{kq}+(X_q'-X_k)I_q-\\psi_{fq}))\n$$\n\n式中\n- $X_k$：电机漏电抗\n- $X_q$：电机定子电抗\n- $X_q'$，$X_d'$：电机瞬态电抗\n- $X_q''$:电机超瞬态电抗","categories":["电气工程"]},{"title":"十二相同步整流发电机的数学模型","url":"/2024/09/13/十二相整流发电机的数学模型/","content":"## 假设条件与正方向\n与常规同步发电机相比，多相整流发电机除了定子结构有差异，其转子也会有一定的区别。为了改善其运行稳定性,在常规同步发电机转子设置的励磁绕组($fd$)、d轴阻尼绕组($kd$)和q轴阳阻尼绕组($kq$)三套绕组基础上，还会布置q轴稳定绕组($fq$)。为了简化分析过程，并确保一定的分析精度，对十二相发电机的物理状态作如下基本假设:\n\n- 忽略铁心材料的饱和、磁滞及涡流影响，不计导线的集肤效应；\n- 忽略空间谐波磁场的影响，气隙磁场按正弦分布；\n- 忽略定、转子齿槽影响，认为定子和转子表面光滑；\n- 将转子上的阻尼回路看作两组等效的阻尼绕组，即$D$轴阻尼绕组和$Q$轴阻尼绕组。\n\n正方向规定如下：\n- 定子绕组电路采用发电机惯例，转子绕组电路采用电动机惯例；\n- 正方向的定子电流产生负的磁链，正方向的转子电流产生正的磁链；\n- 转子旋转正方向为逆时针方向，$q$轴正方向领先$d$轴正方向90°电角度。\n\n![](/images/12/4-1.png)\n\n![](/images/12/4-2.png)\n\n## abc坐标系下的基本方程\n磁链参数矩阵为：\n\n$$\n\\Psi_{abc}=\n\\begin{bmatrix}\n\\Psi_{a1} & \\Psi_{b1} & \\Psi_{c1} & \\Psi_{a2} & \\Psi_{b2} & \\Psi_{c2} & \\Psi_{a3} & \\Psi_{b3} & \\Psi_{c3} & \\Psi_{a4} & \\Psi_{b4} & \\Psi_{c4} & \\Psi_{fd} & \\Psi_{kd} & \\Psi_{fq} & \\Psi_{kq}\n\\end{bmatrix}^T\n$$\n式中前12项下标为12个相位的标号，后四项中\n- $\\Psi_{fd}$：励磁绕组磁链\n- $\\Psi_{kd}$：直轴阻尼绕组磁链\n- $\\Psi_{fq}$：交轴稳定绕组磁链\n- $\\Psi_{kq}$：交轴阻尼绕组磁链\n\n电压参数矩阵为\n$$\nu_{abc}=\n\\begin{bmatrix}\nu_{a1} & u_{b1} & u_{c1} & u_{a2} & u_{b2} & u_{c2} & u_{a3} & u_{b3} & u_{c3} & u_{a4} & u_{b4} & u_{c4} & u_{fd} & u_{kd} & u_{fq} & u_{kq}\n\\end{bmatrix}^T\n$$\n\n电流参数矩阵为\n$$\ni_{abc}=\n\\begin{bmatrix}\ni_{a1} & i_{b1} & i_{c1} & i_{a2} & i_{b2} & i_{c2} & i_{a3} & i_{b3} & i_{c3} & i_{a4} & i_{b4} & i_{c4} & i_{fd} & i_{kd} & i_{fq} & i_{kq}\n\\end{bmatrix}^T\n$$\n\n因直轴阻尼绕组、交轴阻尼绕组和交轴稳定绕组均短接，有$u_{kd}=u_{kq}=u_{fq}=0$。\n\n相应的磁链方程和电压方程为\n$$\n\\Psi_{abc}=L_{abci}i_{abc} \\\\ \nu_{abc}=p\\Psi_{abc}-R_{abc}i_{abc}\n$$\n式中\n$$\nL_{abc}=\n\\begin{bmatrix}\nL_{11} & L_{12} & L_{13} & L_{14} & L_{1r} \\\\\nL_{21} & L_{22} & L_{23} & L_{24} & L_{2r} \\\\\nL_{31} & L_{32} & L_{33} & L_{34} & L_{3r} \\\\\nL_{41} & L_{42} & L_{43} & L_{44} & L_{4r} \\\\\n-L_{1r}^T & -L_{2r}^T & -L_{3r}^T & -L_{4r}^T & L_{rr} \\\\\n\\end{bmatrix}\n$$\n式中$L_{ij},i=1,2,3,4;i=1,2,3,4$为分块矩阵，具体为\n$$\nL_{ij}=\n\\begin{bmatrix}\n-L_{aiaj} & -L_{aibj} & -L_{aicj} \\\\\n-L_{biaj} & -L_{bibj} & -L_{bicj} \\\\\n-L_{ciaj} & -L_{cibj} & -L_{cicj} \\\\\n\\end{bmatrix}\n$$\n矩阵中$-L_{aiaj}$表示$ai$相电枢绕组与$aj$相电枢绕组之间的互感/自感。因正方向中规定正方向的定子电流产生负的磁链，所以所有电感均带负号。\n\n同理，式中$L_{ir},i=1,2,3,4$也为分块矩阵，具体为\n$$\nL_{ir}=\n\\begin{bmatrix}\nL_{aifd} & L_{aikd} & L_{aifq} & L_{aikq} \\\\\nL_{bifd} & L_{bikd} & L_{bifq} & L_{bikq} \\\\\nL_{cifd} & L_{cikd} & L_{cifq} & L_{cikq} \\\\\n\\end{bmatrix}\n$$\n矩阵中$L_{aifd}$表示电枢$ai$相绕组与转子励磁绕组的互感，其余同理。因正方向中规定正方向的转子电流产生正的磁链，所以所有电感均为正。\n\n同理，式中$L_{rr}$表示转子各绕组之间的自感/互感，具体为\n$$\nL_{rr}=\n\\begin{bmatrix}\nL_{fd} & L_{fdkd} & 0 & 0 \\\\\nL_{fdkd} & L_{kd} & 0 & 0 \\\\\n0 & 0 & L_{fq} & L_{fqkq} \\\\\n0 & 0 & L_{fqkq} & L_{kq} \\\\\n\\end{bmatrix}\n$$\n矩阵中$L_{fd}$为励磁绕组的自感，$L_{fdkd}$为励磁绕组与直轴阻尼绕组的互感，其余同理。因为励磁绕组与交轴阻尼绕组、励磁绕组与交轴稳定绕组、直轴阻尼绕组与交轴阻尼绕组、直轴阻尼绕组与交轴稳定绕组的电角度夹角均为90$\\degree$，所以有$L_{fdkq}=L_{fdfq}=L_{kdkq}=L_{kdfq}=0$。\n\n电感矩阵中各量的详细表达式略。\n\n## dq0坐标系下的基本方程\n### 变换矩阵\n应用推广的三相电机Park变换，取变换矩阵为\n$$\nC^{abc}_{dq0}(\\theta)=\n\\begin{bmatrix}\nC_{11} & & & & \\\\\n& C_{22} & & & \\\\\n& & C_{33} & & \\\\\n& & & C_{44} & \\\\\n& & & & I \\\\\n\\end{bmatrix}\n$$\n式中$I$为$4\\times 4$的单位矩阵，其对应的变换对象为转子部分参数，显然该部分无需进行Park变换。\n\n式中，\n$$\nC_{ii}=\n\\frac{2}{3}\n\\begin{bmatrix}\n\\cos[\\theta-(i-1)15\\degree] & \\cos[\\theta-120\\degree-(i-1)15\\degree] & \\cos[\\theta+120\\degree-(i-1)15\\degree] \\\\\n-\\sin[\\theta-(i-1)15\\degree] & -\\sin[\\theta-120\\degree-(i-1)15\\degree] & -\\sin[\\theta+120\\degree-(i-1)15\\degree] \\\\\n\\frac{1}{2} & \\frac{1}{2} & \\frac{1}{2}\\\\\n\\end{bmatrix}\n$$\n\n### 电压方程\n展开dq0坐标系下的**有名值**电压方程式得\n$$\n\\begin{bmatrix}\nu_{d1} \\\\\nu_{q1} \\\\\nu_{01} \\\\\nu_{d2} \\\\\nu_{q2} \\\\\nu_{02} \\\\\nu_{d3} \\\\\nu_{q3} \\\\\nu_{03} \\\\\nu_{d4} \\\\\nu_{q4} \\\\\nu_{04} \\\\\nu_{fd} \\\\\nu_{kd} \\\\\nu_{fq} \\\\\nu_{kq} \\\\\n\\end{bmatrix}\n=\np\n\\begin{bmatrix}\n\\Psi_{d1} \\\\\n\\Psi_{q1} \\\\\n\\Psi_{01} \\\\\n\\Psi_{d2} \\\\\n\\Psi_{q2} \\\\\n\\Psi_{02} \\\\\n\\Psi_{d3} \\\\\n\\Psi_{q3} \\\\\n\\Psi_{03} \\\\\n\\Psi_{d4} \\\\\n\\Psi_{q4} \\\\\n\\Psi_{04} \\\\\n\\Psi_{fd} \\\\\n\\Psi_{kd} \\\\\n\\Psi_{fq} \\\\\n\\Psi_{kq} \\\\\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n-\\omega \\Psi_{q1} \\\\\n\\omega \\Psi_{d1} \\\\\n0 \\\\\n-\\omega \\Psi_{q2} \\\\\n\\omega \\Psi_{d2} \\\\\n0 \\\\\n-\\omega \\Psi_{q3} \\\\\n\\omega \\Psi_{d3} \\\\\n0 \\\\\n-\\omega \\Psi_{q4} \\\\\n\\omega \\Psi_{d4} \\\\\n0 \\\\\n0 \\\\\n0 \\\\\n0 \\\\\n0 \\\\\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n- r_s i_{d1} \\\\\n-r_s i_{q1} \\\\\n-r_s i_{01} \\\\\n- r_s i_{d2} \\\\\n-r_s i_{q2} \\\\\n-r_s i_{02} \\\\\n- r_s i_{d3} \\\\\n-r_s i_{q3} \\\\\n-r_s i_{03} \\\\\n- r_s i_{d4} \\\\\n-r_s i_{q4} \\\\\n-r_s i_{04} \\\\\nr_{fd} i_{fd}\\\\\nr_{fq} i_{fq}\\\\\nr_{kd} i_{kd}\\\\\nr_{kq} i_{kq} \\\\\n\\end{bmatrix}\n$$\n\n考虑基值选取中有$\\omega_B$的存在，将电压方程定子侧的第一个矩阵（磁链阵）除以之，可得$x_{ad}$基值系统下的**标幺值**定子电压方程：\n$$\n\n$$\n","categories":["电气工程"]},{"title":"机器学习基础","url":"/2024/09/09/机器学习基础/","content":"Machine Learning can be divided to :\n    - supervised learning\n    - unsupervised learning\n\n## Supervised learning\nNeeds data set with labels \n\nTO: predict unknown future output\n\n - **Classfication Problem (discrete)**: to predict a discrete output (say yes or no), e.g Cancer benign or malignant diagnosis\n\n - **Regression Problem (Continous)**: to predict a specific number, e.g Stock Price Prediction\n\n During a linear regression problem we have to solve a minimization problem, to minimize the difference between $x$ and $h(y)$.\n\n\n### Regression Problem\n\nTraining set + learning algorithm -> generate hypothesis function $h$\n\n$h$ takes input $x$ (e.g. size of house) and output $y$ (e.g. estimated selling price)\n\nCost Function: \n\n$$\nJ(\\theta_{0},\\theta_{1})=\\frac{1}{2m} \\Sigma (h_{\\theta}(x)-y)^2\n$$\n\nSigma from 1 to m (m equal to sample size)\n\n### Gradient Descent\nrepeat until convergence:\n$$\n\\theta_j  := \\theta_j -\\alpha\\frac{\\partial}{\\partial \\theta_j}J(\\theta_0 , \\theta_1)\n$$\n(for $j$ = 0 and $j$ = 1)\n:= means denote assignment\n$\\alpha$:learning rate, basically controls how big is a step when descent\n$\\theta_0$ and $\\theta_1$ have to be updated simultaneously\n\n### Linear Regression Algorithm\nTO: Apply gradient descent algorithm to minimize squared error cost function\n\n\"Batch\" gradient descent: each step of gradient descend uses all training examples\n\n### Multiple features (variables)\nHypothesis:$h_\\theta (x) = \\theta_T x = \\theta_0 x_0 + \\theta_1 x_1 ... + \\theta_n x_n$\nParameters:$\\theta_0,\\theta_1,...,\\theta_n$\nCost function:\n$$\nJ(\\theta_0,\\theta_1,...,\\theta_n) = \\frac{1}{2m}\\Sigma (h_\\theta(x^{(i)})-y^{(i)})^2\n$$\nSigma from i=1 to m\n\nGradient descent:\nrepeat fellow:\n$$\n\\theta_j  := \\theta_j -\\alpha\\frac{\\partial}{\\partial \\theta_j}J(\\theta_0 , \\theta_1)\n$$\n(simutaneously update for every $j$)\n\nAs a result new algorithm will be like fellow:\n\n$$\n\\theta_j := \\theta_j - \\alpha \\frac{1}{m} \\Sigma (h_\\theta(x^{(i)})-y^{(i)})^2 x_j^{(i)}\n$$\n(simultaneously update $\\theta_j$ for $j=0,1，...,n$)\nE.g from a data set with three features it may like follows:\n\n$$\n\\theta_0 := \\theta_0 - \\alpha \\frac{1}{m} \\Sigma (h_\\theta(x^{(i)})-y^{(i)})^2 x_0^{(i)}$$\n$$\n\\theta_1 := \\theta_1 - \\alpha \\frac{1}{m} \\Sigma (h_\\theta(x^{(i)})-y^{(i)})^2 x_1^{(i)}$$\n$$\n\\theta_2 := \\theta_2 - \\alpha \\frac{1}{m} \\Sigma (h_\\theta(x^{(i)})-y^{(i)})^2 x_2^{(i)}\n$$\n\n### Feature Scaling & Mean normalization\nIdea:make sure features are on a similiar scale.\n\nE.g. $x_1$ = size (0-2000 feet^2) while $x_2$ = number of bedrooms (1-5)\n\n\n### Learning rate\n- if $\\alpha$ is too small: slow convergence\n- if $\\alpha$ is too large: $J(\\theta)$ may not decrease on every iteration; may not converge\n\n\nMake sure gradient descent is working correctly.Final goal is converge the cost function.\n\n### Features and Polynomial Regression\nE.g. Housing prices prediction\n$$\nh_\\theta (x) = \\theta_0 + \\theta_1 \\times frontage + \\theta_2 \\times depth\n$$\nClearly frontage is the first feature $x_1$ and depth is the second feature $x_2$\n\nTo decide which feature is the most important factor to the housing price, thereafter a polynomial regression can be taken:\n$$\nh_\\theta (x) = \\theta_0 + \\theta_1 \\times frontage + \\theta_2 \\times depth^2\n$$\nthis formula can be written as:\n$$\nh_\\theta (x) = \\theta_0 + \\theta_1 \\times x_1 + \\theta_2 \\times x_2^2\n$$\nIn this case, feature scaling is becoming increasingly important to get them comparable.\n\n### Classification Problem (Discrete)\n\n#### Sigmoid Function\nWant outputs 0 or 1\n\n**Sigmoid Function(Logistic Function)**:\n$$\ng(z)= \\frac{1}{1+e^{-z}}\n$$ \n\n![](/images/ML/Sfunc.png)\n\nwhile $z$ can be written as vector($\\vec{w}$ is weights and $x$ is feature): \n$$\nz = \\vec{w}x + b\n$$\n\n#### Decision Boundary\n$$\nf_{\\vec{w},b}(x) = g(\\vec{w}x+b) = \\frac{1}{1+e^{-(\\vec{w}x+b)}}=P(y=1|x;\\vec{w},b)\n$$\n\nClearly the decision boundary is the threshold value of $f_{\\vec{w},b}(x)$.\n\n$x$ is also can be replaced by $\\vec{x}$ if there are multiple features.\n\nClearly the descision boundary is \n$$\n\\vec{w}x+b=0\n$$\n\n\n#### Cost Funciton\n\n![](/images/ML/logcost.png)\n\nSince MSE under logistic regression is a non-convex function, using MSE as cost function index may get \"stuck\" at the inflection point of the function, causing error.\n\nTarget:create or select a new cost function to make it convex.\n\nThe loss function of logistic regression uses the log-likelihood loss function, also known as the cross-entropy loss function, which is used to measure the difference between the model prediction and the true label. The loss function is defined as:\n\n$$\nL(\\theta) = - \\frac{1}{m} \\sum_{i=1}^{m} \\left[ y^{(i)} \\log h_{\\theta}(x^{(i)}) + (1 - y^{(i)}) \\log (1 - h_{\\theta}(x^{(i)})) \\right]\n$$\nwhile \n- $m$:sample amounts\n- $y^{(i)}$: true label (0 or 1) of sample $i$\n- $h_{\\theta}(x^{(i)})$: The model predicts the probability of sample $i$, i.e. $P(y=1|x^{(i)})$\n\nThe goal of this loss function is to minimize the gap between the predicted and actual labels.\n\n#### Training Logistic regression\nUse gradient descent to minimize the cost function $J(\\vec{w},b)$.\n\nwe have \n$$\n\\frac{\\partial}{\\partial w_j} J(\\vec{w},b) = \\frac{1}{m} \\sum_{i=1}^{m} \\left[ f_{\\vec{w},b}(\\vec{x}^{(i)}-y^{(i)})\\right]x_j^{(i)} \n$$\nand\n$$\n\\frac{\\partial}{\\partial b} J(\\vec{w},b) = \\frac{1}{m} \\sum_{i=1}^{m} \\left[ f_{\\vec{w},b}(\\vec{x}^{(i)}-y^{(i)})\\right]\n$$\nwhat we need to do is update them simultaneously.\n\n\n## Unsupervised learning\nNeeds data set without labels\n\nTO: Automatically discover the internal patterns or structures of data, such as dividing data into different clusters, revealing the inherent laws of data, or simplifying data representation.\n\n**Example** : Extracting vocals from audio\n\n## 决策树(Decision Tree)\nE.g.：判断动物是否为猫\n![](/images/ML/DT.png)\n决策树训练步骤\n- 确认第一个决策节点(Node)后对样本进行分类 例如：待检测动物的耳朵是圆的还是尖的\n- 确认剩下的节点\n\n需要解决的问题\n- 如何确定每个节点所用来进行分类的特征(Feature)？如：是根据耳朵类型进行分类还是根据体型进行分类\n- 什么时候停止继续分类（split）？\n  + 某节点能够做到100%的分类时（如有猫DNA的动物一定是猫，不可能是其他）\n  + 某节点之后决策树溢出\n- 继续进行决策所带来的提升低于阈值\n- 节点中的样本数量过少","categories":["深度学习"]},{"title":"以TPS5430为例进行DC-DC选型与设计","url":"/2024/08/19/以TPS5430为例进行DC-DC选型与设计/","content":"*原文来自德州仪器（TI）*：[TPS5430 Datasheet](https://www.ti.com.cn/product/cn/TPS5430?bm-verify=AAQAAAAJ_____9dYxHNK53iaDtVqyxPQxRcsrzMOM-c86S6ivd470tCxI7v2y_3iLaQxnR81kWkBePuyKvYKyC-Kf15mbkeVGi8nAGHJ0TZ3ENp-6GgUlTcvMy_qdx-euoFt1ZFv6JxkzW-Dd3OlaLFZQaxAsFpiD3EHrvgSZyrsjhPFZukuNU6g3lsGi53NSBPq24SEFjJVkxhff7hPbsSkYNRWKgMWat5cOPLkdhhwYkWjjWZCYxQ19lVbHzjbGrfD90mIptd-Xo2P9gBYm2ZBpeDhZ5g5dlGNhcbA7Z9fEjLipdCzrhXmW1HXWL3ZbWTD)\n\n\n本文将以德州仪器（TI）TPS5430 降压DC-DC转换器为例，剖析手册中的参数与技术指标，并进行选型方面的介绍，同时简要介绍高频DC-DC设计相关内容。\n\n## 特性\n- 宽输入电压范围：\n  + TPS5430：5.5V 至 36V\n  + TPS5431：5.5V 至 23V\n\n- 高达 3A 的连续（4A 峰值）输出电流\n- 通过 100mΩ 集成式 MOSFET 开关实现高达 95%的高效率\n- 宽输出电压范围：可调节为低至 1.22V，初始精度为 1.5%\n- 内部补偿可最大限度减少外部器件数量\n- 适用于小型滤波器尺寸的固定 500kHz 开关频率\n- 通过输入电压前馈改进线路调整和瞬态响应\n- 系统受过流限制、过压保护和热关断的保护\n- –40°C 至 125°C 的工作结温范围\n- 采用小型热增强型 8 引脚 SO PowerPAD™ 集成电路封装\n- 使用 TPS5430 并借助 WEBENCH® Power Designer 创建定制设计\n\n## 应用\n- 消费类：机顶盒、DVD 显示屏、LCD 显示屏\n- 工业用和车载音频电源\n- 电池充电器、大功率 LED 电源\n- 12V 和 24V 分布式电源系统\n\n## 说明\nTPS543x 是一款高输出电流 PWM 转换器，集成了低电阻、高侧 N 沟道 MOSFET。具有所列的特性的基板上还包括高性能电压误差放大器（可在瞬态条件下提供高稳压精度）、欠压锁定电路（用于防止在输入电压达到 5.5V 前启动）、内部设置的慢启动电路（用于限制浪涌电流）以及电压前馈电路（用于改进瞬态响应）。通过使用 ENA 引脚，关断电源电流通常可减少到15μA。其他特性包括高电平有效使能端、过流限制、过压保护和热关断。为降低设计复杂性并减少外部元件数量，对 TPS543x 反馈环路进行内部补偿。TPS5431可采用高达 23V 的电源轨运行。TPS5430 可调节多种电源，包括 24V 总线。\n\nTPS543x 器件采用热增强型且易于使用的 8 引脚 SOIC PowerPAD 集成电路封装。TI 提供评估模块和Designer 软件工具，协助快速实现高性能电源设计，满足迫切的设备开发周期要求。\n\n![简化原理图与效率-输出电流关系](/images/dcdc/1.png)\n\n> 有关*效率*：DC-DC转换器的效率（Efficiency）表示输入功率中有多少被成功转换为输出功率，而非被损耗。它通常以百分比表示。效率高意味着大部分能量都被有效转换，只有少量能量因开关损耗、导通损耗、磁损耗等形式而被消耗为热量。DC-DC 转换器的效率通常会随着输入电压、输出电流、负载条件等变化而有所不同。一般来说，DC-DC 转换器的效率可以达到 85% 至 95% 甚至更高。较高的效率在电源设计中至关重要，因为它直接影响系统的功耗和热管理设计。\n\n## 引脚配置和功能\n\n![引脚配置和功能](/images/dcdc/2.png)\n\n> *应当注意*：\n> - **VSENSE**：反馈回路对噪声敏感，应当在PCB设计时进行特殊处理。\n> - **ENA**：与其他型号的IC不同，TPS5430的使能在悬空（Float）时开启，低于0.5V即外部拉低时关闭。不过经验表明ENA被外部上拉时也能够开启使能。\n> - **PH**：即输出端。IC内部集成有N-MOSFET，其源极（S）即连接至PH引脚。\n\n## 规格\n### 绝对最大额定值\n![绝对最大额定值](/images/dcdc/3.png)\n\n> *应当注意*：\n> - 所有输入引脚禁止反接，即使设计有外部反接保护电路。\n> - ENA引脚上拉后输入不得超过7V。\n> - 接近 VIN 引脚的绝对最大额定值可能会导致 PH 引脚上的电压超过绝对最大额定值。\n> - IC输出端可能会在瞬态出现负电压脉冲，其一般由高di/dt与寄生电感共同作用引起。参见：[如何解决负压脉冲](https://www.novosns.com/technical-articles-163)\n> - 表中的“拉电流”原文为“Source Current”，通常指的是FET向负载提供电流的能力。在开关模式中，FET在导通时从电源“拉”电流并传输到负载。当MOSFET处于关闭状态时，PH 引脚会呈现高阻抗状态。表中 PH 漏电流指的是在这种高阻抗状态下，PH 引脚仍然有少量的电流从引脚流出或流入（一般是流出）。手册中标注的 10 $\\mu A$ 漏电流，表示在开关管关闭时，PH 引脚由于漏电效应产生的微小电流。这种电流通常很小，不会对系统性能造成显著影响，但在某些对精度要求较高的应用中，这些小电流可能需要考虑。\n\n### ESD Ratings\n静电放电测试项，此处略。\n\n\n","categories":["电子与电路设计"]},{"title":"电机驱动类PCB布局的最佳实践","url":"/2024/08/14/电机驱动类PCB布局的最佳实践/","content":"*原文转自德州仪器（TI）Application Note*\n# 简介\n电机驱动系统的 PCB 设计并非易事，需要特殊的考虑和技术才能实现最佳性能。电源效率、高速开关频率、低噪声抖动和紧凑的电路板设计是设计人员在布局电机驱动系统时必须考虑的几个主要因素。德州仪器的 DRV 设备非常适合此类系统，因为它们高度集成且配备了保护电路。本应用报告的目标是强调使用 DRV 设备时电机驱动布局的主要因素，并为高性能解决方案提供最佳实践指南，以减少热应力、优化效率并最大限度地降低电机驱动应用中的噪音。\n\n# 接地优化\n任何良好的接地方案的目标都是为 IC 及其周围电路提供稳定的参考（Reference），而不受噪声和其他振荡的影响。本节介绍不同的接地技术、接地的常见挑战、使用接地平面的最佳方式以及双层板的接地注意事项。\n## 常用术语/连接方式\n本节中使用的术语定义如下：\n\n- **单点接地（Single Point）**：在单点分布中，所有参考点都源自同一源，从而确保每个负载都有自己的不间断接地路径（见图 1-1 右）。建议将此连接用于电源分布线。\n\n- **星形接地（Star Ground）**：在星形接地分布中，所有参考点都位于中心；但是，源可能不集中。此方法平衡了所有资源之间的公共阻抗（图 1-1 左）。建议将此连接用于信号线。\n\n![图1-1 星形接地与单点接地的功率分布](/images/siva/1-1.png)\n\n- **分区（Partitioning）**：在使用分区接地方案的PCB中，数字、模拟和高功率信号有自己独立的区域（见图 1-2）。这种分离不是数字和模拟接地的物理分区。\n\n- **网格化（Grid）**：网格化使整个电路板上的接地路径连续，以确保每个信号都有一条返回源的路径（见图 1-3）。这种做法涉及对元件放置、接地填充、过孔放置和走线路径进行细微更改，以最大限度地减少返回地面的路径。网格化有效地创建了一个更加互连的接地平面，可以降低噪声并降低电源和负载之间的阻抗。\n\n![图1-2 数字-模拟地分离与地平面分区](/images/siva/1-2.png)\n\n图 1-3 显示了使用接地网格实现有效接地平面的示例。在布局中实施网格化所做的更改很小，这表明小的改动可以产生大影响。\n\n![图1-3 将地面填充和走线网格化以形成接地平面](/images/siva/1-3.png)\n\n在图 1-3 的示例中，布局 A 和布局 B 是顶层和底层，只留下接地填充、接地走线和前后层之间的过孔。图 1-3 中的布局 C 是电路板接地布线的简单棒状图。每根棒状图或腿代表接地导体的路径。大多数走线仅在一端连接。移除大多数单端走线后，图 1-3 中的布局 D 显示了整个电路板上的接地布线方式；布线上任意两点之间只有一条路径。\n\n图 1-3 中的布局 E、布局 F、布局 G 和布局 H 显示了为实现网格接地而修改的设计。在图 1-3 中的布局 E 和布局 F 中添加了一些走线（以实心黑色显示）并移动了几何图形（由箭头指示）。图 1-3 中的布局 G 显示了修改后的接地棒状图。两端连接的完整走线形成更完整的导体。比较图 1-3 中的布局 H 和布局 D，网格接地已创建了广泛的互连网络，从而创建了所需的网格。其效果几乎与实际接地平面一样有效。\n\n## 使用地平面\n在 4 层板或更大的 2 层板设计中，建议使用接地平面。将 PCB 的一层作为连续接地平面可使每个信号具有最短的返回路径，并减少耦合和干扰。建议通过仔细布线信号线来尽量减少接地平面的不连续性，并将过孔彼此分开以防止平面中断。有关过孔放置的更多信息，请参阅下文。\n\n大多数 DRV 设备都有一个用作接地的导热焊盘，并使用接地铜来散热。图 1-4 显示了公共和分离接地平面的良好布局示例。\n\n![图1-4 公共接地平面与分离接地平面](/images/siva/1-4.png)\n\n*注意*：如果设计是空间受限的 2 层电路板，则接地平面并不总是可行的。在这种情况下，PCB 布局变得更加重要。必须小心谨慎，确保高电流路径远离敏感信号。PCB 的噪声部分（例如功率级 FET、自举电路和电荷泵）通常包含高噪声和纹波，应与此类信号隔离。\n\n## 常见问题\n### 电容和电感耦合\n当两条走线平行延伸时，即使距离很短，也可能发生电容或电感耦合。当一条走线的上升沿导致另一条走线的上升沿时，就会发生电容耦合。当一条走线具有上升沿或下降沿，而第二条走线具有耦合的下降沿或上升沿时，就会发生电感耦合。电容耦合比电感耦合更频繁地发生。\n\n耦合的严重程度取决于走线的长度、开关频率、电压变化和走线之间的距离。为了减少电容耦合，请将嘈杂的信号走线远离重要的数字和模拟信号。尝试在接地平面上布线。\n\n在带有预驱动器的开关应用中，必须特别注意确保预驱动器的高电流承载接地平面与 IC 其余部分的接地平面物理隔离。这两个地可以在星形点或单点接地位置连接，如上一节所述。\n\n### 共模噪声和差模噪声\n差模噪声沿着迹线传播到接收设备，然后通过返回路径返回到源，从而导致两条迹线之间产生差分电压。当信号和返回路径上都产生电压时，就会发生共模噪声，这是由于共用阻抗上的电压降引起的。地弹就是共模噪声的一个例子。通过确保所有返回源的路径都是宽、短且阻抗低的迹线，可以大大降低发生此问题的可能性。\n\n![图1-5 差模噪声与共模噪声](/images/siva/1-5.png)\n\n### 考虑EMC\n电磁兼容性 (EMC) 主要取决于布局和组件之间的电气连接。\n\n每个信号的返回路径必须从资源流向信号源，从而产生电流环路。该线路环路会形成一个天线，可以辐射电磁能量，该能量由电流幅度、信号的重复频率和电流环路的几何面积决定。建议尽量减少这些电流环路以获得最佳 EMC 性能，图 1-6 显示了常见的电流环路类型。\n\n![图1-6 系统中的电流路径](/images/siva/1-6.png)\n\n图 1-6 中的电源线形成环路 A–C–D–B 和 A–E–F–B。系统运行所需的能量由这些线路传导。\n\n环路 L-M-F-D、N-Q-P-F 和 G-H-J-K 由信号和控制形成。如果不考虑系统外部的线路，这些线路所包围的面积通常很小。但是，必须在高频下考虑这些线路，因为它们通常会传输会影响 EMC 性能的信号。\n\n当连接器、接头或其他组件破坏接地平面时，也会形成电流环路。这会导致开关电流的高频分量在电路板周围传播得更远，从而有效地形成一个大环路。这种情况也可能发生在过孔中。\n\n# 热效应\n电机驱动器并非理想设备，在实际应用中，部分功率会以热量的形式在内部耗散。必须在驱动器损坏之前处理转换为热量的能量。正确的 PCB 设计可以有效消除效率低下产生的热量，并使设备保持在推荐温度。\n\n## PCB 传导和对流\n电机驱动器热性能的一个重要考虑因素是设备内部产生的热量可以消散的路径。热量从芯片传到较低温度环境的主要路径有三条：\n- 封装材料\n- 键合线\n- 导热 Pad\n\n以这三条路径为例，导热焊盘是热量从设备传出的最有效路径，其次是封装材料，最后是键合线。导热焊盘集成电路封装中使用的技术从芯片到外部铜平面创建了一条低热阻路径。因此，导热焊盘可以有效地将大量热量从芯片传导出去。驱动器下方的导热焊盘应足够大，以覆盖导热焊盘的整个区域，并且仍然包括 PCB 其他部分的大表面积。导热焊盘还应紧密结合到底部接地平面，并在导热焊盘正下方放置几个导热过孔。图 2-1 显示了设备芯片中产生的热量使用的出口路径示例。\n\n![图2-1 导热焊盘封装的横截面以及由此产生的热传递](/images/siva/2-1.png)\n\n将顶部和底部接地平面连接到驱动器的导热焊盘可显著提高 PCB 设计中的散热量。因此，在布局中应将这些平面做得尽可能大。\n\n## 连续Top-Layer导热焊盘\n将导热焊盘连接到实心铜平面是创建驱动器芯片产生的热量出口路径的重要要求。为了使热量从设备中流出，铜平面必须从导热焊盘连续到电路板上的其他区域。最佳做法是包括一条从驱动器下方的铜填充到宽阔的高表面积平面的宽出口路径。如果这些平面被中断，热量的出口路径就会收缩，从而增加热阻。热阻的增加会导致导热焊盘和同一平面上更宽的表面积之间的温差更大。图 2-2 显示了驱动器下方收缩和连续接地浇注引起的温升示例。\n\n![图2-2 破碎地与连续地浇注热图](/images/siva/2-2.png)\n\n在驱动器下方放置连续的铜导热焊盘对于设备高效冷却非常重要。\n将宽路径整合到高表面积平面可使驱动器导热焊盘和环境空气温度之间的热阻保持在最低水平。\n\n## 铜厚 （Copper Thickness）\n虽然连续、宽阔的平面会降低热阻，但平面上的铜厚度也是 PCB 热性能的关键考虑因素。通过增加 PCB 上的铜镀层厚度，平面的有效热阻会降低。下式可计算铜厚度与平面面积之间的关系：\n\n$$\n\\theta_{cu}=(\\frac{1}{\\lambda_{cu}}\\times length ) / Area\n$$\n\n假设长度和宽度为 1 厘米，镀层厚度为 1 盎司 (0.0035 厘米)，则与驱动器横向连接的铜平面的近似热阻可按照下式计算：\n\n$$\n\\theta_{cu}=(\\frac{1}{\\lambda_{cu}}\\times length ) / Area = (25 ℃ \\quad cm/W \\times 1 cm) / 1 cm \\times 0.0035 cm =71.4 ℃/W\n$$\n\n如果铜厚度加倍，相同尺寸平面的热阻就会减半。连接到驱动器的接地平面上的铜厚度越厚，有助于高效地将热量从设备传导到周围空气中，而不会导致电路板上出现明显的温差。\n\n## 散热过孔连接方式（Thermal via Connections）\n散热过孔应将顶层和底层连接在一起，以便热量可以从 IC 散发到两层。散热过孔不应使用*热风焊盘*（Thermal Relief，即十字花焊盘，为了防止因散热过快而导致的虚焊，在电源和地的过孔采用十字花的工艺连接，减少了接触面积，降低了散热速度，方便焊接）连接，因为热量从顶层通过通孔流到底层的路径受到限制。这种热流路径的收缩导致通孔周围顶层剩余部分的温度升高。直接连接通孔可使通孔和铜层之间的热阻尽可能低。散热通孔应与内部接地平面连接，并在镀通孔的整个圆周周围进行完整连接。不要用焊料掩模覆盖通孔，否则会导致过多的空洞。图 2-3 显示了散热通孔和直接连接通孔之间的温差。\n\n*参见*：[如何使引脚接地为十字焊盘，但过孔为完全接地?](https://ee.ofweek.com/2021-01/ART-11000-2800-30482578.html)\n\n![图2-3 热风焊盘（右）与直接过孔连接（左）热力图](/images/siva/2-3.png)\n\n散热焊盘接头将平面与过孔或组件电连接起来，但它们会减少组件或过孔与平面之间的热流。这样做的目的是让烙铁或回流炉只加热组件并确保可靠的焊接连接。这种方法对于不需要过孔在平面之间进行热传导的应用非常有效。然而，电源应用（例如电机驱动器）要求将这些过孔直接粘合到平面上，以实现层间的最佳热性能。\n\n## 散热过孔宽度 （Thermal Via Width）\n虽然导热焊盘在芯片和 PCB 顶部接地平面之间提供了低阻抗热路径，但应考虑连接顶部和底部接地平面的过孔的热阻抗。**德州仪器建议在导热焊盘正下方设置直径为 20 mil 的导热过孔，孔径为 8 mil。**\n\n减小散热孔的直径或增加孔的尺寸会增加热阻。建议的 8 mil 孔尺寸和 20 mil 直径需要从散热焊盘到底层的最小焊料芯吸，并将过孔的热阻保持在最低水平。图 2-4 显示了推荐的过孔放置位置。\n\n![图2-4 散热过孔放置](/images/siva/2-4.png)\n\n## PCB散热设计小结\n总结一下热设计，电机驱动器系统中热设计的主要考虑因素如下：\n- 导热焊盘（Thermal Pad）连接是器件芯片导热的最有效途径\n- 使用从导热焊盘到接地平面的连续顶层灌注\n- 尽可能使用 1.5 或 2 盎司铜厚\n- 使用直接连接热通孔\n- 使用 8 mil x 20 mil 的导热过孔（Via）尺寸，以避免过多的焊料渗入\n- 将热通孔分组为阵列，以最小化平面之间的热阻\n\n# 过孔（Vias）\nPCB 上的通孔在电路板的不同层上具有两个位于相应位置的焊盘，它们通过穿过电路板的孔进行电连接。该孔通过电镀制成导电的。有几种类型的通孔，例如盲孔、埋孔和热孔。对于电机驱动器 PCB 设计，重点是普通通孔和热孔。\n\n通孔经常用于信号轨道和电源轨道的 PCB 布线。对于信号连接，电流很小（微安到毫安），一个或两个通孔可能足以将信号路由到另一层。对于电源连接，可以在电源或接地迹线上添加多通孔或“通孔拼接”，以确保层间以及电源和接地平面之间的低阻抗连接。还可以添加多通孔以将设备产生的热量散发到其他电路板层，如第上一节所述。\n\n![图3-1 底部铜平面的过孔连接](/images/siva/3-1.png)\n\n## 过孔电流承载量（Via Current Capacity）\n在电机驱动器 PCB 设计中，多通孔通常用于层间高电流连接。提供适当的通孔尺寸和数量以实现低电阻和长期可靠性非常重要。通常，通孔的直径至少应为走线的长度。在使用铜平面作为走线的情况下，多个通孔应位于电流进入或离开元件引脚的位置附近。\n\n下表列出了按照 IPC-2152 标准，1 盎司 PCB 在温度升高 10°C 时不同通孔直径的电流容量。\n\n| Via \t Diameter \t| Current Capacity \t|\n|:-----------:\t|:---------------:\t|\n|  6  \t    mil   \t|   0.2       A    \t|\n|  8  \t   mil   \t|   0.55      A    \t|\n|  10 \t   mil   \t|   0.81      A    \t|\n|  12 \t    mil   \t|   0.84      A    \t|\n|  16 \t   mil   \t|   1.1       A    \t|\n\n## 过孔布局建议\n### 多过孔布局\n多通孔对于低寄生接地和大电流连接非常有用。图 3-2、图 3-3 和图 3-4 显示了多通孔放置在电路板设计的不同位置的示例。\n\n![图3-2 用于去耦接地的多通孔](/images/siva/3-2.png)\n\n![图3-3 用于电流检测接地的多通孔](/images/siva/3-3.png)\n\n![图3-4 用于大电流连接的多通孔](/images/siva/3-4.png)\n\n### 过孔放置\n尽管过孔很小，但它们会占用 PCB 和接地平面上的空间。将多个过孔布线在一起会在平面上产生间隙，并影响电流和接地回路。良好的过孔布局可为所有信号创建充足的返回路径。图 3-5 显示了如何避免过孔造成不必要的接地平面分裂的示例。\n\n![图3-5 避免过孔分裂接地平面](/images/siva/3-5.png)\n\n# 通用布线技巧\n在进行电机驱动器 PCB 设计时，请遵循以下通用布线技术：\n\n- 使栅极驱动器走线尽可能宽且长度尽可能短。对于至少 1 盎司铜，从 20 密耳的走线宽度开始，如果大电流需要，则走线宽度可以更大。\n\n![图4-1 DRV8323xEVM 栅极信号线](/images/siva/4-1.png)\n\n- 高端FET栅极的信号走线应当尽可能靠近开关节点走线，以尽量减少电感、环路面积以及 dv/dt 开关引起噪声的可能性。\n\n![图4-2 平行栅极信号线](/images/siva/4-2.png)\n\n- 不要使用直角走线。走线中的 90 度弯曲会起到阻抗的作用，并可能导致电流反射。当电机的相位切换时，急弯可能会引发电磁干扰 (EMI) 问题。圆形弯曲是理想的，但在实际设计中可能不切实际。拐角布线的最佳做法是使用钝角。图 4-3 显示了走线中不同角度的示例。\n\n![图4-3 正确的走线角度](/images/siva/4-3.png)\n\n- 将过孔过渡到焊盘，特别是将输出引脚上的细线过渡到粗线。泪滴（Teardrop）技术可降低信号转换的热应力。该技术还可避免线的开裂，并使线在机械上更坚固。泪滴技术适用于从小信号过渡到通孔焊盘的情况。\n\n![图4-4 过孔至焊盘的过渡](/images/siva/4-4.png)\n\n- 绕物体布线时，应以平行对的方式布线，以避免因分叉布线而导致的差分阻抗和不连续性。这种方法对于电流检测放大器的信号非常重要。\n\n![图4-5 平行走线](/images/siva/4-5.png)\n\n- 将无源元件（例如源匹配电阻或交流耦合电容）放置在信号路径内，并将它们并排放置。平行放置元件可产生更宽的走线间距。不建议交错放置元件，因为这会造成狭窄的区域。\n\n![图4-6 推荐的元器件放置](/images/siva/4-6.png)\n\n- 将电路的模拟部分和数字部分分开接地是抑制噪声的最简单、最有效的方法之一。\n\n![图4-7 数字地与模拟地的隔离](/images/siva/4-7.png)\n\n# Bulk电容和旁路电容的放置\n## Bulk电容放置\n在电机驱动系统设计中，Bulk电容器（大容量电容器）可最大限度地减少低频电流瞬变的影响，并存储电荷以提供电机驱动器切换时所需的大电流。选择Bulk电容器时，请考虑电机系统所需的最高电流、电源电压纹波和电机类型。\n\n使用Bulk电解电容帮助从通过电机绕组驱动的电流中获取低频、高值电流。这些电容器通常大于 10 μF，具体取决于应用要求。\n\n将所有Bulk电容器放置在电源模块或电路板的电源入口点附近。TI 建议每个Bulk电容器都有多个通孔将焊盘连接到相应的电源层。TI 还建议所有Bulk电容器都具有低等效串联电阻 (ESR)。\n\n![图5-1 Bulk电容多过孔放置](/images/siva/5-1.png)\n\n![图5-2 Bulk电容和旁路电容放置](/images/siva/5-2.png)\n\n## 电荷泵电容器（Charge Pump Capacitor）和自举电容\nTI 的大多数电机驱动设备 (DRVxx) 都使用电荷泵或自举电容器来完全切换高侧 N 沟道 MOSFET 的栅极。将这些电容器放置在尽可能靠近电机驱动设备的位置。在图 5-3 中，C4 电容器是用于从 VM 到 VCP 引脚的电荷泵输出的电容，而 C7 电容器是用于电荷泵切换节点的电容。\n\n![图5-3 电荷泵电容放置](/images/siva/5-3.png)\n\n## 旁路（Bypass）/解耦（Decoupling）电容放置\n### 靠近电源\n旁路电容用于将高频噪声最小化，以减少进入 DRV 器件电源引脚的噪声。TI 建议将电容尽可能靠近器件的电源输入引脚和接地引脚。如果旁路电容和器件之间的走线长度没有最小化，它们可能会在旁路电容要过滤的高频下产生电感。走线电感增加的阻抗可能导致电源引脚处的电压或电流产生振铃，从而导致 EMI 并影响数字或模拟电路的性能。最佳做法是将值较小的电容尽可能靠近器件放置，以最大限度地减少走线电感的影响。将值较大的电容连接到值较小的电容之后，因为随着电容值的增加，电感变得更小。\n\n![图5-4 靠近设备的解耦电容](/images/siva/5-4.png)\n\n如上文所示，使用的过孔越多，阻抗越低。TI 强烈建议在电源层和接地层使用多个过孔。将过孔直接放置在电容器的安装焊盘上是一种有效的方法，可以最大限度地减少布线面积，同时仍能实现电流流动布线。请遵循以下旁路电容器指南：\n\n- 不要在旁路电容器和有源器件之间使用过孔。可视化高频电流流动并尽可能减少高频电流环路。\n\n- 确保旁路电容器与有源元件位于同一层，以获得最佳效果。不要在旁路电容器引脚和 IC 电源或接地引脚之间放置过孔。\n\n- 将过孔布线到旁路电容器中，然后再布线到有源元件中。\n\n- 使用最多的过孔和最宽的走线以获得最佳布局。\n\n- 旁路电容器越近越好（小于 0.5 厘米，0.2 英寸）。\n\n- 不要使用大于 3:1 的长宽比。\n\n![图5-5 旁路电容的放置](/images/siva/5-5.png)\n\n### 靠近功率级（Power Stage）\n对于功率级上的旁路电容，请使用小型陶瓷电容器来衰减由 MOSFET 和其他寄生电容切换引起的高频电流。这些电容器的电容值通常小于 10 μF，具体取决于应用要求。\n\n![图5-6 设置有旁路电容的H桥](/images/siva/5-6.png)\n\n### 靠近开关电流源（Switch Current Source）\n正确布局和放置这些电容器对于确保其有效性至关重要。电容和开关电流源之间的任何额外寄生电感都会降低其效果。理想情况下，将电容器放置在尽可能靠近开关电流源的位置，在本例中为电机和 MOSFET。图 5-7 显示了基于上一个原理图示例的示例布局。\n\n![图5-7 旁路电容的放置](/images/siva/5-7.png)\n\n### 靠近电流测量运放\n对于带有集成电流检测放大器 (CSA) 的设备，TI 建议将额外的去耦电容尽可能靠近检测引脚放置，并使用大约 1 nF 的值。图 5-8 显示了去耦电容 C12、C13 和 C17。\n\n![图5-8 SNx和SPx布局](/images/siva/5-8.png)\n\n### 靠近稳压器（Voltage Regulators）\n对于带有稳压器的器件，请将电容器尽可能靠近引脚放置。尽量减少接地引脚的接地回路。例如，图 5-9 显示 C18 电容器尽可能靠近 DVDD 稳压器。\n\n![图5-9 DVDD的接地回路](/images/siva/5-9.png)\n\n# MOSFET的放置与功率级布线\n栅极驱动器和功率 MOSFET 的放置对于预驱动器电机驱动解决方案的正确功能和最佳性能至关重要。对于带有集成 MOSFET 的电机驱动器，例如 DRV8870、DRV8313、DRV10987、DRV10983-Q1 和 DRV8873-Q1，正确的布线已在内部完成。对于栅极驱动器，例如 DRV8701、DRV8304、DRV8306、DRV8323、DRV8343-Q1 和 DRV8353，仔细规划 PCB 的布局和功率 MOSFET 的放置非常重要。以下部分介绍了一些常见的 MOSFET 拓扑，并介绍了使用常见电机驱动架构的基本布局示例。\n\n## 常见功率 MOSFET 封装\n本节介绍一些常见的 N 沟道功率 MOSFET 封装类型。大多数\n功率 MOSFET 都有这四种选项之一。通过了解封装类型、尺寸和引脚排列，可以更好地设计 PCB 以获得最佳解决方案。\n\n图 6-1 中的符号代表 N 沟道功率 MOSFET。虽然 MOSFET 是一种四端器件，具有源极、栅极、漏极和体极，但体极通常位于源极端子。\n\n![图6-1 N-MOSFET符号](/images/siva/6-1.png)\n\nMOSFET 封装与功率级和散热直接相关。不同的封装具有不同的布线规则。\n\n### DPAK\n图 6-2 所示的 DPAK (SOT-252) 封装是业界最常用的封装之一。此封装在尺寸和性能之间实现了折衷。DPAK 封装通常用于高功率 MOSFET 和稳压器。\n\n![图6-2 DPAK封装](/images/siva/6-2.png)\n\n### D2PAK\nD2PAK（SOT-252）封装（见图 6-3）是 DPAK 封装的较大版本，可以提供更好的散热效果。\n\n![图6-3 D2PAK封装](/images/siva/6-3.png)\n\n### TO-220\nTO-220 封装（见图 6-4）是一种通孔 MOSFET 封装。直立片可用于安装散热器。使用这种封装的缺点是它需要更多空间，并且通常比表面贴装封装（例如 DPAK 和 D2PAK 封装）更高。\n\n![图6-4 TO-220封装](/images/siva/6-4.png)\n\n### 8-Pin SON\n8 引脚 SON 封装（见图 6-5）是最常见的无引线封装。此封装提供了一种解决方案，可实现最小的电路板空间和最佳性能。大多数引线封装具有相似的引脚排列。8 引脚 SON 封装的独特之处在于，与引线封装（TO-252 和 TO-220）相比，栅极引脚位于相反的一侧。\n\n![图6-5 8-Pin SON 封装](/images/siva/6-5.png)\n\n## MOSFET布局设置\n图 6-6 和图 6-7 显示了两种典型配置的常见 MOSFET 位置和布局；分别为半桥堆叠和半桥并排，适用于有引线和无引线封装。\n\n![图6-6 半桥堆叠](/images/siva/6-6.png)\n\n![图6-7 半桥并排](/images/siva/6-7.png)\n\n这些半桥布局可以重复用于多个半桥拓扑，包括 H 桥（两个半桥）、逆变器（三个半桥）和双 H 桥（四个半桥）。\n\n## 功率级布局设计\n在为功率 MOSFET 选择正确的位置后，下一步是确保布线正确。由于 MOSFET 用于高功率、电机驱动开关应用，因此设计对非理想布局引入的寄生效应很敏感。本节介绍了一些需要布线的关键信号以及管理这些信号的最佳实践。功率级如图 6-8 所示。\n\n![图6-8 带开关节点（红圈）的半桥功率级](/images/siva/6-8.png)\n\n### 开关节点（Switch Node）\n开关节点是高端 MOSFET 的源极引脚和低端 MOSFET 的漏极引脚之间的连接，如图 6-10 所示。此节点是最终连接到负载（在本应用中为电机）的网络。开关节点是半桥配置中要路由的最关键信号，因为此网络上的信号具有高频、大电流特性。图 6-8 所示的电路具有由 PCB 和功率 MOSFET 引起的许多非理想寄生效应。图 6-9 显示了其中一些主要寄生效应，它们是开关节点振铃现象的主要原因。\n\n![图6-9 半桥寄生效应](/images/siva/6-9.png)\n\n开关节点振铃是由于 PCB 和功率 MOSFET 的寄生效应导致的开关节点上的 LC 振荡。开关节点振铃会导致 EMI 并产生过冲和下冲电压，这可能会违反 MOSFET 漏极-源极电压和栅极驱动器引脚的绝对最大额定值。它还会降低功率级的效率。\n\n可以通过外部措施和系统调整（降低斜率、外部缓冲器等）来解决开关节点振铃问题，但基本合理的布局可以解决许多主要问题。图 6-10 中的布局示例显示了最小化高端 MOSFET 源极和低端 MOSFET 漏极之间电感的设计。最佳做法是最小化铜平面连接的长度并最大化其宽度，并使用具有最小寄生电感的 MOSFET 封装。\n\n![图6-10 开关节点布局样例](/images/siva/6-10.png)\n\n### 大电流循环路径（High-Current Loop Paths）\n由于电机应用依赖于高开关电流，因此最小化高电流路径的总环路电感至关重要。最小化该电感可最大程度地减少电压纹波和噪声，并可减少对额外旁路电容的需求。\n\n在电机系统中，高电流环路从电源的正极开始，经过高端功率 MOSFET，经过电机绕组，经过相反的低端 MOSFET，再回到电源的负极。图 6-11 以 H 桥示例显示了此流程。\n\n![图6-11 大电流循环路径样例](/images/siva/6-11.png)\n\n应通过以下方式最小化高电流环路路径：\n\n- 对整个高电流环路使用正确的走线宽度。增加走线宽度可降低寄生电感。\n\n- 使用正确的布局来最小化元件之间的距离。减少走线长度可降低寄生电感。\n\n- 尽量减少高电流路径中的层跳转数量，并在使用高电流走线跳转层时使用正确的通孔尺寸和数量。\n\n图 6-12 显示的是优化大电流环路的示例布局。\n\n![图6-12 大电流循环路径Layout样例](/images/siva/6-12.png)\n\n### VDRAIN 检测引脚\nVDRAIN 引脚用于感测高端 MOSFET 漏极电压。具有 VDRAIN 引脚的电机驱动设备必须经过一定的布线才能获得最佳性能。由于电压供应首先到达高端 MOSFET 的漏极，因此 VDRAIN 引脚的布线对于布局至关重要。VDRAIN\n引脚为电压供应 (VM) 提供 Kelvin 连接，从而可以在发生过流事件时监控高端 MOSFET 的 VDS 电压（见图 6-13）。由于功率级中的 VM 连接通常由大铜平面和宽走线组成以支持所需的电流，因此平面的额外电感和压降可能会影响 VDS 测量精度。因此，将 VDRAIN 引脚通过一条走线直接布线到外部功率 MOSFET 的漏极。TI 建议在漏极附近使用 Net Tie 以尽量减少可能导致错误 OCP 故障的额外电感（见图 6-14）。\n\n![图6-13 VDRAIN Kelvin 连接](/images/siva/6-13.png)\n\n![图6-14 Net Tie 高端MOSFET的漏级](/images/siva/6-14.png)\n\n*有关 Kelvin 连接，参见*：[The basics of Kelvin connections](https://www.testandmeasurementtips.com/the-basics-of-kelvin-connections-faq/)\n\n*Net Tie 是一种在PCB设计中将两个或多个不同的网络在特定位置进行连接的技术，通常用于管理不同网络之间的连接关系。它是一种特殊的器件，形式上可以表现为一小段连接铜皮、过孔或其他类似的结构。有关更多 ，参见*：[Net Ties and How to Use Them](https://smtnet.com/library/files/upload/NetTies-and-How-to-Use-Them.pdf)\n\n# 电流检测放大器布线（Current Sense Amplifier Routing）\nTI 的各种电机驱动器都包含具有内置电流感应功能的器件，其中大多数使用外部分流电阻作为测量源。将电流感应放大器与驱动器结合使用为电机接口提供了一体化解决方案，并允许以更低的成本实现更高质量的电流感应。图 7-1 显示了所有可用的电流感应拓扑。\n\n![图7-1 电流检测拓扑](/images/siva/7-1.png)\n\n这些设备内置的集成电流检测放大器 (CSA) 通常分为三类，每类都有各自的优点。以下将介绍这些类别。\n\n## 单高端电流分流器（Single High-Side Current Shunt）\n图 7-2 显示了高端（High-Side）电流检测电路。\n\n![图7-2 高端电流检测](/images/siva/7-2.png)\n\n使用高侧电流检测的好处包括：\n\n- 直接测量电源电流\n\n- 可以检测负载短路\n\n- 不受地（GND）干扰\n\n使用高端电流检测的缺点是它需要更多的共模电压。\n\n## 单低端电流分流器（Single Low-Side Current Shunt）\n图 7-3 显示了低端电流分流电路。\n\n![图7-3 低端电流检测](/images/siva/7-3.png)\n\n使用低侧电流分流器的好处是它需要的共模电压较低。\n\n使用低侧电流分流器的缺点是它更容易受到接地噪声的影响，并且无法检测接地短路。\n\n## 两相和三相电流分流放大器（Two-Phase and Three-Phase Current Shunt Amplifiers）\n图 7-4 显示了具有两相和三相 CSA 的电路。\n\n![图7-4 两相和三相 CSA ](/images/siva/7-4.png)\n\n两相和三相 CSA 对电路板布局有利，因为它们对共模电压的要求较低。它们还可以单独测量每个通道，因此可用于更复杂的控制方案，例如磁场定向控制。\n\n在电路板布局中使用两相和三相 CSA 的缺点包括：\n\n- 对接地噪声的敏感性更高\n- 无法检测接地短路\n- 可能需要更多软件来实现总系统电流\n\n## 器件选型\n在选择检测电阻（精密电阻）时，需要在精度和功耗之间进行权衡。由于功率级中的大电流会流过检测电阻，因此所选电阻值必须很小，以将功耗保持在最低水平。对于大电流系统，电阻值通常以 mΩ 为单位。例如，驱动 20 A 电流并使用 1 mΩ 检测电阻的系统将从该电阻上耗散 400 mW。在这种情况下，CSA 的输入仅接收 20 mV 的信号。增加电阻值可以提高信噪比，但也会增加功耗。\n\nCSA 的性能参数也必须考虑。在针对系统中的最坏情况电流进行设计时，所选的分流电阻应防止电流检测输入引脚上的电压高于 CSA 的绝对最大额定值。在正常运行期间，此电压必须保持在差分电压范围的指定参数范围内。要选择检测电阻，请参阅器件数据表。\n\n对于使用外部增益电阻的器件（例如 DRV3201-Q1），请选择具有高精度的组件。组件不匹配会导致整个系统的共模和差模增益发生很大变化。\n\n## 器件放置（Placement）\n检测电阻的放置位置应与功率级的组件一致，以最大限度地减少走线阻抗。分流电阻也应放置在靠近 CSA 连接的位置，以降低在电路板上其他走线上耦合的可能性。\n\n对于高端电流检测，分流电阻应靠近电源和高端 MOSFET 源极之间的星点。对于使用外部增益电阻的高端电流检测设备（例如 DRV3205-Q1），分压器中的第一个电阻应放置在最靠近分流电阻的位置。其余组件应放置在最靠近设备的位置。\n\n对于低端电流检测，分流电阻应位于低端 MOSFET 的源极和功率级的星点接地连接之间。\n\n对于在两个或三个单独相位上具有分流电阻的系统，分流电阻应放置在相应低端 MOSFET 的源极和星点接地连接之间。\n\n## 布线（Routing）\n**必须使用差分对来路由检测信号**。在差分对中，两个信号在布局中紧密耦合，并且走线必须从分流器或检测电阻器平行延伸到 IC 输入端的 CSA。\n\n![图7-5 CSA 布线 ](/images/siva/7-5.png)\n\n## 实用工具（Net Tie 和 差分对）\n许多现代 CAD 工具都实现了可帮助布局工程师正确布线 PCB 的功能。本节中介绍的功能是 Altium Designer 工具的一部分；但是，许多其他工具也具有类似的功能。\n\n在初始阶段布线 PCB 时，有助于显示哪些组件布线到哪里的指南在检测电阻布线的情况下可能会产生误导。在低侧分流电阻的情况下，负输入可以直接接地，而正输入可以直接连接到低侧源极引脚。为避免这种情况，请在设备和分流电阻之间放置一个 Net Tie，以便设计人员可以在放置期间而不是布线期间放置布线限制。图 7-6 显示了 Net Tie 放置的示例。\n\n![图7-6 Net Tie 放置样例](/images/siva/7-6.png)\n\n使用差分对的布局技术通过并行布线两个紧密耦合的信号来降低共模噪声。TI 建议使用差分对将信号从分流电阻布线到 CSA。为了进一步降低噪声耦合，请勿将噪声敏感的走线与噪声（开关）信号并行布线。\n\n## 输入和输出过滤（Input and Output Filters）\n感测放大器的输入和输出滤波器尽可能靠近感测放大器。这种放置方式可确保设备接收到的不需要的噪声被限制在滤波器和感测放大器之间。图 7-7 显示了输入滤波器（C40、R30 和 R31）的示例布局。\n\n![图7-7 输入和输出过滤原理图](/images/siva/7-7.png)\n\n![图7-8 输入和输出过滤Layout](/images/siva/7-8.png)\n\n## CSA 小结\n设计电机驱动器的电路板布局时，请执行以下操作：\n\n- 使用开尔文连接\n- 使布局对称\n- 使用 Net Ties 和差分布线工具\n\n\n","categories":["电子与电路设计"]},{"title":"简单H桥电机驱动电路分析及其隔离设计","url":"/2024/08/12/简单H桥电机驱动电路分析及其隔离设计/","content":"# H桥驱动电路（H-Bridge Circuit）\nH桥是一种相当简单的电路。它包含四个独立控制的MOSFET，用作引导电流流过负载（通常是电感负载，例如电机）的开关元件。\n\n![H桥电路拓扑图](/images/H/1.png)\n\n具体的工作方式不再赘述，本文主要分析一些比较细节的点。\n\n## MOSFET中的寄生二极管与外部续流二极管\n在N沟道MOSFET中，源极和漏极通常是N型区域，而基区是P型材料。这些区域之间形成了两个PN结，其中一个是在源极与基区之间，另一个是在漏极与基区之间。由于在MOSFET中，源极和基区通常是短接的，因此源极-基区的PN结不会起作用，而漏极-基区的PN结则形成了寄生二极管。该现象在大多数功率MOSFET中都会出现。这也就是为什么在一些仿真软件中，MOSFET的拓扑符号后会有一个反向并联的二极管标识。\n\n\n作为典型的感性负载，电机在电流变化时会产生反电动势。当H桥中的MOSFET切换状态时，电流的变化会导致电感负载产生一个高电压尖峰。这种电压尖峰可能会反向施加在MOSFET上，可能导致MOSFET损坏或造成不稳定的电路操作。\n\n为了保护MOSFET和其他电路元件，在每个MOSFET的漏极和源极之间通常会并联一个续流二极管。续流二极管的作用主要有以下几点：\n\n- **提供电流续流路径**：当MOSFET关闭时，感性负载的电流无法立即停止，续流二极管为该电流提供了一个通路。这样可以避免因电流中断导致的高电压尖峰，从而保护MOSFET和其他电路元件。\n\n- **保护MOSFET**：续流二极管可以限制感性负载产生的反电动势，避免这些电压尖峰直接加在MOSFET上，防止MOSFET因过压而损坏。\n\n- **稳定电路操作**：在高频开关操作中，续流二极管可以减少电路中的电磁干扰（EMI）和噪声，提高电路的稳定性和可靠性。\n\nMOSFET自带的寄生二极管在电路中确实可以在某些情况下起到续流二极管的作用，特别是在开关断开的瞬间，它可以为电感性负载提供电流续流的路径。然而，由于寄生二极管的特性不如专门设计的续流二极管（例如肖特基二极管），它的导通电压较高，反向恢复时间较长，所以在实际电路设计中，寄生二极管往往不能完全替代续流二极管。因此，如果对续流二极管有严格的要求，通常会在电路中另外并联一个性能更好的二极管。\n\n![一个H桥上臂MOSFET两端并联的续流二极管](/images/H/2.png)\n\n## 电流衰减模式\n电机是感性负载，电流不能突变。若要使电机减速，在断开电机两端所加的电压时，电压由工作值瞬间衰减至零，根据电磁感应定律，电机会根据电压变化率（$du/dt$）的大小而产生反向电动势。当电压变化率很大时，这个反电动势很有可能损坏MOSFET。因此想让电机停下，除了断开供电，还要形成一个续流的回路，释放掉电机上的能量。这就是刚刚提到过的续流二极管的作用。\n\n在减速时的电流再生过程中，H桥通常可以工作在两个模式：\n- 快速衰减（Fast Decay Mode）\n\n- 慢速衰减（Slow Decay Mode）\n\n*注意*：“衰减”指的是流过电机线圈（电感器）的电流，与电机的行为没有直接关系。不要认为快速衰减会使电机迅速停止。\n\n![不同衰减模式下的电流回路示意图](/images/H/3.png)\n\n### 快速衰减模式（Fast Decay Mode）\n\n![快速衰减模式](/images/H/4.png)\n\n该模式下，四个MOSFET全部关断，反电动势带来的反向感应电流通过Q2、Q3的寄生二极管（续流二极管）流动，此时反电动势带来的感应电流方向与电源电压方向相反，线圈电流迅速衰减。\n\n为避免同一侧的上下臂MOSFET同时导通而造成击穿，应当采取机制。具体为，添加一个令所有FET开关均处于关闭状态的时间段（被称为**死区时间**）。在此期间，允许激励FET开关切换到关闭状态，存在电感负载的电流由寄生二极管或外部续流肖特基二极管承载。\n\n快速衰减模式下电流虽然能够迅速降低到零，但电机速度会因惯性而逐渐减小，对外呈现“滑动”式的减速。\n\n### 慢衰减模式（Slow Decay Mode）\n\n![慢衰减模式](/images/H/5.png)\n\n该模式下，Q1、Q3关断，Q2、Q4导通，感应电流以循环方式在流经Q2和Q4时降至零。在这种情况下，电流在流过电感阻抗和两个FET的导通阻抗时以热量的形式耗散。\n\n*注意*：虽然慢速衰减通常描述为两个低侧FET开关打开、两个高侧FET开关关闭，但相同现象可通过启用两个高侧 FET 开关、同时禁用两个低侧FET开关来实现。也就是说，衰减回路可以为上臂，也可以为下臂。部分IC支持通过相应的输入信号来配置。\n\n在直流电机上，慢速衰减模式会令电机绕组短路，进而形成反电动势短路，使得转子以极快速度停止旋转。\n\n### 混合衰减（Mixed Decay Mode）\n在混合衰减再循环模式中，电流衰减至零的速度快于慢速衰减方法，但慢于快速衰减方法。实现此技术的方法是，协调FET开关的开/关时间，在固定时间内处于快速衰减模式，然后在剩余时间内处于慢速衰减模式。系统保持在快速衰减模式与慢速衰减模式中的时间比例被称为混合衰减百分比。\n\n混合衰减对于步进电机驱动很有意义，但最重要的是，它对微步进驱动极有意义。在微步进时，将保持一定波形以获得出色的运动质量。例如，通常会通过正弦波（电流曲线）来驱动步进电机绕组。也可以在相同范围内使用三角形和菱形。\n\n有关混合衰减的内容将另作介绍。\n\n## MOSFET高低端驱动与自举电路\n在H桥电路中，MOSFET通常分为高端（High-Side）和低端（Low-Side）两个部分：\n\n- **高端MOSFET（High-Side MOSFET）**： 连接在电源和负载之间的MOSFET。\n\n- **低端MOSFET（Low-Side MOSFET）**： 连接在负载和地之间的MOSFET。\n\n已知MOSFET导通需要满足\n\n$$\nV_{GS}>V_{GS(th)}\n$$\n\n对于低端MOSFET，源极通常接地，因此提高驱动电压使得$V_{GS}>V_{GS(th)}$比较容易实现。而对于高端MOSFET，源极与负载相连，且源极电位通常高于地电位，因此对栅极直接驱动需要一个比电源电压更高的电压来导通MOSFET。这就需要特殊的高端驱动电路来生成这个较高的栅极驱动电压。\n\n自举电路是常用的一种解决方案，用于生成高端MOSFET所需的高电压驱动信号。它通常包括一个二极管和一个电容器（自举电容），配合驱动芯片工作。\n\n以半桥为例，当Q2导通时，Q1的源极被拉到地电位（低电平）。此时，自举电容C1通过二极管充电（此处所加电压V一般由LDO架构电源输出）。此时，自举电容的电压接近于电源电压V。\n\n![自举电容充电](/images/H/6.png)\n\n当Q2断开时，SW位置电位不再为地电位，而自举电容C1两端储存了大小为V的电压，A点电压变为$V_{SW}+V$，很容易就能够驱动高端MOSFET。此时由C1提供上管驱动阶段所需的所有电流。此时自举二极管（一般为肖特基二极管）处于反向截止状态，将自举压降限制在自举回路内，防止其回流至上一级从而损坏电路。\n\n![自举电容放电](/images/H/7.png)\n\n参见：[H桥自举电路分析](https://blog.csdn.net/qq_44897194/article/details/107397079?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-107397079-blog-110673237.235^v43^pc_blog_bottom_relevance_base6&spm=1001.2101.3001.4242.1&utm_relevant_index=3)\n\n自举电容持续放电将会导致高端MOSFET的栅极对地电压持续减小，直至其等于V。因此要让高端MOSFET持续导通，需要令自举电容不断充放电，或是增加自举电容容量、更换IC或在设计中避免持续导通需求。由于MOSFET的特性，自举电路在增加栅源电压的同时，还可令MOSFET的导通电阻减小，从而减少发热损耗。\n\n## H桥驱动控制\n对MOSFET栅极引入PWM控制，可实现对电机转动方向和速度的调节。PWM的占空比对应电机转速，占空比越大，平均等效输出电压越大，转速越快。通常的PWM频率在10Khz至20KHz之间。若频率太低，电机转速会过低，同时容易出现高噪声或高频机械振动；频率太高，则MOSFET开关损耗带来的影响会变大，降低系统效率。\n\n根据不同桥臂的PWM控制方式，大致上可分为三种：\n\n- 受限单极模式\n\n- 单极模式\n\n- 双极模式\n\n### 受限单极模式\n\n该模式下，电机电枢驱动电压极性是单一的，优点是控制电路较为简单，缺点是电机不能刹车，不能进行能耗制动，在负载超过设定速度时不能提供向力矩。调速静差大，调速性能很差，稳定性也不好。当PWM高电平时，电机两端分别为VM和GND，有电流流过，电机产生扭矩，进行转动。当PWM低电平时，电机两端未导通，不形成闭合回路，没有电流流过，此时电机的转动没有力来维持，难以控制。\n\n### 单极模式\n\n单极模式引入互补PWM波（PWMN），其一般由MCU高级定时器生成，如STM32F429的TIM1、TIM8。\n\n![PWM单极模式](/images/H/8.png)\n\n相比受限单极模式，单极模式控制在Q1信号为低电平时，由互补PWM提供，对Q2施加高电平信号，令Q2打开。此时Q2、电机、Q4形成闭合回路。电机中仍然有电流流过，虽然电流会减小，但是仍会产生磁场，仍会产生力矩来继续控制电机转动。该模式优点是启动快，能加速、刹车、能耗制动、能量反馈，调速性能虽然不如双极模式好，但是相差不多，电机特性也较好。在负载超速时，也能提供反向力矩。\n\n### 双极模式\n\n双极模式下电枢电压极性是正负交替的。\n\n![PWM双极模式](/images/H/9.png)\n\n图中，PWM1、PWM2均由定时器输出，PW1N、PW2N为他们的互补PWM通道。PWM1和PWM2周期相同，占空比相同，极性相反，使得对角线上的两个MOSFET能够同时导通，同时关断。最终电机的转动方向由PWM和PWM1共同决定，若A的PWM占空比高于50%则电流从左至右，若低于50%则从右至左。该模式在继承单极模式优点的基础下，在速度快要接近于0时也可以提供一定的力矩，加减速性能更好，因此正反转的性能优于单极模式。控制效果好。缺点是控制更复杂，工作时4个MOS都在工作，功耗大。\n\n### 死区时间\n死区时间（Dead Time）是指在切换两个互补的MOSFET时，为了避免同时导通而导致短路或直通故障，在关断一个MOSFET和导通另一个MOSFET之间插入的延迟时间。死区时间提供了一个缓冲，确保一个MOSFET完全关闭后，另一个才开始导通，从而避免直通故障。\n\nMOSFET的导通和关断不是瞬时的，而是需要一定的时间。这包括MOSFET栅极充电和放电的时间。不同类型的MOSFET具有不同的开关速度（开通时间和关断时间）。如果死区时间设置得太短，可能不足以覆盖MOSFET的开关时间，导致直通故障。如果死区时间设置得太长，则会降低电路的效率。因为在死区时间内，两对互补的MOSFET都处于关闭状态，没有电流通过负载，导致功率损失和电机或负载的性能下降。\n\nMOSFET的开关速度与栅极电荷（Qgs、Qgd）和栅极驱动电流有关。死区时间应与这些参数相匹配。较低的栅极电荷通常意味着更快的开关速度，可以使用更短的死区时间。另一方面，高侧和低侧MOSFET的不同Rds(on)值也会影响开关速度，因此在设计死区时间时需要考虑。一些驱动IC会根据MOSFET的特性自动调整死区时间，以优化性能和保护MOSFET。\n### 程序代码（以STM32 HAL库为例）\n以IRS21867S方案为例：\n\n![IRS21867S硬件方案](/images/H/10.png)\n\nMCU为STM32F1，PWM由TIM1通道3生成，PWM-N由TIM1通道3的互补通道生成；PWM1由TIM1通道2生成，PWM1-N由TIM1通道2的互补通道生成。PWM信号从对应的复用GPIO管脚连接至驱动IC。\n\n|         模式        \t| Q1（左上）栅极信号 \t| Q2（右上）栅极信号 \t| Q3（左下）栅极信号 \t| Q4（右下）栅极信号 \t|\n|:-------------------:\t|:--------:\t|:---------:\t|:--------:\t|:---------:\t|\n| 受限单极模式 (正转) \t|     PWM    \t|     OFF    \t|     OFF    \t|     ON     \t|\n| 受限单极模式 (反转) \t|     OFF    \t|     PWM     \t|     ON    \t|     OFF     \t|\n|   单极模式（正转）  \t|     PWM    \t|     OFF     \t|     PWM-N    \t|     ON     \t|\n|   单极模式（反转）  \t|     OFF   \t|     PWM     \t|     ON   \t|     PWM-N      \t|\n|       双极模式      \t|     PWM1    \t|     PWM2     \t|     PWM1-N    \t|     PWM2-N     \t|\n\n根据该真值表，即可通过修改对应的TIM通道的PWM极性来配置电机工作模式。\n\n为方便，可自定义工作模式函数。\n\n*注意*：下面的Set_Motor_Mode()函数仅设置了定时器状态。在受限单极模式和单极模式下，修改Set_Motor_Mode()函数后，一定要记得根据上表修改对应桥臂MOSFET的栅极信号以保证其处于恒导通状态，对电枢电流提供回路。\n\n```\n// 电机工作模式设置（定时器状态）\nvoid Set_Motor_Mode(uint8_t mode)\n{\n    switch (mode)\n    {\n    case 0: // 受限单极模式（正转）\n        HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);\n        HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_2);\n        HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_3);\n        HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_3);\n        break;\n\n    case 1: // 受限单极模式（反转）\n        HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_2);\n        HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_2);\n        HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);\n        HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_3);\n        break;\n\n    case 2: // 单极模式（正转）\n        HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);\n        HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_2);\n        HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_3);\n        HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_3);\n        break;\n\n    case 3: // 单极模式（反转）\n        HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_2);\n        HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_2);\n        HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);\n        HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_3);\n        break;\n\n    case 4: // 双极模式\n        HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);\n        HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_2);\n        HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);\n        HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_3);\n        break;\n\n    case 5: // 关闭输出\n        HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_2);\n        HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_2);\n        HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_3);\n        HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_3);\n        break;            \n\n    default:\n        // 处理非法模式\n        break;\n    }\n}\n```\n\n配置TIM1：\n```\nvoid MX_TIM1_Init(void)\n{\n    TIM_ClockConfigTypeDef sClockSourceConfig = {0};\n    TIM_OC_InitTypeDef sConfigOC = {0};\n    TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};\n\n    htim1.Instance = TIM1;\n    htim1.Init.Prescaler = (uint32_t)((SystemCoreClock / 2) / 20000) - 1; //预分频寄存器写入\n    htim1.Init.CounterMode = TIM_COUNTERMODE_UP;\n    htim1.Init.Period = 1000 - 1; // 自动重载寄存器写入\n    htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n    htim1.Init.RepetitionCounter = 0;\n    htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;\n    HAL_TIM_Base_Init(&htim1);\n\n    sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;\n    HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig);\n\n    HAL_TIM_PWM_Init(&htim1);\n\n    sConfigOC.OCMode = TIM_OCMODE_PWM1;\n    sConfigOC.Pulse = 500; // 初始占空比50%\n    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;\n    sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;\n    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;\n    sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;\n    sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;\n\n    HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2);\n    HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3);\n\n    //死区设置\n    sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;\n    sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;\n    sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;\n    sBreakDeadTimeConfig.DeadTime = 100;\n    sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;\n    sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;\n    sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;\n    HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig);\n}\n```\n定时器触发更新事件时间间隔为\n$$\nT_{out}=\\frac{(ARR+1)\\times(PSC+1)}{f_{clk}}\n$$\n\n可按照该式自定义PWM频率。如要调整初始占空比，可通过改变Pulse参数值（范围为0到Period）来实现。\n\nPWM输出函数（以单极模式为例）：\n```\nvoid set_pwm(int speed)\n{\n    // 处理速度的正负，正值表示正转，负值表示反转\n    if (speed > 0)\n    {\n        Set_Motor_Mode(2);  // 正转\n\n        *******此处要记得将Q4栅极信号拉高*******\n\n    }\n    else if (speed < 0)\n    {\n        Set_Motor_Mode(3);  // 反转\n\n        *******此处要记得将Q3栅极信号拉高*******\n\n        speed = -speed; // 将速度值取绝对值\n    }\n    else\n    {\n        Set_Motor_Mode(5);  // 停止\n        return;\n    }\n\n    // 限制最低速度，确保电机能够启动\n    int min_speed = 10; // 定义最低速度\n    if (speed < min_speed)\n    {\n        speed = min_speed;\n    }\n\n    // 将速度值映射到PWM占空比范围\n    speed = 700 - speed; // 这里700是基准值，越接近700，PWM占空比越小\n\n    TIM1->CCR2 = speed; // 设置TIM1通道2的PWM占空比\n    TIM1->CCR3 = speed; // 设置TIM1通道3的PWM占空比\n}\n```\n\n主函数：\n```\nint main(void)\n{\n    HAL_Init();\n    SystemClock_Config();\n\n    // 初始化TIM1\n    MX_TIM1_Init();\n\n    // 选择电机的工作模式\n    Set_Motor_Mode(???); \n    \n    // 主循环\n    while (1)\n    {\n        // 在这里可以通过修改占空比来控制电机速度\n        set_pwm(???);\n    }\n}\n```\n\n以上是一个最简单的能让电机在开环下转起来的代码。如果要实现动态控制、动态调速，需要加入控制环节，另作介绍。","categories":["电子与电路设计"]},{"title":"【电机瞬态分析】同步电机突然三相短路分析","url":"/2024/08/08/【电机瞬态分析】同步电机突然三相短路分析/","content":"## 简介\n在电力系统实际发生的故障中，不对称短路占的比例较大，对称短路的故障所占比例虽较小，但其后果比较严重。根据国家标准规定，同步发电机必须能承受空载电压等于105%额定电压下的突然三相对称短路。本节直接利用之前导出的同步电机动态方程式，求解空载时突然三相对称短路后的短路电流和电磁转矩。\n\n假定在突然短路过程中转速为同步转速，即$\\omega=1$。这个假定在分析最大突然短路电流和最大短路转矩时是可以满足工程要求的。由于转速恒定而且已知，因此，只需求解动态方程式中的电压方程式，无需考虑转矩过渡时的转子运动方程式。此时电压方程式是一组线性常系数的微分方程式，为了求解方便，可以应用叠加原理和拉氏变换的方法。\n\n根据叠加原理，实际突然短路可以看成是下面两种工况的叠加：\n\n- 电机突然短路前的稳定运行工况\n- 在零初始状态下电枢端突然加上与电机短路前大小相等、方向相反的电压时的运行工况\n\n实际突然短路问题的求解就转化成了短路前的稳态运行工况和零初始值时电枢端突加反向电压的瞬态问题的求解，这样，将使计算大为简化。下面分别就电枢突然短路后的电枢电流、转子电流及电磁转矩进行讨论。\n\n## 空载突然短路后的电枢电流\n假设同步电机在三项短路前空载运行，其稳定运行工况之前已经有分析过，其端电压为\n\n$$\nu_d=u_{d0}=0 \\\\\nu_q=u_{q0}=E_m\n$$\n\n根据叠加原理，突然三相短路后的电枢电流$i_d$、$i_q$，将由原来的稳态电流$i_{d0}$、$i_{q0}$和突然加电压$-u_{d0}$和$-u_{q0}$引起的瞬态电流$i_d'$、$i_q'$相加而成，即\n\n$$\ni_d=i_{d0}+i_d' \\\\\ni_q=i_{q0}+i_q' \n$$\n\n下面将分别求解电流$i_{d0}$、$i_{q0}$、$i_d'$、$i_q'$和$i_d$、$i_q$，并将其返回至abc坐标系统。\n\n### 短路前的稳态电流$i_{d0}$、$i_{q0}$\n同步电机运行在空载状态，电枢绕组开路，三相电枢绕组电流均为零，因而\n\n$$\ni_{d0}=i_{q0}=0\n$$\n\n### 突然加上$-u_{d0}$、$-u_{q0}$时所产生的电流$i_d$、$i_q$\n电枢d、q绕组端分别突然加上$-u_{d0}$、$-u_{q0}$时，电压方程式为\n\n$$\n-u_{d0}=0=p\\psi_d'-\\psi_q'+r_si_d' \\\\\n-u_{q0}=-E_m=p\\psi_q'+\\psi_d'+r_si_q'\n$$\n\n不计励磁调节作用，在突然短路时$u_f$为恒定值，而该恒定励磁电压的作用已经在稳态运行分析时考虑过。当电枢端突加电压$-u_{d0}$、$-u_{q0}$时，励磁绕组相当于短路回路，即$u_f=0$，因而相应的电枢磁链为\n\n$$\n\\psi_d'=x_d(p)i_d' \\\\\n\\psi_q'=x_q(p)i_q'\n$$\n\n将电枢磁链式代入电压方程式，得到电压与阻抗、电流的关系式。当电枢端突加电压时，各绕组的电流、磁链初值为零，故经由$Laplace$变换后，其运算方程为\n\n$$\n0=[r_s+px_d(p)]I_d(p)-x_q(p)I_q(p) \\\\\n-\\frac{E_m}{p}=[r_s+px_q(p)]I_q(p)+x_d(p)I_d(p)\n$$\n\n解出电流$I_d(p)$如下\n\n$$\nI_d(p)=-\\frac{E_m}{p}\\times\\frac{x_q(p)}{r_s^2+r_s[x_d(p)+x_q(p)]p+x_d(p)x_q(p)p^2+x_d(p)x_q(p)}\n$$\n\n或\n\n$$\nI_d(p)=-\\frac{E_m}{p}\\times\\frac{1}{p^2+r_s[\\frac{1}{x_d(p)}+\\frac{1}{x_q(p)}]p+1+\\frac{r_s^2}{x_d(p)x_q(p)}}\\times\\frac{1}{x_d(p)}\n$$\n\n略去$r_s^2$项，中括号内有$x_d(p)$和$x_q(p)$的项中，将转子电阻$r_f$、$r_D$、$r_Q$略去，这样$x_d(p)$、$x_q(p)$可分别简化为直轴、交轴次暂态（超瞬变）电抗$x_d''$、$x_q''$，于是有\n\n$$\nI_d(p)=-\\frac{E_m}{p(p^2+2\\alpha p+1)x_d(p)}\n$$\n\n式中\n\n$$\n\\alpha = \\frac{r_s}{2}(\\frac{1}{x_d''}+\\frac{1}{x_q''})=\\frac{1}{T_a}\n$$\n\n根据运算电抗章节中导出的$x_d(p)$的倒数形式\n\n$$\n\\frac{1}{x_d(p)}=\\frac{1}{x_d}+(\\frac{1}{x_d'}-\\frac{1}{x_d})\\frac{T_d'p}{T_d'p+1}+(\\frac{1}{x_d''}-\\frac{1}{x_d'})\\frac{T_d''p}{T_d''p+1}\n$$\n\n代入原式，有\n\n$$\nI_d(p)=-\\frac{E_m}{p(p^2+2\\alpha p +1)}[\\frac{1}{x_d}+(\\frac{1}{x_d'}-\\frac{1}{x_d})\\frac{T_d'p}{T_d'p+1}+(\\frac{1}{x_d''}-\\frac{1}{x_d'})\\frac{T_d''p}{T_d''p+1}]\n$$\n\n同理可解出象函数$I_q(p)$为\n\n$$\\begin{aligned}I_{q}(p)&=- \\frac{E_{m}}{p}\\times\\frac{r_{s}+px_{d}(p)}{r_{s}^{2}+r_{s}[x_{d}(p)+x_{q}(p)]p+x_{d}(p)x_{q}(p)p^{2}+x_{d}(p)x_{q}(p)}\\\\&=- \\frac{E_{m}}{p}\\times\\frac{r_{s}+px_{d}(p)}{p^{2}+r_{s}\\Big[\\frac{1}{x_{d}(p)}+\\frac{1}{x_{q}(p)}\\Big]p+1+\\frac{r_{s}^{2}}{x_{d}(p)x_{q}(p)}}\\times\\frac{1}{x_{d}(p)x_{q}(p)}\\end{aligned}\n$$\n\n分母中采用与导出$I_d(p)$时同样的简化方法，并根据运算电抗章节中导出的$x_q(p)$的倒数形式\n\n$$\n\\frac{1}{x_q(p)}=\\frac{1}{x_q}+(\\frac{1}{x_q''}-\\frac{1}{x_q})\\frac{T_q''p}{1+T_q''p}\n$$\n\n代入，得\n\n$$\nI_q(p)=-\\frac{E_m}{(p^2+2\\alpha p +1)}[\\frac{1}{x_q}+(\\frac{1}{x_q''}-\\frac{1}{x_q})\\frac{T_q''p}{1+T_q''p}]\n$$\n\n将象函数$I_d(p)$和$I_q(p)$使用$Laplace$反变换至原函数$i_d'$和$i_q'$。由于同步电机中$\\frac{1}{T_d}$、$\\frac{1}{T_d'}$、$\\frac{1}{T_d''}$、$\\frac{1}{T_q''}$均远小于1，反变换后的结果为\n\n$$\ni_d'=-E_m[(\\frac{1}{x_d''}-\\frac{1}{x_d'})e^{-t/T_d''}+(\\frac{1}{x_d'}-\\frac{1}{x_d})e^{-t/T_d'}+\\frac{1}{x_d}]+\\frac{E_m}{x_d''}e^{-t\\cos t/T_a}\\\\\n$$\n\n$$\ni_q'=-\\frac{E_m}{x_q''}e^{-t \\sin t/T_a}\n$$\n\n### 空载突然短路后的实际电流$i_d$、$i_q$\n根据上面分析，实际的空载突然三相短路电流可应用叠加原理，将空载稳态运行时的电流与突加$-u_{d0}$、$-u_{q0}$时的电流相加，由于空载时电枢电流为零，所以突然短路后的电流用dq0坐标系统表示为\n\n$$\ni_d=i_{d0}+i_d'=i_d' \\\\\ni_q=i_{q0}+i_q'=i_q'\n$$\n\n### 空载突然短路后的电流$i_a$、$i_b$、$i_c$\n假定$t=0$时，d轴和q轴得夹角为$\\theta_0$，则$\\theta=t+\\theta_0$。将$i_d'$和$i_q'$二式返回至abc坐标系统，有\n\n$$\ni_a=-[(\\frac{1}{x_d''}-\\frac{1}{x_d'})e^{-t/T_d''}+(\\frac{1}{x_d'}-\\frac{1}{x_d})e^{-t/T_d'}+\\frac{1}{x_d}]E_m\\cos(t+\\theta_0)+\\frac{E_m}{2}e^{-1/T_a}[(\\frac{1}{x_d''}+\\frac{1}{x_q''})\\cos \\theta_0+(\\frac{1}{x_d''}-\\frac{1}{x_q''})\\cos (2t+\\theta_0)]\n$$\n\n把上式中的$\\theta_0$分别用$(\\theta_0-120\\degree)$、$(\\theta_0+120\\degree)$替换，即可得到$i_b$、$i_c$的表达式。\n\n### 小结\n以上是从解方程式得到的突然三相短路后的实际定子绕组电流。由$i_a$的表达式可知，突然三相短路后，定子各相短路电流由两大部分构成，即基频的周期分量、非周期及2倍频分量，从物理意义上来理解，当定子绕组突然三相短路后，由于转子磁场的旋转及定子绕组中产生相应的三相稳态基频电流，将引起定子及转子各组中的磁链的突变。为了保持各闭合回路中的磁链不发生突变,定子绕组和转子阻尼和励磁绕组中就产生了非周期电流。由于转子以同步速度旋转，转子阻尼和励磁绕组中的非周期电流会在定子绕组中产生相应的基频周期电流分量，即超瞬变（次暂态）分量和瞬变（暂态）分量。由于转子绕组中存在电阻，突然短路在转子绕组中引起的非周期电流将逐步衰减至零，其阻尼绕组和励磁绕组的衰减时间常数分别为$T_d''$和$T_d'$。由转子绕组中的非周期电流在定子绕组中感生的超瞬变分量和瞬变分量电流亦按同样的时间常数衰减。同样地，定子绕组中的非周期电流会在转子绕组中产生相应的基频周期分量电流，但由于转子不对称，这个转子绕组中的基频电流所产生的磁场相对转子而言可分为两个转向相反，转速均为同步转速$\\omega_1$的分量，其中与转子转向相同的旋转磁场对定子的转速为$2\\omega_1$，它将在定子绕组中引起倍频的周期分量。从$i_a$的表达式中也可看出，当转子的磁路和电路完全对称，即$x_d''=x_q'$时，这个倍频的周期分量将不存在。与转子转向相反的旋转磁场对定子的转速为零，对定子非周期电流产生的磁场是一个去磁作用。\n\n由于定子绕组存在电阻，定子绕组中的非周期电流和倍频电流将以定子绕组的时间常数$T_a$衰减至零。\n\n从上面分析也可以看出，由于绕组轴线选取的不同，在d、q、0坐标系统中，电流$i_d$、$i_q$的非周期分量相当于a、b、c坐标系统中电流$i_a$、$i_b$、$i_c$的基频周期分量，而电流$i_d$及$i_q$的基频周期分量，则相当于电流$i_a$、$i_b$、$i_c$的非周期分量和倍频的周期分量。\n\n## 空载突然短路后的转子绕组电流\n\n突然三相短路后，电机转子绕组中电流的计算方法与计算电枢绕组电流一致，采用叠加原理将实际的突然短路电流看成是以下两种工况的叠加：\n\n- 电机突然短路前稳定运行工况的电流\n- 在零初始状态下，电枢端突然加上与短路前大小相等、方向相反的电压时运行工况的电流\n\n即：\n\n1. 求原来稳态三相对称运行时的转子电流$i_{f0}$、$i_{D0}$、$i_{Q0}$\n2. 求突然在电枢端加上电压$-u_{d0}$、$-u_{q0}$引起的转子电流$i_f'$、$i_D'$、$i_Q'$\n3. 突然三相短路后转子的实际电流为（1）、（2）所求电流的叠加，即\n$$\ni_f=i_{f0}+i_f'\\\\\ni_D=i_{D0}+i_D'\\\\\ni_Q=i_{Q0}+i_Q'\\\\\n$$\n\n下面分三步求解转子电流：\n\n### 求稳态三相对称运行时转子电流\n根据第二节空载运行的分析可知，稳态运行时励磁绕组电流，等于外加励磁电压在励磁绕组中产生的稳态直流电流，即\n\n$$\ni_{f0}=\\frac{u_f}{r_f}\n$$\n\n且稳态三相对称运行时阻尼绕组内电流为零，即\n\n$$\ni_{D0}=i_{Q0}=0\n$$\n\n### 求突然加上电压$-u_{d0}$、$-u_{q0}$引起的转子电流\n\n","categories":["电气工程"]},{"title":"【电机瞬态分析】凸级同步电机对称稳态运行分析","url":"/2024/08/05/【电机瞬态分析】凸级同步电机对称稳态运行分析/","content":"电机学中已经详细讨论了同步电机对称稳态运行问题，这里用之前导出的d、q、0坐标系统的电压方程式，对这一运行方式进行分析，很容易求得稳态运行时的有功功率、无功功率及电磁转矩。\n## 空载运行\n空载稳态运行时，显然同步电机的转速只能为同步转速，即角速度（标幺值）$\\omega=1$；励磁绕组端外加直流电压为$u_f$，电枢绕组开路，三相电枢绕组电流$i_a$、$i_b$、$i_c$均为零，转换为d、q、0坐标系统后，$i_d$、$i_q$、$i_0$亦都为零。由于转速恒定，不存在转矩过渡过程，故该情况下无需求解转矩方程式，只需求解电压方程式，即可求得发电机空载运行时由励磁电流、磁链在发电机电枢绕组中产生的空载电压。\n\n首先，求出励磁电流$i_f$。根据标幺值形式下的同步电机电压方程式\n\n$$\nU^*=L^*pI^*+\\omega^*G^*I^*+R^*I^*\n$$\n\n式中\n$$\nU^*=[U_{dq0}^* \\quad U_{fDQ}^*]^T\\\\\n$$\n$$\nI^*=[I_{dq0}^* \\quad I_{fDQ}^*]^T\n$$\n$$\nR^*=\n\\begin{bmatrix}\nR_{abc}^* & 0\\\\\n0 & R_{fDQ}^*\n\\end{bmatrix}\n$$\n$$\n\\begin{array}{c}\nL^{*}=\\left[\\begin{array}{cccccc}\nx_{\\mathrm{d}}^* & 0 & 0 & x_{\\mathrm{ad}}^{*} & x_{\\mathrm{ad}}^{*} & 0 \\\\\n0 & x_{\\mathrm{q}}^{*} & 0 & 0 & 0 & x_{a q}^{*} \\\\\n0 & 0 & x_{0}^{*} & 0 & 0 & 0 \\\\\nx_{\\mathrm{ad}}^{*} & 0 & 0 & x_{\\mathrm{f}}^{*} & x_{a d}^{*} & 0 \\\\\nx_{a d}^{*} & 0 & 0 & x_{ad}^{*} & x_{\\mathrm{D}}^{*} & 0 \\\\\n0 & x_{\\mathrm{aq}}^{*} & 0 & 0 & 0 & x_{\\mathrm{Q}}^{*}\n\\end{array}\\right] \n\n\\\\\n\nG^{*}=\\left[\\begin{array}{cccccc}\n0 & -x_{\\mathrm{q}}^{*} & 0 & 0 & 0 & -x_{a q}^{*} \\\\\nx_{d}^{*} & 0 & 0 & x_{\\mathrm{ad}}^{*} & x_{\\mathrm{ad}}^{*} & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0\n\\end{array}\\right]\n\\end{array}\n$$\n\n考虑$i_d$、$i_q$为零，可得\n\n$$\nu_f=p(x_fi_f+x_{ad}i_D) + r_fi_f \\\\\n0=p(x_{ad}i_f+x_Di_D)+r_Di_D \\\\\n0=px_Qi_Q+r_Qi_Q\n$$\n\n励磁绕组外加电源为直流电压，且现讨论的是稳态运行问题，所以励磁绕组电流为恒定直流，转子各绕组交链的磁链也为恒指，变压器电动势$p\\psi$为零，这时励磁绕组的电压方程式为\n\n$$\nu_f=r_fi_f\n$$\n\n励磁绕组的电流为\n\n$$\ni_f = \\frac{u_f}{r_f}\n$$\n\n阻尼绕组为短路回路，无端口电压，此时与阻尼绕组交链的磁链为恒值，无变压器电动势，显然阻尼绕组内电流为零，即\n\n$$\ni_D=i_Q=0\n$$\n\n其次，解出空载时电枢绕组的端电压$u_d$、$u_q$，根据同步电机电压方程式中电枢绕组部分，有\n\n$$\nu_d=p\\psi_d-\\omega\\psi_q+r_ai_d\\\\\nu_q=p\\psi_q+\\omega\\psi_d+r_ai_q\n$$\n\n上式右边第一项$p\\psi_d$、$p\\psi_q$为零，由于电枢绕组电流$i_d$、$i_q$和阻尼绕组电流都为零，故$\\psi_d=x_{ad}i_f=$恒值，$\\psi_q=0$，故其变化率$p\\psi$也为零，第三项电枢电流引起的电阻压降亦为零。考虑转子角速度$\\omega=1$，可将上式改写为\n\n$$\nu_d = 0 \\\\\nu_q = \\psi_d = x_{ad}i_f = x_{ad}\\frac{u_f}{i_f}=E_m\n$$\n\n式中，$E_m$为空载电动势幅值。$u_q =E_m$是一个重要的关系。\n\n最后，将电枢绕组在dq0坐标系统下得到的空载电压$u_d$、$u_q$返回到abc坐标系统，稳态运行时，可任意选择时间的起始点，一般取d轴和a轴重合的瞬间作为时间起点，即$\\theta_0=0$，这样就有$\\theta=\\omega t + \\theta_0 = t$，将$u_d$、$u_q$逆变换后可得三相空载电压为\n\n$$\nu_a = u_d \\cos\\theta - u_q\\sin\\theta = -E_m\\sin t \\\\\nu_b = u_d \\cos (\\theta - 120 \\degree) - u_q \\sin (\\theta - 120 \\degree) = -E_m\\sin (t-120 \\degree)\\\\\nu_c = u_d \\cos (\\theta + 120 \\degree) - u_q \\sin (\\theta + 120 \\degree)=-E_m\\sin (t+120 \\degree)\n$$\n\n综合上式可以看出，稳态运行时，在abc坐标系统中，电枢绕组的空载电压为按额定频率变换的正弦量，而在dq0坐标系统中则变为恒定的直流量。由于绕组轴线的变换，使绕组电动势的频率也发生了变换，这也可以从电机变换前后的物理模型中清楚的看到。\n\n## 负载运行\n同步电机带负载运行时，端电压与空载电动势之间会形成一定的相位差。假定端电压滞后于空载电动势的相角为$\\delta$，即为**功角**。则电机端电压的瞬时值可导出为\n\n$$\n\\begin{bmatrix}\nu_a \\\\ u_b \\\\ u_c\n\\end{bmatrix}=\n-U_m\n\\begin{bmatrix}\n\\sin (t - \\delta) \\\\\n\\sin (t - \\delta - 120 \\degree) \\\\\n\\sin (t - \\delta + 120 \\degree) \n\\end{bmatrix}\n$$\n\n式中，$U_m$为同步电机端电压幅值。\n\n将abc坐标系统的电枢绕组电压变换至dq0坐标系统，则$u_d$、$u_q$、$u_0$为\n\n$$\n\\begin{bmatrix}\nu_d \\\\ u_q \\\\ u_0\n\\end{bmatrix}=C\n\\begin{bmatrix}\nu_a \\\\ u_b \\\\ u_c\n\\end{bmatrix}=\n\\begin{bmatrix}\nU_m \\sin \\delta \\\\\nU_m \\cos \\delta \\\\\n0 \\\\\n\\end{bmatrix}\n$$\n\n稳态运行时，端电压幅值$U_m$及功角$\\delta$皆为恒值，所以$u_d$和$u_q$亦为恒值。同样地，对称稳态运行时，三相电流$i_a$、$i_b$、$i_c$以及电枢绕组电流$i_d$、$i_q$都为恒定直流且零序电流$i_0$为零。根据同步电机磁链方程式，可求得d、q绕组的磁链为\n\n$$\n\\psi_d = x_di_d + x_{ad}i_f = x_di_d + x_{ad}\\frac{u_f}{r_f} = x_di_d + E_m \\\\\n\\psi_q = x_q i_q\n$$\n\n根据上式，当电流$i_d$、$i_q$为恒值时，磁链亦为恒值。将上式代入电压方程式，并考虑同步转速下$\\omega = 1$，有\n\n$$\nu_d = -\\psi_q + r_ai_d = -x_qi_q + r_si_d \\\\\nu_q = \\psi_d + r_ai_q = E_m + x_di_d + r_si_q \\\\\n$$\n\n此处有$r_s=r_a$。三相对称绕组中每一相的电阻都是一致的，为表示方便，下面将用$r_s$代替定子电阻。\n\n当已知电压$u_d$、$u_q$、$u_f$及阻抗参数时，可解出电枢绕组电流$i_d$、$i_q$如下\n\n$$\ni_d = \\frac{r_su_d-x_q(E_m-u_q)}{r_s^2+x_dx_q}=\\frac{r_sU_m\\sin\\delta-x_q(E_m-U_m\\cos\\delta)}{r_s^2+x_dx_q} \\\\\ni_q = \\frac{-x_du_d-r_s(E_m-u_q)}{r_s^2+x_dx_q}=\\frac{-x_du_m\\sin\\delta-r_s(E_m-U_m\\cos\\delta)}{r_s^2+x_dx_q}\n$$\n\n实际中，同步电机定子电阻$r_s$的值远小于电抗$x_d$和$x_q$的值。当略去定子电阻$r_s$时，上式可化简为\n\n$$\ni_d = -\\frac{E_m-u_q}{x_d}=-\\frac{E_m-U_m\\cos\\delta}{x_d} \\\\\ni_q = - \\frac{u_d}{x_q} = - \\frac{U_m\\sin\\delta}{x_q}\n$$\n\n从上面求解过程也可看出，当三相对称稳态运行时，变换到d、q、0坐标系统下的电枢绕组电压、电流均为直流。因此，将原三相稳态交流电路的问题转变成了稳态直流电路的问题，即将求解复代数方程式转变为求解实代数方程式，使计算大为简化，显示了dq0坐标系统在解三相对称稳态运行问题时的优越性。\n\n同步电机对称稳态运行时的磁链、电流、电压求出后，就可进一步分析同步发电机的有功功率、无功功率与电磁转矩。\n\n### 有功功率\n同步发电机电枢端的有功功率，只需将之前求出的电压和电流代入三相功率标幺值公式$P=u_di_d+u_qi_q+2u_0i_0$中即可得到，此时考虑定子电阻$r_s$，为\n\n$$\nP=u_di_d+u_qi_q \\\\\n= U_m\\sin\\delta\\frac{r_sU_m\\sin\\delta-x_q(E_m-U_m\\cos\\delta)}{r_s^2+x_dx_q}+U_m\\cos\\delta\\frac{-x_dU_m\\sin\\delta-r_s(E_m-U_m\\cos\\delta)}{r_s^2+x_dx_q}\\\\\n= \\frac{-1}{r_s^2+x_dx_q}[-r_sU_m^2+E_mU_m(x_q\\sin\\delta+r_s\\cos\\delta)+\\frac{U_m^2}{2}(x_d-x_q)\\sin2\\delta]\n$$\n\n若略去$r_s$，则\n\n$$\nP=-[\\frac{E_mU_m}{x_d}\\sin\\delta+\\frac{U_m^2}{2}(\\frac{1}{x_q}-\\frac{1}{x_d})\\sin2\\delta]\n$$\n\n对于隐级同步电机，因其$x_d=x_q$，则有\n\n$$\nP=-\\frac{E_mU_m}{x_d}\\sin\\delta\n$$\n\n从上面公式可看出，有功功率前面均有负号，这是由于按电动机惯例选取的正方向。因此，负功率意味着电枢端不是输入而是输出电功率，即运行在发电机状态。这也说明正方向的假设是可以人为选定的。按电动机惯例选取正方向，同样可以分析发电机的运行状态。本文中功率基值为三相电机的额定容量，即$P_b=3U_NI_N$，因此，用标么值表示的功率在形式上与电机学中不一致，但返回到有名值后就无差别了。\n\n### 无功功率\n电机的视在功率$S$与有功功率$P$和无功功率$Q$的关系为\n\n$$\nQ= \\sqrt {S^2-P^2}\n$$\n\n式中$S$为标幺值。\n\n三相视在功率的有名值为$3UI$，则有\n\n$$\nS=\\frac{3UI}{P_b}=\\frac{\\frac{3}{2}U_mI_m}{\\frac{3}{2}U_bI_b}=U_mI_m\n$$\n\n式中$U_m$和$I_m$分别为用标幺值表示的电枢绕组端电压和电流的幅值，它们与d、q轴电枢绕组的端电压和电流的关系分别为\n\n$$\nU_m=\\sqrt{u_d^2+u_q^2},I_m=\\sqrt{i_d^2+i_q^2}\n$$\n\n将视在功率$S$与有功功率$P$代入上式，可得无功功率$Q$的标幺值为\n\n$$\nQ=\\sqrt{(u_d^2+u_q^2)(i_d^2+i_q^2)-(u_di_d+u_qi_q)^2}=u_qi_d-u_di_q\n$$\n\n代入电压和电流，有\n\n$$\nQ=\\frac{-1}{r_s^2+x_dx_q}[E_mU_m(x_q\\cos\\delta-r_s\\sin\\delta)-\\frac{U_m^2}{2}(x_d+x_q)+\\frac{U_m^2}{2}(x_d-x_q)\\sin2\\delta]\n$$\n\n略去$r_s$时，有\n\n$$\nQ=-[\\frac{E_mU_m}{x_d}\\cos\\delta-\\frac{U_m^2}{2}(\\frac{1}{x_q}+\\frac{1}{x_d})+\\frac{U_m^2}{2}(\\frac{1}{x_q}-\\frac{1}{x_d})\\sin2\\delta]\n$$\n\n若为隐级同步电机，因$x_d=x_q$，则\n\n$$\nQ=-(\\frac{E_mU_m}{x_d}\\cos\\delta-\\frac{U_m^2}{x_d})\n$$\n\n### 电磁转矩\n将磁链式和电流式代入电磁转矩公式，有\n\n$$\nT_{em}=i_q\\psi_d-i_d\\psi_q=-\\frac{r_s(r_s^2+x_q^2)E_m^2}{(r_s^2+x_dx_q)^2}-\\frac{E_mU_m}{(r_s^2+x_dx_q)^2} \\\\\n\\times [(r_sx_d\\sin\\delta-x_q^2\\cos\\delta)2r_s+(x_dx_q-r_s^2)(r_s\\cos\\delta+x_q\\sin\\delta)] \\\\\n- \\frac{(x_d-x_q)U_m^2}{(r_s^2+x_dx_q)^2}[(x_d\\sin^2\\delta-x_q\\cos^2\\delta)r_s+\\frac{1}{2}(x_dx_q-r_s^2)\\sin2\\delta]\n$$\n\n上式中，等号左侧电磁转矩符号为负，说明该转矩方向与假定正方向相反，为制动转矩。\n\n上式中等号右侧的第一项称为短路转矩，为电机稳态短路$(U_m=0)$时的转矩。短路时电枢电流$i_{dk}$、$i_{qk}$为\n\n$$\ni_{dk}=-\\frac{x_qE_m}{r_s^2+x_dx_q},i_{qk}=-\\frac{r_sE_m}{r_s^2+x_dx_q}\n$$\n\n因此，电枢短路电流所引起的电枢电阻损耗为\n\n$$\ni_{dk}^2r_s+i_{qk}^2r_s=I_{km}^2r_s=\\frac{(r_s^2+x_q^2)E_m^2}{(r_s^2+x_dx_q)}r_s\n$$\n\n因$r_s^2 << x_q^2$，且$r_s^2 << x_dx_q$，可略去$r_s$的二次项，改写上式为\n\n$$\nT_k=-\\frac{(r_s^2+x_q^2)E_m^2}{(r_s^2+x_dx_q)^2}r_s \\approx -(\\frac{E_m}{x_d})^2r_s=-I_{km}^2r_s\n$$\n\n因此，短路转矩$T_k$仅与励磁绕组电流产生的空载电动势$E_m$有关，而与端电压$U_m$无关。当略去电枢绕组电阻$r_s$时，该转矩为零。\n\n转矩公式中等号右侧的第二项为同步转矩$T_s$，它不仅与励磁电流产生的空载电动势$E_m$有关，还和电枢绕组的端电压$U_m$有关，其对应基本电磁功率部分。当略去$r_s$时，$T_s$变为\n\n$$\nT_s = \\frac{E_mU_m}{x_d}\\sin\\delta\n$$\n\n转矩公式中等号右侧的第三项为磁阻转矩$T_r$，只有当直轴和交轴磁阻不等$(x_d \\neq x_q)$时，该转矩才存在，且只与$U_m$有关。其对应电磁功率中的磁阻功率部分。当略去$r_s$时，$T_r$变为\n\n$$\nT_r = - \\frac{U_m^2}{2}(\\frac{1}{x_q}-\\frac{1}{x_d})\\sin2\\delta\n$$\n\n当略去电枢电阻时，稳态对称情况下总的电磁转矩为\n\n$$\nT_{em}=-\\frac{E_mU_m}{x_d}\\sin\\delta-\\frac{U_m^2}{2}(\\frac{1}{x_q}-\\frac{1}{x_d})\\sin2\\delta\n$$\n\n可以看出，略去电枢电阻后，且直轴和交轴磁阻相等时，用标幺值表示的电磁转矩式（上式）与电枢端有功功率式完全一致。与电磁转矩相对应的电磁功率在不考虑电枢电阻损耗时，就是电枢端的有功功率。\n","categories":["电气工程"]},{"title":"【电机瞬态分析】交流电机综合动态方程式","url":"/2024/08/02/【电机瞬态分析】交流电机综合动态方程式/","content":"### 简介\n在实际运行中，不论电机受到电磁方面或是机械方面的扰动，都可以使电机的转矩失去平衡，导致发生机电过渡过程。在这种情况下，既有电机的电流、磁链、电磁转矩等电磁量的变化，又有电机的转速、机械转矩等机械量的变化，两者是相互影响的。之前几个小节所导出的电压方程式和转子运动方程式，正确地反映了电机的电磁、机械等量的内在联系和相互制约的关系。因此，一般情况下应该联立求解电压方程式和转子运动方程式。\n\n当转速不是恒值而是变量时，电压方程式中的$\\omega \\psi$为两个变量的乘积，转矩方程式中电磁转矩$T_{em}=i_q\\psi_d-i_d\\psi_q$，亦是两个变量的乘积，因此，转换为d、q、0坐标系统的同步电机电压方程式和转矩方程式，均为非线性微分方程式。一般来说，无法采用解析法而需采用数值法求解。\n\n将凸极同步电机的电压方程式和转子运动方程式合并，可得凸极同步电机的动态方程式。以该方程式为基础，根据隐极同步电机和感应电机的实际情况做适当简化，可分别得到他们各自的动态方程式。\n\n### 凸级同步电机动态方程式\n令机械阻尼转矩为\n\n$$\nT_D=k_p\\frac{d\\theta}{dt}=k_D \\omega$$\n式中$k_D$为机械阻尼系数。\n\n则转子运动方程式为\n$$\nH\\frac{d\\omega}{dt}=T_{em}-T_L-T_D=i_q\\psi_d-i_d\\psi_q-T_L-k_D\\omega\\\\\n=x_di_qi_d+x_{ad}i_qi_f+x_{ad}i_qi_D-x_qi_di_q-x_{aq}i_di_Q-T_L-k_D\\omega\n$$\n合并电压方程式和上式（转矩方程式），可得凸级同步电机的动态方程为\n$$\n\\begin{bmatrix}\nu_d \\\\ u_q \\\\ u_0 \\\\ u_f \\\\ 0 \\\\ 0 \\\\T_L \\\\ 0\n\\end{bmatrix}=\n\\begin{bmatrix}\nx_d & 0 & 0 & x_{ad} & x_{ad} & 0 & 0 & 0 \\\\\n0 & x_q & 0 & 0 & 0 & x_{aq} & 0 & 0 \\\\\n0 & 0 & x_0 & 0 & 0 & 0 & 0 & 0 \\\\\nx_{ad} & 0 & 0 & x_f & x_{ad} & 0 & 0 & 0\\\\\nx_{ad} & 0 & 0 & x_{ad} & x_D & 0 & 0 & 0\\\\\n0 & x_{aq} & 0 & 0 & 0 & x_Q & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 & -H & 0\\\\\n0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\\n\\end{bmatrix}p\n\\begin{bmatrix}\ni_d \\\\ i_q \\\\ i_0 \\\\ i_f \\\\ i_D\\\\ i_Q\\\\ \\omega\\\\\\theta\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nr_s & -\\omega x_q & 0 & 0 & 0 & -\\omega x_{aq} & 0 & 0 \\\\\n\\omega x_d & r_s & 0 & \\omega x_{ad} & \\omega x_{ad} & 0 & 0 & 0 \\\\\n0 & 0 & r_s & 0 & 0 & 0 & 0 & 0\\\\\n0 & 0 & 0 & r_f & 0 & 0 & 0 & 0\\\\\n0 & 0 & 0 & 0 & r_D & 0 & 0 & 0\\\\\n0 & 0 & 0 & 0 & 0 & r_Q & 0 & 0\\\\\nx_di_q & -x_qi_d & 0 & x_{ad}i_q & x_{ad}i_q & -x_{aq}i_d & -k_D & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 & -1 & 0\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\ni_d \\\\ i_q \\\\ i_0 \\\\ i_f \\\\ i_D\\\\ i_Q\\\\ \\omega\\\\\\theta\n\\end{bmatrix}\n$$\n\n显然这是一组非线性微分方程，直接求解较为困难,求解实际问题时，可根据求解问题的条件，从工程角度出发，做一些适当的简化。\n\n当转子转速$\\omega$为恒值，且己知时，对这类问题的求解就无需求解转子运动方程式，只需单独求解电压方程式，这时方程式是一组线性常系数微分方程式，可用解析法求解。对于变速问题，由于$\\omega$是变量，必须联立求解电压方程式和转子运动方程式，这时方程式是一组非线性微分方程式。一般情况下，只能将上式改写为状态方程式，采用数值法求近似解。\n\n### 隐级同步电机动态方程式\n隐级同步电机为柱形转子，直轴与交轴磁导相同，所以有\n$$\nx_{ad}=x_{aq},x_d=x_q\n$$\n按照此关系对凸级同步电机动态方程中的参数作修改后即可得到隐级同步电机的动态方程式。\n\n### 感应电机动态方程式\n感应电机中定子三相绕组为对称，转子为圆柱形，且无励磁绕组，而转子不论是绕线型还是鼠笼型都为对称绕组，所以感应电机中定子、转子的磁路和电路均为对称，因而直轴和交轴电枢反应电抗相等，即$x_{ad}=x_{aq}=x_m$。电枢绕组中$x_d=x_q=x_{ss}=x_{sl}+x_m$，原转子绕组中直轴和交轴阻尼绕组参数应该为现转子绕组的相应电抗$x_{rr}$和电阻$r_r$，即\n$$\nx_D=x_Q=x_{rr}=x_{rl}+x_m,r_D=r_Q=r_r\n$$\n将参数代入原凸级同步电机的动态方程式，并将式中的第四行、第四列去掉，转子直轴阻尼绕组电流$i_D$改为转子直轴绕组电流$i_{dr}$，交轴阻尼绕组电流$i_Q$改为转子交轴绕组电流$i_{qr}$，即可得到感应电机动态方程式。\n\n由于感应电机定子、转子磁路、电路均对称，转子位置改变时磁路的磁导不变，故坐标变换时，只要绕组轴线相对静止，就可以使电感系数变为常系数，这样绕组轴线既可选在定子方面也可选在转子方面。\n\n","categories":["电气工程"]},{"title":"晶振及其典型应用与设计参数","url":"/2024/07/31/晶振及其典型应用与设计参数/","content":"\n### 有源晶振(Oscillator)和无源晶振(Crystal)\n晶振可以分为两类：\n- 有源晶振(Oscillator)\n- 无源晶振(Crystal)\n\n#### 有源晶振(Oscillator)\n\n又被称为石英晶体振荡器（简写OSC或XO）。\n\n有源晶振包含*晶体振荡器*和*外围集成电路*两个部分，工程上多集成于同一封装内，以4pin贴片形式出现，体积较大，引脚分别为VCC、GND、OUT和NC。\n\n有源晶振不需要使用MCU的内部振荡器，信号稳定，质量较好，而且连接方式比较简单（仍需设置电源滤波，通常使用一个电容和电感构成滤波网络，输出端用一个小阻值的电阻过滤信号），不需要复杂的配置电路。\n\n适用场景：有成本和功耗要求，时钟信号精度、稳定性要求不高，IC内部有晶振时钟电路。\n\n有源晶振原始输出波形一般为**方波**（若封装内已集成整形电路）。实际观测时因示波器带宽限制可能无法看到方波而只能看到正弦波，因方波的傅里叶分解结果为基频和奇数次谐波叠加，若带宽不够，很容易只能看到高频方波的低频谐波分量，即只显示正弦波。参见：[有源晶振和无源晶振的输出波形](https://blog.csdn.net/qq_29350001/article/details/50680676)\n\n![有源晶振原始输出波形](/images/crystal/1.png)\n\n#### 无源晶振(Crystal)\n\n又被称为石英晶体（Xtal）。\n\n无源晶振是有2个引脚的无极性元件，需要借助于时钟电路才能产生振荡信号，自身无法起振。其信号质量较差，通常需要精确匹配外围电路（用于信号匹配的RLC元件），更换不同频率的晶体时周边配置电路也需要做相应的调整。\n\n适用场景：时钟要求高，IC内部无晶振时钟电路。\n\n无源晶振原始输出波形为**正弦波**。\n\n![无源晶振原始输出波形](/images/crystal/2.png)\n\n### 无源晶振的分析模型\n#### 电气模型\n在电气网络中，石英晶体可以转换成一组RLC等效电路，以利分析。这一电路模型有两个频率接近但特性不同的共振点：**低阻抗的串联共振点**与**高阻抗的并联共振点**。\n\n![无源晶振电路符号与等效电路](/images/crystal/3.png)\n\n$Laplace$变换后，该等效电路网络的阻抗可以写成以下形式：\n$$\nZ(s)=(\\frac{1}{sC_1}+sL_1+R_1)//(\\frac{1}{sC_0})\n$$\n或\n$$\nZ(s)=\\frac{s^2+s\\frac{r_1}{L_1}+\\omega_s^2}{(sC_0)[s^2+s\\frac{R_1}{L_1}+\\omega_p^2]}\n$$\n$$\n\\omega_s = 1/(\\sqrt{L_1C_1})\n$$\n$$\n\\omega_p = \\sqrt{\\frac{C_1+C_0}{L_1C_1C_0}}=\\omega_s \\sqrt{1+\\frac{C_1}{C_0}} \\approx \\omega_s(1+\\frac{C_1}{2C_0}) (C_0 >> C_1)\n$$\n式中$s=j\\omega$，$\\omega_s$为串联共振频率，$\\omega_p$为并联共振频率，单位均为$rad/s$。\n\n在晶体两端并联上额外的并联电容器会使并联后的整体共振频率降低，因此，石英晶体厂商在制作并测量石英晶体的并联共振频率时，会在特定的并联电容值（称为负载电容）下进行测试。如使用较小的电容值，振荡频率会比规格高，反之比规格低。这一特性也可以用来微调振荡频率。\n\n#### 共振模式\n石英晶体提供了两种共振模式，由$C_1$与$L_1$构成的串联共振，与由$C_0$、$C_1$与$L_1$构成的并联共振。\n\n对于一般的MHz级石英晶体而言，串联共振频率一般会比并联共振频率低若干KHz。频率在30MHz以下的石英晶体，通常工作时的频率处于串联共振频率与并联共振频率之间，此时石英晶体呈现电感性阻抗。因为，外部电路上的电容会把电路的振荡频率拉低一些。在设计石英晶体振荡电路时，也应令电路上的杂散电容与外加电容合计値与晶体厂商使用的负载电容值相同，振荡频率才会准确符合厂商的规格。\n\n频率在30MHz以上（到200MHz）的石英晶体，通常工作于串联共振模式，工作时的阻抗处于最低点，相当于$R_s$。此种晶体通常标示串联电阻（< 100 $\\Omega$）而非并联负载电容。为了达到高的振荡频率，石英晶体会振荡在它的一个谐波频率上，此谐波频率是基频的整数倍。因为偶数次谐波会使得晶体内电场互相抵消，只有奇数次谐波可以利用，例如3倍、5倍、与7倍的泛音晶体。要达到所要的振荡频率，振荡电路上会加入额外的电容器与电感器，以选择出所需的频率。\n\n#### 温度效应\n石英晶体的频率特性取决于形状或切割方式。音叉型晶体通常会切割成温度特性是以25℃为中心的抛物线。这意味着，音叉晶体振荡器在室温下产生的共振频率接近其目标频率，当温度或增加或减少时频率都会降低。频率-温度曲线为抛物线的常见32.768千赫音叉晶体的温度系数是负百万分之0.04/摄氏度²。\n$$\nf=f_0[1-0.04ppm(T-T_0)^2]\n$$\n也就是说，如不考虑制作误差，以这种石英晶体控制频率的时钟，如运作在比室温低10°C的环境下，每年会比运作在室温下慢2分钟；如运作在比室温低摄氏20°C的环境下，则每年会比运作在室温下慢8分钟。\n\n### 无源晶振典型电路及其参数\n#### 皮尔斯晶体振荡器（Pierce Crystal Oscillator）\n\n![Pierce Crystal Oscillator](/images/crystal/4.png)\n\n此电路中晶体决定了振荡频率，并以串联谐振频率工作，$f_s$在输出和输入之间提供低阻抗路径。谐振时存在180度相移，因而反馈为正。输出正弦波的幅度限制在MOSFET漏极端子的最大电压范围内。电阻器$R_1$控制反馈量和晶体驱动量，而射频扼流圈RFC上的电压在每个周期内反转。\n\n大多数数字时钟、手表和计时器都以某种形式使用皮尔斯振荡器，因为它可以使用最少的组件来实现。\n\n#### MCU振荡器\n\nMCU电路中，皮尔斯振荡器常以另一种较为简单的方式出现。\n\n![Pierce Crystal Oscillator (MCU)](/images/crystal/5.png)\n\n其中包括\n- $C_{L1}$、$C_{L2}$：外部负载电容\n- $R_{EXT}$：阻尼电阻，用于调节激励电流\n- $R_F$：反相器反馈电阻，强制反相器工作在线性放大区，用于改善起振。多数MCU会内置该电阻。\n\nMCU振荡器还有另一种更简洁的形式：\n\n![External Oscillator (MCU)](/images/crystal/6.png)\n\n该电路中省去了$R_{EXT}$。\n\n#### 负载电容($C_L$)\n负载电容的标称值通常由晶振制造商提供，标示为$C_L$。实际电路中的负载电容是并联在晶振两端的两个电容$C_{L1}$、$C_{L2}$，以及晶振内部电容以及布线电容（寄生电容）共同作用的结果，其计算公式为\n$$\nC_L=\\frac{C_1 \\times C_2}{C_1 + C_2}+C_{s}\n$$\n\n式中$C_{s}$是电路中其他杂散电容（包括晶振引脚电容和 PCB 布线电容），大小通常在3-5$pF$。\n\n实际应用中，选择负载电容的步骤为：\n- 查阅手册，确定晶振的标称负载电容 $C_L$。\n- 根据经验或者实际测量估算电路板的杂散电容，一般经验值为3-10$pF$。\n- 根据公式选择合适的$C_{L1}$、$C_{L2}$，使其满足标称负载电容的要求。\n\n#### 振荡频率(Oscillation frequency)\n振动频率是指与晶体谐振器一起工作的振荡电路的实际频率。振动频率由晶体谐振器决定，并受MCU、外部负载电容、PCB杂散电容等的影响。\n$$\nf_{osc}=f_{L}=f_{r}[\\frac{C_1}{2(C_0+C_s)}+1]\n$$\n式中$f_{L}$为负载共振频率，$f_{r}$为共振频率。\n*注意*：不能用示波器探头、万用表笔等测试工具直接探测晶振输入、输出端，因为示波器探头、万用表笔均具有寄生电容特性，测试时将改变整个负载电容的等效值，测试出的数据不准，同时也会改变晶体的ESR，甚至会出现晶振停振现象。\n\n参见：[如何测量振荡频率](https://www.murata.com.cn/zh-cn/products/timingdevice/crystalu/overview/basic/frequency)\n\n#### 激励功率 (Drive Level)和$R_{EXT}$\n激励功率是指施加在晶振上的功率，通常以微瓦 ($\\mu W$) 为单位。它表示晶振在工作时所消耗的能量。激励功率对于晶振的可靠性和寿命至关重要，过高的激励功率可能会导致晶振过热或损坏，过低的激励功率则可能导致晶振无法正常启动或工作不稳定。一般都按手册设计。\n\n激励功率的观测和调节可基于两种方法进行：\n\n##### 电流法\n根据\n$$\nDL=I_{RMS}^2 \\times ESR\n$$\n参见：[How to Measure the Drive Level](https://www.murata.com.cn/zh-cn/products/timingdevice/crystalu/overview/basic/drivelevel)\n##### 电压法\n此处略。\n\n$R_{EXT}$用于调节激励功率。\n\n#### 静态电容（Static Capacitance）\n静态电容即为并联电容（Parallel Capacitance,$C_0$），是指晶振在不振荡时其两端的电容。这一参数是晶振的固有特性之一，通常由制造商在晶振的规格书中给出。其在不施加任何电压或不进行振荡时测得。它反映了晶体材料和电极结构的固有特性。\n\n#### 温漂\n温漂是指晶振的振荡频率随温度变化而发生的偏移。温漂通常用 ppm/°C（百万分之几每摄氏度）来表示，它是晶振频率稳定性的重要指标之一。\n\n温漂受以下因素影响：\n- 材料特性。晶体材料的温度系数是影响温漂的主要因素。石英晶体的温度系数相对较低，但仍会随温度变化而导致频率漂移。\n- 晶体切割方式。不同的晶体切割方式（如 AT 切割、BT 切割等）对温漂有不同的影响。AT 切割的石英晶体在常用温度范围内具有较好的频率稳定性。\n- 电路设计。晶振电路中的元件（如负载电容、放大器等）对温度的敏感度也会影响整体的频率温漂。\n\n应对方法：\n- 选用温补晶振（TCXO），通过内部的温度补偿电路，修正因温度变化引起的频率漂移，从而提高晶振的频率稳定性。\n- 选用恒温控制晶振（OCXO），通过内置的恒温控制系统，将晶振保持在恒定温度下工作，极大地减少温漂影响。\n- 在温度相对稳定的环境中使用晶振，尽量避免极端温度变化。\n\n#### 品质因数（Quality Factor，Q值）\n品质因数$Q$是无量纲的参数，用来表示振荡系统的损耗情况。具体来说，它是储存在晶振中的能量与每周期损耗能量的比值。对于晶振，$Q$值越高，表示其能量损耗越小，振荡的稳定性和纯度越高。\n$$\nQ=\\frac{f_0}{\\Delta f}\n$$\n式中$f_0$为晶振谐振频率，$\\Delta f$为频率响应的带宽（即晶振在其谐振频率处的响应下降到其最大值的$1/\\sqrt 2$处的频率间隔）。\n\n高$Q$值晶振起振后的频率稳定性和噪声均较低，但其需要较长的起振时间以达到稳定。\n\n### 典型应用\nSTM32F429IRTx需要在OSC_IN和OSC_OUT引脚外接25MHz晶振以供系统高速时钟源HSE，同时通过内部锁相环（PLL）进行倍频。\n\n![外接的25MHz高频时钟源](/images/crystal/7.png)\n\n![使用的YXC X322525MOB4SI型无源贴片晶振](/images/crystal/8.png)\n\n手册推荐负载电容为10$pF$或20$pF$，选取10$pF$。\n\n根据工程设计经验，一般取手册值-2或-3$pF$后，再乘以2，作为目标负载电容值。此处即为\n$$\nC_L'=(C_L-2)\\times2=(10-2)\\times2=16pF\n$$\n根据\n$$\nC_L'=\\frac{C_1 \\times C_2}{C_1 + C_2}+C_{s}\n$$\n$C_s$经验值为5$pF$，所以可解得$C_1=C_2=22pF$。","categories":["电子与电路设计"]},{"title":"【电机瞬态分析】交流电机的运算电抗、等效电路、电磁转矩","url":"/2024/07/27/【电机瞬态分析】交流电机的运算电抗、等效电路、电磁转矩/","content":"## 同步电机等效运算电路\n在进行瞬态分析时，亦可根据导出的方程式画出相应的等效电路，这样比较直观也便于记忆。一般情况下，最关心的是电枢绕组各量的变化，即从电枢绕组的端点看，能反映瞬态方程式的等效电路和等效阻抗。通过从a、b、c坐标系统到d、q、0坐标系统的变换，将电感系数从变系数变为了常系数，并通过各基值的选取，使互感系数的标么值可逆，且$L_{ad}=M_{af}=M_{aD}=x_{ad}$，这样就在电路上无联系的几个绕组具备了等效为一个电路的基本条件。当转子转速$\\omega$=恒值时，电压方程式为常系数线性微分方程组，可采用拉氏变换将时域的微分方程转换为复频域的代数方程求解。\n\n下面就转子上只有励磁绕组和同时存在励磁和阻尼绕组两种情况，分别对电枢直轴链和交轴磁链的等效运算电路进行讨论。\n\n### 转子上只有励磁绕组时的等效运算电路\n该情况下，根据上篇文章的内容，由标幺值下交流电机方程式推导可得（磁链关系代入电压方程式），直轴电枢磁链方程和励磁绕组电压方程为\n$$\n\\psi_d=x_di_d+x_{ad}i_f\n$$\n$$\nu_f=px_{ad}i_d+(r_f+px_f)i_f\n$$\n式中$p$为时间微分算子。可见各变量为时间的函数，相应的方程为微分方程。当电流$i_d、i_f$的初值为零时，拉氏变换后方程的形式不变，但$p$为一代数复变量，各变量是以$p$为变量的变换函数，如变量$\\psi、i、u$经拉氏变换后分别用$\\psi(p)、I(p)、U(p)$表示，以示区别。如此改写后的磁链和电压方程式的变换函数为\n$$\nu_d(p)=x_dI_d(p)+x_{ad}I_f(p)\n$$\n$$\nU_f(p)=px_{ad}I_d(p)+(r_f+px_f)I_f(p)\n$$\n*注意*：此处的$p$在代数学意义上可视为拉普拉斯变换算子$s$。$U(p)$即等同于$U(s)$，从$U(t)$经$Laplace$变换而来。\n\n用$p$除等式$U_f(p)$两端，并考虑到$x_d=x_l+x_{ad}$，$x_f=x_{fl}+x_{ad}$，整理后可得\n$$\n\\psi_d(p)=x_lI_d(p)+x_{ad}[I_d(p)+I_f(p)]\n$$\n$$\n\\frac{U_f(p)}{p}=x_{ad}[I_d(p)+I_f(p)]+(x_{fl}+\\frac{r_f}{p})I_f(p)\n$$\n根据上式即可画出相应的直轴等效运算电路，如下图所示。\n\n![](/images/1.2/dzhoudengxiao.png)\n\n在多数情况下只需研究定子上的各变量，因而可以将等式中的转子电流项$I_f(p)$消去，以获得更加简明的关系式。应用戴维南定理，根据图(a)，得到开路电压$G(p)U_f(p)$及短路阻抗$x_d(p)$，即\n$$\n\\psi_d(p)=G(p)U_f(p)+x_d(p)I_d(p)\n$$\n式中\n$$\nG_(p)=\\frac{x_{ad}}{r_f+x_fp}\n$$\n$$\nx_d(p)=x_l+\\frac{1}{\\frac{1}{x_{ad}+\\frac{1}{x_{fl}+\\frac{r_f}{p}}}}\n$$\n式中$G_(p)$称为励磁电压对直轴磁链的传递函数，$x_d(p)$称为直轴运算电抗。二者都是具有恒系数的运算式，和电机瞬时转速无关，因而可以用来研究任意转速下电机的各种运行工况。\n\n### 转子上有励磁绕组、D轴阻尼绕组和Q轴阻尼绕组\n#### 直轴等效运算电路\n当转子直轴上除励磁绕组外还装有短路的阻尼绕组，且当各绕组电流初值为零时，可得到直轴电枢绕组磁链方程和励磁绕组、直轴阻尼绕组电压方程式的变换函数方程为\n$$\n\\psi_d(p)=x_dI_d(p)+x_{ad}I_f(p)+x_{ad}I_D(p)\n$$\n$$\nU_f(p)=px_{ad}I_d(p)+(r_f+px_f)I_f(p)+px_{ad}I_D(p)\n$$\n$$\n0=px_{ad}I_d(p)+px_{ad}I_f(p)+(r_D+px_D)I_D(p)\n$$\n用$p$除以等式两侧，考虑$x_d=x_l+x_{ad}$，$x_f=x_{fl}+x_{ad}$，$x_D=x_{Dl}+x_{ad}$，整理后有\n$$\n\\psi_d(p)=x_lI_d(p)+x_{ad}[I_d(p)+I_f(p)+I_D(p)]\n$$\n$$\n\\frac{U_f(p)}{p}=x_{ad}[I_d(p)+I_f(p)+I_D(p)]+(x_{fl}+\\frac{r_f}{p})I_f(p)\n$$\n$$\n0=x_{ad}[I_d(p)+I_f(p)+I_D(p)]+(x_{Dl}+\\frac{r_D}{p})I_D(p)\n$$\n根据上式，导出得有阻尼绕组时得直轴等效运算电路\n\n![](/images/1.2/zunidzhoudengxiao.png)\n\n根据戴维南定理，可得开路电压$G(p)U_f(p)$及短路阻抗$x_d(p)$，则$\\psi_d(p)$为\n$$\n\\psi_d(p)=G(p)U_f(p)+x_d(p)I_d(p)\n$$\n其中\n$$\nG(p)=\\frac{(x_Dx_{ad}-x_{ad}^2)p+x_{ad}r_D}{(x_fx_D-x_{ad}^2)p^2+(x_fr_D+x_Dr_f)p+r_fr_D}\n$$\n$$\nx_d(p)=x_l+\\frac{1}{\\frac{1}{x_{ad}}+\\frac{1}{x_{fl}+\\frac{r_f}{p}}+\\frac{1}{x_{Dl}+\\frac{r_D}{p}}}\n$$\n\n#### 交轴等效运算电路\n转子交轴上有短路的阻尼绕组，且各绕组电流初值为零时，可得到交轴电枢绕组磁链方程和交轴阻尼绕组电压方程式的变换函数为\n$$\n\\psi_q(p)=x_qI_q(p)+x_{aq}I_Q(p)\n$$\n$$\n0=x_{aq}I_q(p)+(x_Q+\\frac{r_Q}{p})I_Q(p)\n$$\n类似于直轴情况，考虑$x_q=x_l+x_{aq}$，$x_Q=x_{Ql}+x_{aq}$，消去交轴阻尼绕组电流后，有\n$$\n\\psi_q(p)=x_q(p)I_q(p)\n$$\n其中\n$$\nx_q(p)=x_l+\\frac{1}{\\frac{1}{x_{aq}}+\\frac{1}{x_{Ql}+\\frac{r_Q}{p}}}\n$$\n式中$x_q(p)$为交轴运算电抗。交轴等效运算电路如下图所示。\n\n![](/images/1.2/zuniqzhoudengxiao.png)\n\n## 运算电抗特性\n### 同步电抗、瞬变（暂态）电抗和超瞬变（次暂态）电抗\n\n根据上节内容，直轴、交轴运算电抗的等效电路可导出为下图（未消去转子电流）。\n![](/images/1.2/tu25.png)\n\n根据拉氏变换终值定理，$p$趋于零时，$t$趋于无穷大，即同步电机稳态运行所呈现的同步电抗。图中$p$趋于零时，其值相当于转子各绕组均断开时的电抗值，即\n$$\n\\lim_{p \\to 0}x_d(p)=x_l+x_{ad}=x_d\n$$\n$$\n\\lim_{p \\to 0}x_q(p)=x_l+x_{aq}=x_q\n$$\n根据拉氏变换初值定理，若转子上无阻尼绕组，根据等效电路，可得\n$$\n\\lim_{p \\to \\infin}x_d(p)=x_l+\\frac{1}{\\frac{1}{x_{ad}}+\\frac{1}{x_{fl}}}=x'_{d}\n$$\n$x'_{d}$即为同步电机的**直轴暂态电抗**，等效电路如图2-6(a)所示。\n\n若转子上有阻尼绕组，根据等效电路，有\n$$\n\\lim_{p \\to \\infin}x_d(p)=x_l+\\frac{1}{\\frac{1}{x_{ad}}+\\frac{1}{x_{fl}}+\\frac{1}{x_{Dl}}}=x''_{d}\n$$\n\n$x''_{d}$即为同步电机的**直轴次暂态电抗**，等效电路如图2-6(b)所示。\n\n同理，在交轴方向，根据等效电路，有\n$$\n\\lim_{p \\to \\infin}x_q(p)=x_l+\\frac{1}{\\frac{1}{x_{aq}}+\\frac{1}{x_{Ql}}}=x''_{q}\n$$\n$x''_{q}$即为同步电机的**交轴次暂态电抗**，等效电路如图2-6(c)所示。\n\n![](/images/1.2/tu26.png)\n\n可见，暂态电抗和次暂态电抗分别是无阻尼绕组和有阻尼绕组同步电机在瞬态的初瞬间，从电枢绕组端看进去的电抗。该数值在研究同步电机运行时非常有用。\n\n### 以时间常数形式来表示的运算电抗\n实际应用中，运算电抗$x_d(p)$和$x_q(p)$常用励磁绕组和阻尼绕组的时间常数来表示。\n\n当转子仅有励磁绕组而无阻尼绕组时，有\n$$\nx_d(p)=x_d-\\frac{x_{ad}^2p}{r_f+x_fp}=x_d[\\frac{r_f+(x_f-x_{ad}^2/x_d)}{r_f+x_fp}]=x_d(\\frac{r_f+x_f'p}{r_f+x_fp})=x_d(\\frac{1+T_f'p}{1+T_fp})\n$$\n式中，$x_f'$为电枢绕组短路时从励磁绕组端口看进去的瞬态电抗，$T_f'=x_f'/r_f$为励磁绕组瞬态时间常数。$T_f=x_f/r_f$为励磁绕组时间常数。\n\n电枢绕组短路时，从励磁绕组端口看进去的瞬态电抗$x_f'$的等效电路如图2-7所示。\n\n![](/images/1.2/tu27.png)\n\n当转子仅有励磁绕组时，**其时间常数$T_f'$就是电枢直轴瞬变电流衰减的时间常数$T_d'$**，即$T_f'=T_d'$，且$T_f=T_{d0}$。*注意*：此处时间常数单位均用时间的标幺值表示。\n\n求解瞬变电流时常使用运算电抗的倒数形式，有\n$$\n\\frac{1}{x_d(p)}=\\frac{1}{x_d} \\times \\frac{1+T_{d0}}{1+T_d'p}\n$$\n将该式展开为部分分式，并考虑到$x_d'=\\frac{T_d'}{T_{d0}}x_d$，有\n$$\n\\frac{1}{x_d(p)}=\\frac{1}{x_d}+(\\frac{1}{x_d'}-\\frac{1}{x_d})\\frac{T_d'p}{1+T_d'p}\n$$\n该形式在由复数域函数变换返回时域的原函数时非常方便。\n\n同理可推导，转子上除励磁绕组外，直轴上还装有阻尼绕组时的直轴运算电抗$x_d(p)$的时间常数表达式为\n\n$$\nx_d(p)=x_d[\\frac{\\sigma_{fD}' T_f' T_D' p^2+(T_f'T_D')p+1}{\\sigma_{fD}T_f T_Dp^2+(T_f+T_D)p+1}]\n$$\n\n式中，\n- $T_D$为直轴阻尼绕组本身的时间常数。$T_D=x_D/r_D$\n- $T_D'$为励磁绕组开路、直轴电枢绕组短路时，直轴阻尼绕组的时间常数（瞬态时间常数），$T_D'=x_D'/r_D$。\n- $T_D'$计算式中$x_D'=x_{Dl}+\\frac{1}{\\frac{1}{x_l}+\\frac{1}{x_{ad}}}=x_{Dl}+x_{ad}'$，为该情况下直轴绕组的等效电抗，$x_D'$等效电路如图2-8所示。\n\n![](/images/1.2/tu28.png)\n\n- $\\sigma_{fD}$为电枢绕组**开路**时，励磁绕组和直轴阻尼绕组间的漏磁系数，$\\sigma_{fD}=1-{x_{ad}^2}/{x_fx_D}$\n\n- $\\sigma_{fD}'$为电枢绕组**短路**时，励磁绕组和直轴阻尼绕组间的漏磁系数，$\\sigma_{fD}'=1-{x_{ad}'^2}/{x_f'x_D'}$\n\n漏磁系数反映绕组间电磁耦合的漏磁情况。当完全耦合无漏磁时，上述漏磁系数为零。实际上每个绕组总存在着只与各自绕组交链的漏磁链和相应的漏电感，因此，漏磁系数不会为零，其大小反映了漏磁的大小。\n\n转子上除励磁绕组外，直轴上还装有阻尼绕组时的直轴运算电抗$x_d(p)$的时间常数表达式可继续分解为$p$的因式形式：\n$$\nx_d(p)=\\frac{(T_d'p+1)(T_d''p+1)}{(T_{d0}'p+1)(T_{d0}''p+1)}x_d\n$$\n联立，时间常数由下列$p$的二次方程式确定：\n$$\n(T_{d0}'p+1)(T_{d0}''p+1)=\\sigma_{fD}T_fT_Dp^2+(T_f+T_D)p+1\n$$\n$$\n(T_d'p+1)(T_d''p+1)=\\sigma_{fD}'T_f'T_D'p^2+(T_f'+T_D')p+1\n$$\n式中\n$$\nT_{d0}'=\\frac{2\\sigma_{fD}T_fT_D}{(1-q)(T_f+T_D)}=\\frac{1}{2}(1+q)(T_f+T_D)\\approx T_f+T_D\n$$\n$$\nT_{d0}''=\\frac{2\\sigma_{fD}T_fT_D}{(1+q)(T_f+T_D)} \\approx  \\frac{\\sigma_{fD}T_fT_D}{(T_f+T_D)}\n$$\n$$\nT_d'=\\frac{2\\sigma_{fD}'T_f'T_D'}{(1-q')(T_f'+T_D')}=\\frac{1}{2}(1+q')(T_f'+T_D')\\approx T_f'+T_D'\n$$\n$$\nT_d''=\\frac{2\\sigma_{fD}'T_f'T_D'}{(1+q')(T_f'+T_D')} \\approx  \\frac{\\sigma_{fD}'T_f'T_D'}{(T_f'+T_D')}\n$$\n式中$q\\approx1$，$q'\\approx1$。\n\n上式中的$T_{d0}'$、$T_{d0}''$、$T_d'$、$T_d''$是同步电机主要的四个时间常数，其准确值计算由上式给出。但以上计算非常繁琐，工程计算角度可进一步简化。考虑阻尼绕组电阻$r_D$标幺值远大于励磁绕组电阻$r_f$的标幺值，而相应的电抗$x_D$、$x_f$的标幺值相近，$x_D'$、$x_f'$的标幺值亦相近，因此在直轴阻尼绕组和励磁绕组的时间常数中，$T_D$远小于$T_f$，且$T_D'$远小于$T_f'$。因而之前的计算式可进一步简化为\n$$\nT_{d0}'=T_f+T_D \\approx T_f = T_{d0}\n$$\n$$\nT_{d0}'' \\approx \\frac{\\sigma_{fD}T_fT_D}{(T_f+T_D)} \\approx \\sigma_{fD}T_D\n$$\n$$\nT_d'=T_f'+T_D' \\approx T_f'\n$$\n$$\nT_d'' \\approx \\frac{\\sigma_{fD}'T_f'T_D'}{(T_f'+T_D')} \\approx \\sigma_{fD}'T_D'\n$$\n进一步可导出\n$$\nT_{d0}'' \\approx \\sigma_{fD}T_D=(1-\\frac{x_{ad}^2}{x_fx_D})\\frac{x_D}{r_D}=(x_{Dl}+\\frac{1}{\\frac{1}{x_{ad}}+\\frac{1}{x_{fl}}})\\frac{1}{r_D}\n$$\n$$\nT_d'' \\approx \\sigma_{fD}'T_D'=(1-\\frac{x_{ad}'^2}{x_f'x_D'})\\frac{x_D'}{r_D}=(x_D'-\\frac{x_{ad}'^2}{x_f'})\\frac{1}{r_D}=(x_{Dl}+\\frac{1}{\\frac{1}{x_{ad}}+\\frac{1}{x_l}+\\frac{1}{x_{fl}}})\\frac{1}{r_D}\n$$\n当直轴设置有阻尼绕组时，从以上对直轴运算电抗$x_d(p)$导出的时间常数的准确计算式可看出，$T_{d0}'$、$T_{d0}''$、$T_d'$、$T_d''$四个时间常数均与励磁绕组和阻尼绕组两个绕组的时间常数有关，因为这两个绕组均放置在转子直轴上，二者之间存在类似于变压器一、二次绕组间的电磁能量传递关系。与变压器不同，同步电机中时间常数$T_D$远小于$T_f$，且$T_D'$远小于$T_f'$，因而可简化，简化后的等效电路见图2-9.\n\n![](/images/1.2/tu29.png)\n\n其中，$T_{d0}'$、$T_d'$是电枢绕组分别为开路、短路时励磁绕组的时间常数，二者与阻尼绕组无关；而$T_{d0}''$、$T_d''$是励磁绕组短路，电枢绕组分别为开路、短路时直轴阻尼绕组的时间常数。\n\n为方便逆变换，可导出$x_d(p)$的倒数形式为\n\n$$\n\\frac{1}{x_d(p)}=\\frac{1}{x_d}+(\\frac{1}{x_d'}-\\frac{1}{x_d})\\frac{T_d'p}{T_d'p+1}+(\\frac{1}{x_d''}-\\frac{1}{x_d'})\\frac{T_d''p}{T_d''p+1}\n$$\n\n交轴运算电抗$x_q(p)$的表达式亦可用时间常数表示为\n$$\nx_q(p)=x_q-\\frac{x_{aq}^2p}{r_Q+x_Qp}=x_q(\\frac{T_q''p+1}{T_{q0}''p+1})\n$$\n式中\n- $T_{q0}''$为交轴阻尼绕组本身的时间常数，$T_{q0}''=x_Q/r_Q$\n- $T_q''$为考虑到交轴电枢绕组短路时，交轴阻尼绕组的时间常数，$T_q''=\\frac{1}{r_Q}(x_{Ql}+x_{aq}x_l/(x_{aq}+x_l))$\n\n$T_{q0}''$和$T_q''$所对应的等效电路如图2-10所示。\n\n![](/images/1.2/tu210.png)\n\n为方便逆变换，可导出$x_q(p)$的倒数形式为\n\n$$\n\\frac{1}{x_q(p)}=\\frac{1}{x_q}+(\\frac{1}{x_q''}-\\frac{1}{x_q})\\frac{T_q''p}{1+T_q''p}\n$$\n\n## 同步电机的等效电路\n上文已经通过电枢磁链$\\psi_d(p)$、$\\psi_q(p)$的运算方程式，导出了等效运算电路及相应的运算电抗，在时域中也可画出类似于变压器和感应电机的同步电机等效电路。为获得直轴上各绕组的等效电路，将标幺值表示的直轴磁链方程式代入电压方程式，有\n$$\n\\begin{bmatrix}\nu_d\\\\u_f\\\\0\n\\end{bmatrix}=p\n\\begin{bmatrix}\nx_d & x_{ad} & x_{ad} \\\\\nx_{ad} & x_f & x_{ad} \\\\\nx_{ad} & x_{ad} & x_D\n\\end{bmatrix}\n\\begin{bmatrix}\ni_d \\\\ i_f \\\\ i_D \n\\end{bmatrix}+\n\\begin{bmatrix}\nr_a & 0 & 0 \\\\\n0 & r_f & 0 \\\\\n0 & 0 & r_D \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\ni_d \\\\ i_f \\\\ i_D \n\\end{bmatrix}+\n\\begin{bmatrix}\n-\\omega \\psi_q \\\\ 0 \\\\ 0\n\\end{bmatrix}\n$$\n相应的直轴等效电路如图2-11所示。\n\n![](/images/1.2/tu211.png)\n\n同理可列出交轴电压方程式为\n$$\n\\begin{bmatrix}\nu_q \\\\ 0\n\\end{bmatrix}=p\n\\begin{bmatrix}\nx_q & x_{aq} \\\\\nx_{aq} & x_Q\n\\end{bmatrix}\n\\begin{bmatrix}\ni_q \\\\ i_Q\n\\end{bmatrix}+\n\\begin{bmatrix}\nr_a & 0 \\\\\n0 & r_Q \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\ni_q \\\\ i_Q\n\\end{bmatrix}+\n\\begin{bmatrix}\n\\omega \\psi_d \\\\ 0\n\\end{bmatrix}\n$$\n相应的交轴等效电路如图2-12所示。\n\n![](/images/1.2/tu212.png)\n\n显然，方程式与等效电路图是对应的，从方程式可画出等效电路，反过来，根据等效电路图，利用基尔霍夫电压定律也可写出各绕组回路的电压方程式。\n\n根据前面分析的结果，分析隐极同步电机时，只要令上面等效电路中$x_{ad}=x_{aq}$，即可使用；分析感应电机时，再将励磁回路取消即可。\n\n下面就图2-11、2-12所示的同步电机等效电路图与通常电机学中感应电机等效电路图的异同比较如下：\n\n- 同步电机等效电路是根据各变量瞬时值写出的电压方程式画出的，可以研究**瞬态**和**稳态**问题。通常电机学中感应电机等效电路是根据求解正弦稳态电路的相量方程式画出的，只能求解**正弦稳态**问题。\n\n- 在频率折算上，稳态感应电机的等效电路是将旋转的转子绕组通过频率折算,把实际转子绕组的频率由$f_2=sf_1$转换为定子绕组频率$f_1$，而同步电机的等效电路是将静止的定子绕组轴线通过坐标变换变为与转子同步旋转的d、q两相绕组轴线，亦即将电枢绕组中频率为$f_1$的交流量转换为频率为零的直流量。\n\n## 同步电机的功率及电磁转矩\n有名值表示三相同步电机电枢端的瞬时输入功率为\n$$\nP=u_ai_a+u_bi_b+u_ci_c\n$$\n标幺值系统中功率基值为\n$$\nP_b=3U_NI_N=\\frac{3}{2}U_bI_b\n$$\n因此标幺值表示时电机电枢端瞬时三相输入功率为\n$$\nP^*=\\frac{2}{3}(u_a^*i_a^*+u_b^*i_b^*+u_c^*i_c^*)\n$$\n对上式中变量进行Park变换后，dq0坐标系中三相输入功率的标幺值为\n$$\nP^*=u_d^*i_d^*+u_q^*i_q^*+2u_0^*i_0^*\n$$\ndq0坐标系下因定子绕组由原先的“静止绕组”转化为“伪静止绕组”，绕组电感系数由时变系数转为常系数，因而先前在相坐标系统中导出的电磁转矩公式已经不再适用。下面以能量守恒原理为基础重新推导适用于这种绕组的电磁转矩表达式。\n\n由于零轴电流所产生的气隙合成磁场为零，仅产生与电枢绕组交链的漏磁场，因而不参与电磁功率的转换，故在推导电磁转矩时可以不考虑零轴分量。\n\n由dq0坐标系中三相输入功率的标幺值可知，零轴对应的输入功率为$2u_0i_0$，当不考虑电枢零轴分量时，从各端点输入的电功率瞬时值的总和为\n$$\nI'^TU'=u_di_d+u_qi_q+u_fi_f\n$$\n式中\n$$\nI'^T=\n\\begin{bmatrix}\ni_d & i_q & i_f & i_D & i_Q\n\\end{bmatrix}\n$$\n$$\nU'= \\begin{bmatrix}\nu_d & u_q & u_f & 0 & 0\n\\end{bmatrix}^T\n$$\n根据标幺值系统下电压方程式，可导出不考虑电枢零轴分量的电压方程式为\n$$\nU'=L'pI'+\\omega G'I'+R'I'\n$$\n式中'上标表示该矩阵未考虑零轴分量，其可以分别从相应的原始矩阵中除去零轴分量的第三行以及第三列得到。如该矩阵方程左乘以电流的转置矩阵$I'^T$，则功率方程为\n$$\nI'^TU'=I'^TL'pI'+I'^T\\omega G'I'+I'^TR'I'\n$$\n方程的左边是从各端点输入的总电功率，右边由二项组成：第一项为电流和磁链变化率的乘积，即$I'^TL'pI'=I'^Tp\\Psi'$，其代表了定、转子绕组储存磁场能量的变化率；第三项$I'^TR'I'$代表了定、转子绕组的电阻损耗。根据功平衡关系可知，第二项$I'^T\\omega G'I'$是跨过气隙由电功率转为机械功率的电磁功率。用转速$\\omega$除它，即得到用标么值表示的电磁转矩，即\n$$\nT_{em}=\\frac{I'^T\\omega G'I'}{\\omega}=I'^T G'I'\n$$\n矩阵$G$中第三行和第三列元素均为0，所以有\n$$\nI'^T G'I'=I^TGI\n$$\n即\n$$\nT_{em}=I^TGI\n$$\n该式适用于“伪静止绕组”电机。将电流矩阵$I$和矩阵$G$代入上式，可得三相同步电机的电磁转矩为\n$$\nT_{em}=i_q\\psi_d-i_d\\psi_q\n$$","categories":["电气工程"]},{"title":"【电机瞬态分析】交流电机在相坐标系统中的状态方程式、电磁转矩和转子运动方程式","url":"/2024/07/24/【电机瞬态分析】交流电机在相坐标系统中的状态方程式、电磁转矩和转子运动方程式/","content":"### 交流电机在相坐标系统中的状态方程式\n将先前得出的磁链方程式代入电压方程式，即可得到交流电机在相坐标系统中的电压方程式：\n$$\n\\begin{bmatrix}\nu_a \\\\\nu_b \\\\\nu_c \\\\\nu_f \\\\\nu_D \\\\\nu_Q\n\\end{bmatrix}=\np\n\\begin{bmatrix}\nL_{aa} & M_{ab} & M_{ac} & M_{af} & M_{aD} & M_{aQ}\\\\\nM_{ba} & L_{bb} & M_{bc} & M_{bf} & M_{bD} & M_{bQ}\\\\\nM_{ca} & M_{cb} & L_{cc} & M_{cf} & M_{cD} & M_{cQ}\\\\\nM_{fa} & M_{fb} & M_{fc} & L_{f}  & M_{fD} & 0 \\\\\nM_{Da} & M_{Db} & M_{Dc} & M_{Df} & L_{D} & 0  \\\\\nM_{Qa} & M_{Qb} & M_{Qc} & 0 & 0 & L_{Q}\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\ni_a\\\\\ni_b\\\\\ni_c\\\\\ni_f\\\\\ni_D\\\\\ni_Q\n\\end{bmatrix}+\n\\begin{bmatrix}\nr_a & & & & & \\\\\n & r_b & & & & \\\\\n & & r_c & & & \\\\\n & & & r_f & & \\\\\n & & & & r_D & \\\\\n & & & & & r_Q \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\ni_a\\\\\ni_b\\\\\ni_c\\\\\ni_f\\\\\ni_D\\\\\ni_Q\n\\end{bmatrix}\n$$\n即\n$$\nU=p(LI)+RI\n$$\n矩阵中各绕组的自感系数和互感系数在之前的文章中已有推导。\n\n这是一组表述电机基本电磁关系的*时变*系数的微分方程组，在已知电感系数和电阻的情况下，利用这组方程就可以求解**恒速**运转时电机的瞬态和稳态运行问题。由于定子绕组电感系数和定、转子绕组间的互感系数均为位置角$\\theta$的函数，即为时间的函数，因此，在求解上述电压方程式时,不能采用解析方法,而需采用数值解法。\n\n用数值法求解微分方程组,可将式$U=p(LI)+RI$改写为状态方程组。状态方程是一组一阶的微分方程式。在电机分析中利用状态变量法时，一般可选取各绕组回路中的电流或磁链作为状态变量，这些变量都是不能突变的量。*此处的更多内容请参阅《线性控制理论》。*\n\n若选取定子三相电流$i_a$、$i_b$、$i_c$，及转子绕组电流$i_f$、$i_D$、$i_Q$为状态变量，则电压方程式可改写为：\n$$\nU=pLI+RI=(pL)I+LpI+RI\n$$\n式中$pL$为电感系数矩阵的一阶导数。\n\n用状态方程组的标准形式将上式表示如下\n$$\n\\dot I = AI + BU\n$$\n式中\n$$\nA=-L^{-1}[D+R]\\\\\nD=pL\\\\\nB=L^{-1}\n$$\n当需要考虑电感系数的高次谐波项时，由于定子绕组的自感系数和互感系数，及定、转子绕组间的互感系数均为位置角$\\theta$的无穷三角级数，系数矩阵$L$及其导数$D$的计算工作量很大，用手工计算是不可能的，因而随着计算机技术的发展和广泛应用，可利用计算机求解上述状态方程组的数值解。\n\n相坐标系统下导出的凸极同步电机的电压方程式，只要作相应的变化，就可适用于隐极同步电机和感应电机。隐极同步电机与凸极同步电机的差别是隐极同步电机的气隙为均匀的。感应电机与隐极同步电机相比，定子结构都是相同的，气隙也是均匀的，只是感应电机转子绕组中没有励磁绕组，感应电机的短路转子绕组相当于同步电机的阻尼绕组。所以从凸极同步电机入手推导的方程式，只需作很小的变动，就可以方便地用于隐极同步电机和感应电机。\n\n相坐标系统下交流电机的电压方程式的特点是可以考虑空间气隙磁场谐波，适用于计算磁场谐波很强的电机。利用这些方程，可求解**恒速**运转时的电机瞬态和稳态运行问题。如果再加上电机的电磁转矩和转子运动方程，电机变速运转时的机电过渡过程也可求解。下节将对电机的电磁转矩和转子运动方程加以讨论。\n\n### 交流电机电磁转矩和转子运动方程式\n电磁转矩是电机进行机电能量转换的关键量，也是表征电机性能的重要量。而转子运动方程是根据牛顿定律写出的作用在电机转子上的转矩之间的平衡方程式，当考虑转子转速变化时，除上述电压方程式外，尚需增加转子运动方程式联立求解。下面先讨论交流电机的电磁转矩。\n\n设交流电机的定子绕组有$m$个回路，以下标\"$sm$\"表示定子第$m$个回路；转子绕组有$n$个回路，以下标\"$rn$\"表示定子第$n$个回路。假设磁路为线性，则电机的总磁场能量为\n$$\nW_{m}=\\frac{1}{2}(\\psi_{s1}i_{s1}+\\psi_{s2}i_{s2}+...+\\psi_{sm}i_{sm}+\\psi_{r1}i_{r1}+\\psi_{r2}i_{r2}+...+\\psi_{rn}i_{rn})\n$$\n式中各回路的磁链分别为\n$$\n\\psi_{s1}=L_{s1}i_{s1}+...+M_{s1sm}i_{sm}+M_{s1r1}i_{r1}+...+M_{s1rn}i_{rn}\\\\\n...\\\\\n\\psi_{sm}=M_{sms1}i_{s1}+...+L_{sm}i_{sm}+M_{smr1}i_{r1}+...+M_{smrn}i_{rn}\\\\\n\\psi_{r1}=M_{r1s1}i_{r1}+...+M_{r1sm}i_{sm}+L_{r1}i_{r1}+...+M_{r1rn}i_{rn}\\\\\n...\\\\\n\\psi_{rn}=M_{rns1}i_{s1}+...+M_{rnsm}i_{sm}+M_{rnr1}i_{r1}+...+L_{rn}i_{rn}\n$$\n\n若改写为矩阵形式，可表示为\n$$\nW_m=\\frac{1}{2}I^TLI\n$$\n\n根据*虚位移定理*，当各回路电流保持不变时，有\n$$\nf=\\frac{\\partial W_m}{\\partial g}|i=const\n$$\n式中$f$为广义力，$g$为广义位移。\n\n若视广义位移为转子绕组参考轴线领先于定子绕组参考轴线的机械角度$\\gamma$，则广义力即为电机的电磁转矩$T_{em}$，有\n$$\nT_{em}=\\frac{\\partial W_m}{\\partial \\gamma}=\\frac{\\partial (\\frac{1}{2}I^TLI)}{\\partial \\gamma}=\\frac{1}{2}I^T\\frac{\\partial L}{\\partial \\gamma}I\n$$\n\n电机极对数为$p$，$\\theta$为转子绕组参考轴线领先于定子绕组参考轴线的电角度，$\\gamma$为同步电机d轴领先于a轴的位置角（机械角度），则有\n$$\n\\gamma = \\theta / p\n$$\n电磁转矩可继续改写为\n$$\nT_{em}=\\frac{p}{2}I^T\\frac{\\partial L}{\\partial \\theta}I\n$$\n在建立转子运动方程时，按电动机惯例选用电磁转矩的正方向，它的正方向与转子正常旋转方向一致。如下图；\n\n![建立转子运动方程用图](/images/1.2/zhuanzifangcheng.png)\n\n\n其中$T_{em}$为电动机的电磁转矩，是驱动转矩；$T_m$为负载的机械转矩，是制动转矩；剩余转矩$T_{em}-T_m$则为加速转矩。由此可得转子运动方程为\n$$\nJ\\frac{d\\Omega}{dt}=T_{em}-T_m\n$$\n式中$J$为转动惯量($kgm^2$)，$\\Omega$为转子机械角速度，$\\Omega=\\frac{d\\gamma}{dt}$。\n\n电机中常用电弧度来表示角度，将上式改写为：\n$$\nJ\\frac{1}{p} \\times \\frac{d\\omega}{dt}=J\\frac{1}{p} \\times \\frac{d^2\\theta}{dt^2}=T_{em}-T_m\n$$\n式中$\\omega$为转子转速($rad/s$)，$\\omega = \\frac{d\\theta}{dt}$。\n\n根据电力拖动内容，若转动部分飞轮转矩为$GD^2$，工程常用单位为$t·m^2$，则\n$$\nJ=\\frac{1}{4}GD^2 \\times 10^3 kgm^2\n$$\n联立转化为状态方程为\n$$\n\\frac{d\\omega}{dt}=\\frac{p}{J}(T_{em}-T_m)\\\\\n\\frac{d\\theta}{dt}=\\omega\n$$\n当需要求解电机变速问题，即$\\omega$不为常系数时，需通过联立求解两个状态方程式（上节和本节）得到各状态变量。此时$\\theta \\neq \\omega t + \\theta_0$，需通过上式中的第二式解出$\\theta$。\n\n### 转子运动方程式的标幺值形式\n\n工程实践中，转子运动方程式常用标幺值形式。转矩的基值一般选为\n$$\nT_b=\\frac{S_N \\times 10^3}{\\frac{2\\pi n}{60}}\n$$\n式中$S_N$为电机额定视在功率($kVA$)，$n$为电机同步转速($r/min$)。\n\n时间基值一般选为$\\tau_b=\\frac{1}{2\\pi f}$，即为电机转过一个电弧度所需的时间。用转矩基值除原式的两侧，可得\n$$\nH\\frac{d^2\\theta}{dt^2}=H\\frac{d\\omega^*}{dt^*}=(T_{em}^*-T_m^*)\n$$\n其中$H$被称为惯性常数，可导出为\n$$\nH=\\frac{1}{p} \\times \\frac{GD^2}{S_N}2\\pi^3f^2(\\frac{n}{60})=2\\pi^3f\\times \\frac{GD^2}{S_N}(\\frac{n}{60})^2\n$$\n$H$和时间标幺值之间有简单的关系：\n$$\ndt^*=\\frac{Hd\\omega^*}{T_{em}^*-T_m^*}\n$$\n假设剩余转矩$T_{em}^*-T_m^*=1$，电机转速从零上升至同步转速($\\omega^*=1$)所需的时间为$\\tau$，则\n$$\n\\tau = \\int_{0}^{\\tau}dt^*=\\int_{0}^{1}Hd\\omega^*=H\n$$\n可见，在原来静止的电机转子上加上标幺值为1的剩余转矩后，转速由零上升至同步转速的时间标幺值等于$H$。\n","categories":["电气工程"]},{"title":"【电机瞬态分析】同步电机标幺值系统","url":"/2024/07/21/【电机瞬态分析】同步电机标幺值系统/","content":"### 标幺值系统\n电气工程领域中，因采用有名值时不同容量电机参数之间不便于比较，故通常的工程计算中多采用标幺值系统。\n\n标幺值的定义为：标幺值=有名值/基值。其中基值与有名值的单位应当相同。\n\n要采用标幺值系统，则必须首先解决基值的选取问题。电机分析最常用的一套基值系统选取原则为：\n- 使采用标幺值后电机各方程式的形式与采用有名值时的相同\n- 用标幺值表示的电枢与转子绕组间的互感系数是可逆的\n\n显然电机中各物理量的量纲都可以表示为电压、电流和时间三个量纲的组合，因此只要确定这三个变量的基值，就可推广确定电机运行中所有变量的标幺值基值。\n\n### 定子各变量基值的选取\n瞬态分析时各变量均采用瞬时值形式，故电压、电流基值常采用其额定值的幅值，而不使用其有效值。\n\n- 定子电流基值$I_b$选取定子相电流额定值的幅值\n- 定子电压基值$U_b$选取定子相电压额定值的幅值\n- 时间基值$\\tau_b=1/\\omega_N=1/2{(\\pi f_N)}(s)$，即在额定频率$f_N$下经过一个电弧度所需的时间。\n\n以上三个变量均为独立地选取其基值，为保证方程式形式在使用标幺值系统时保持不变，以下变量的基值需要根据量纲关系，基于上述三个基本变量的基值进行导出。\n\n- 阻抗基值：$Z_b=\\frac{U_b}{I_b}$  $(\\Omega=V/A)$\n- 角频率基值 $\\omega_b=\\frac{1}{\\tau_b}$ $(rad/s)$\n- 电感基值 $L_b=\\frac{Z_b}{\\omega_b}=\\frac{U_b}{I_b}\\tau_b$ $(H=Vs/A)$\n- 磁链基值 $\\psi_b=L_bI_b=U_b\\tau_b$ $(Wb=Vs)$\n\n此处电感基值的推导基于$Z_L=j\\omega L$。\n\n以下基值按惯用方法选取：功率基值取三相**额定**视在功率，即\n- 功率基值 $P_b=3U_NI_N=\\frac{3}{2}U_{Nm}I_{Nm}=\\frac{3}{2}U_bI_b$ $(VA)$ （注意$U_b$和$I_b$均为幅值而非有效值，所以等式第三项要除以两次根号2）\n- 转矩基值 $T_b = \\frac{P_b}{\\Omega_N}=\\frac{P_b}{\\omega_b}p$ $(Nm)$ 式中$\\Omega_N$为额定机械角速度，单位$rad/s$；$p$为磁极对数。\n（注意此处有$\\omega_b=p\\Omega_N$，即同步电机电气角频率基值等于电机额定机械角速度乘以极对数。对于单极电机，额定机械角速度等于电气角频率；对于多极电机，电气角频率一般数倍于额定机械角速度。）\n\n### 转子各量基值的选取\n转子的时间基值$\\tau_b$与定子一致，关键是要确定转子各绕组电压、电流基值。下面讨论常用的可逆的互感系数和$x_{ad}$基值系统的转子基值选取方法。\n\n假定：\n- $I_{fb}$、$U_{fb}$、$\\psi_{fb}$为励磁绕组的电流基值、电压基值和磁链基值；\n\n- $I_{Db}$、$U_{Db}$、$\\psi_{Db}$为直轴阻尼绕组的电流基值、电压基值和磁链基值；\n\n- $I_{Qb}$、$U_{Qb}$、$\\psi_{Qb}$为交轴阻尼绕组的电流基值、电压基值和磁链基值。\n\n令定子电流基值及电压基值与转子绕组相应量的基值的比值为\n$$\nk_{if}=\\frac{I_b}{I_{fb}},k_{iD}=\\frac{I_b}{I_{Db}}.k_{iQ}=\\frac{I_b}{I_{Qb}}\\\\\nk_{uf}=\\frac{U_b}{U_{fb}},k_{uD}=\\frac{U_b}{U_{Db}}.k_{uQ}=\\frac{U_b}{U_{Qb}}\n$$\n\n由$\\psi=LI$和$L_b=\\frac{Z_b}{\\omega_b}=\\frac{U_b}{I_b}\\tau_b$，可推导得$\\psi_b=U_b\\tau_b$。所以定子、转子磁链基值比与电压基值比相同，即：\n$$\nk_{uf}=\\frac{\\psi_b}{\\psi_{fb}},k_{uD}=\\frac{\\psi_b}{\\psi_{Db}},k_{uQ}=\\frac{\\psi_b}{\\psi_{Qb}}\n$$\n用标幺值表示的磁链方程式可推导为：\n$$\n\\left[\\begin{array}{l}\n\\psi_{d}^* \\\\\n\\psi_{f}^* \\\\\n\\psi_{D}^* \n\\end{array}\\right]=\\left[\\begin{array}{ccc}\nL_d^* & M_{af}^* & M_{aD}^*\\\\\nM_{fa}^* & L_f^* & M_{fD}^*\\\\\nM_{Da}^* & M_{Df}^* & L_D^*\n\\end{array}\\right]\\left[\\begin{array}{l}\ni_{d}^* \\\\\ni_{f}^* \\\\\ni_{D}^* \n\\end{array}\\right]\n$$\n上式中各自感系数和互感系数的标幺值可推导如下：\n$$\nM_{af}^*=\\frac{M_{af0}}{L_b}\\frac{1}{k_{if}}\\\\\nM_{fa}^*=\\frac{\\frac{3}{2}M_{af0}}{L_b}k_{uf}\\\\\nL_{d}^*=\\frac{L_d}{L_b}\\\\\nM_{aD}^*=\\frac{M_{aD0}}{L_b}\\frac{1}{k_{iD}}\\\\\nM_{Da}^*=\\frac{\\frac{3}{2}M_{aD0}}{L_b}k_{uD}\\\\\nL_f^*=\\frac{L_f}{L_b}\\frac{k_{uf}}{k_{if}}\\\\\nL_D^*=\\frac{L_D}{L_b}\\frac{k_{uD}}{k_{iD}}\\\\\nM_{fD}^*=\\frac{M_{fD}}{L_b}\\frac{k_{uf}}{k_{iD}}\\\\\nM_{Df}^*=\\frac{M_{Df}}{L_b}\\frac{k_{uD}}{k_{if}}\n$$\n\n要使以上各式中的互感系数可逆，即要求\n$$\nM_{af}^*=M_{fa}^*,M_{aD}^*=M_{Da}^*,M_{fD}^*=M_{Df}^*\n$$\n显然要令上式成立，则必须在标幺值系统中选取合适的转子电流基值和电压基值，即：\n$$\nk_{uf}k_{if}=\\frac{2}{3},\nk_{uD}k_{iD}=\\frac{2}{3},\nk_{uQ}k_{iQ}=\\frac{2}{3}\n$$\n因此，要获得可逆的互感系数，**定、转子各绕组的电压基值比与电流基值比的乘积需等于2/3**。\n\n显然这个条件很容满足，这说明在定子各量基值已经选定并要求互感系数可逆的条件下，转子方面的电流基值和电压基值的选取方式仍然很多，但$k_i$和$k_u$中则只能自由选定其中一个，另一个则由2/3法则确定。\n\n工程上常用$x_{ad}$基值系统来确定转子方面的变量基值。该系统中，电枢d轴绕组自感中对应主磁场部分（$L_{ad}$）的标幺值、电枢d轴绕组与励磁绕组互感系数$M_{af}$的标幺值以及电枢d轴绕组与直轴阻尼绕组互感系数$M_{aD}$的标幺值相等，即\n$$\nL_{ad}^*=M_{af}^*=M_{aD}^*\n$$\n\n将等式代入，很容易得到：\n$$\nL_{ad}I_b=M_{af0}I_{fb}\n$$\n可见$x_{ad}$基值系统中励磁电流基值选取的规则是：励磁电流基值所产生的通过气隙的主磁场与电枢d绕组的互感磁链应与电枢d绕组通过基值定子电流所产生的通过气隙的自感磁链相等。\n\n励磁电流基值$I_{fb}$也可通过实验求得。将上式两边同乘以额定角频率$\\omega_N$，得\n$$\n\\omega_N M_{af0} I_{fb}=\\omega_N L_{ad}I_b=x_{ad}I_{Nm}\n$$\n该式表明基值励磁电流在定子各相绕组中将感生出有名值幅值为$x_{ad}I_{Nm}$的空载电动势。因此以下实验可确定励磁电流基值：同步电机以额定同步转速旋转，定子各绕组开路，励磁绕组通以电流，各项绕组中产生的基波空载（不计饱和）电压幅值为$x_{ad}I_b=x_{ad}I_{Nm}$,此时的励磁电流值即为励磁电流基值。\n\n按照该种方法选定转子电流基值后，可确定转子电压基值。原来不相等的一些电感系数还可以变为相等：\n$$\nL_{ad}^*=M_{af}^*=M_{fa}^*=M_{aD}^*=M_{Da}^*\\\\\nL_{aq}^*=M_{aQ}^*=M_{Qa}^*\\\\\nM_{fD}^*=M_{Df}^*=\\frac{M_{fD}}{L_b} \\times \\frac{2}{3}(\\frac{I_{fb}I_{Db}}{I_b^2})\\\\\nL_f^*=\\frac{L_f}{L_b} \\times \\frac{2}{3}(\\frac{I_{fb}}{I_b})^2\\\\\nL_D^*=\\frac{L_D}{L_b} \\times \\frac{2}{3}(\\frac{I_{Db}}{I_b})^2\\\\\nL_Q^*=\\frac{L_Q}{L_b} \\times \\frac{2}{3}(\\frac{I_{Qb}}{I_b})^2\n$$\n\n转子变量标幺值的折算也可以作以下理解，即先将转子方面的参数折合到定子方面，然后再采用定子方面的基值求其标幺值，非常类似于变压器中高低压两侧的标幺值折算方法。如：\n$$\nL_f^*=\\frac{L_fk_{uf}}{L_bk_{if}}\n$$\n可以看作是励磁绕组自感$L_f$乘以$k_{uf}/k_{if}$折合到定子方面，再除以定子电感基值$L_b$。\n\n励磁绕组与直轴阻尼绕组间的互感系数标幺值$M_{Df}^*=M_{fD}^*$，在不考虑只与它们两个绕组共同交链的不通过气隙的漏磁链时，则有$M_{Df}^*=M_{fD}^*=L_{ad}^*$。一般情况下工程计算中都会作该简化，此时对电枢电流计算带来的误差可忽略，对转子电流计算会带来一定的误差。\n\n将$M_{Df}^*=M_{fD}^*=L_{ad}^*$代入磁链方程式中，并考虑电感标幺值与额定频率下相应电抗的标幺值在数值上相等，即$x^*=\\frac{\\omega_N L}{\\omega_b L_b}=L^*$，因此磁链方程式可以改写为：\n$$\n\\begin{bmatrix}\n\\psi_d^* \\\\\n\\psi_f^* \\\\\n\\psi_D^*\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nx_d^* & x_{ad}^* & x_{ad}^* \\\\\nx_{ad}^* & x_f^* & x_{ad}^* \\\\\nx_{ad}^* & x_{ad}^* & x_D^*\n\\end{bmatrix}\n\\begin{bmatrix}\ni_d^* \\\\\ni_f^* \\\\\ni_D^*\n\\end{bmatrix}\n$$\n同理有\n$$\n\\begin{bmatrix}\n\\psi_q^* \\\\\n\\psi_Q^* \n\\end{bmatrix}\n=\n\\begin{bmatrix}\nx_q^* & x_{aq}^*  \\\\\nx_{aq}^* & x_Q^*  \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\ni_q^* \\\\\ni_Q^*\n\\end{bmatrix}\n$$\n其中\n$$\n\\begin{aligned}\nx_d^* &= x_l^* + x_{ad}^* \\\\\nx_q^* &= x_l^* + x_{aq}^* \\\\\nx_f^* &= x_{fl}^* + x_{ad}^* \\\\\nx_D^* &= x_{Dl}^* + x_{ad}^* \\\\\nx_Q^* &= x_{Ql}^* + x_{aq}^*\n\\end{aligned}\n$$\n励磁绕组电压基值可由以下方式确定。\n\n因为\n$$\nk_{uf}k_{if}=\\frac{U_b}{U_{fb}}\\times \\frac{I_b}{I_{fb}}=\\frac{2}{3}\n$$\n故\n$$\nU_{fb}=\\frac{3}{2}\\times\\frac{I_b}{I_{fb}}U_b\n$$\n\n励磁绕组阻抗基值的取法与电枢阻抗相似，为励磁绕组电压、电流基值的比，即\n$$\nZ_{fb}=\\frac{U_{fb}}{I_{fb}}=\\frac{3}{2}(\\frac{I_b}{I_{fb}})^2Z_b\n$$\n同样方法可求出直轴、交轴阻尼绕组的电压基值和阻抗基值。\n### 交流电机基本方程式的标幺值形式\n现在，就可以把原有的dq坐标系下的交流电机基本方程式改写为基于$x_{ad}$基值系统的标幺值形式。\n\n定、转子电压方程标幺值的形式与有名值形式下的相同，即\n$$\n\\begin{bmatrix}\nu_d^* \\\\\nu_q^* \\\\\nu_0^* \\\\\nu_f^* \\\\\nu_D^* \\\\\nu_Q^*\n\\end{bmatrix}\n=p\n\\begin{bmatrix}\n\\psi_d^* \\\\\n\\psi_q^* \\\\\n\\psi_0^* \\\\\n\\psi_f^* \\\\\n\\psi_D^* \\\\\n\\psi_Q^*\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nr_a^* & 0 & 0 & 0 & 0 & 0 \\\\\n0 & r_a^* & 0 & 0 & 0 & 0 \\\\\n0 & 0 & r_a^* & 0 & 0 & 0 \\\\\n0 & 0 & 0 & r_f^* & 0 & 0 \\\\\n0 & 0 & 0 & 0 & r_D^* & 0 \\\\\n0 & 0 & 0 & 0 & 0 & r_Q^*\n\\end{bmatrix}\n\\begin{bmatrix}\ni_d^* \\\\\ni_q^* \\\\\ni_0^* \\\\\ni_f^* \\\\\ni_D^* \\\\\ni_Q^*\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n-\\omega^* \\psi_q^* \\\\\n\\omega^* \\psi_d^* \\\\\n0 \\\\\n0 \\\\\n0 \\\\\n0\n\\end{bmatrix}\n$$\n将磁链方程式代入，整理可得\n$$\nU^*=L^*pI^*+\\omega^*G^*I^*+R^*I^*\n$$\n式中\n$$\nU^*=[U_{dq0}^* \\quad U_{fDQ}^*]^T\\\\\n$$\n$$\nI^*=[I_{dq0}^* \\quad I_{fDQ}^*]^T\n$$\n$$\nR^*=\n\\begin{bmatrix}\nR_{abc}^* & 0\\\\\n0 & R_{fDQ}^*\n\\end{bmatrix}\n$$\n$$\n\\begin{array}{c}\nL^{*}=\\left[\\begin{array}{cccccc}\nx_{\\mathrm{d}}^* & 0 & 0 & x_{\\mathrm{ad}}^{*} & x_{\\mathrm{ad}}^{*} & 0 \\\\\n0 & x_{\\mathrm{q}}^{*} & 0 & 0 & 0 & x_{a q}^{*} \\\\\n0 & 0 & x_{0}^{*} & 0 & 0 & 0 \\\\\nx_{\\mathrm{ad}}^{*} & 0 & 0 & x_{\\mathrm{f}}^{*} & x_{a d}^{*} & 0 \\\\\nx_{a d}^{*} & 0 & 0 & x_{ad}^{*} & x_{\\mathrm{D}}^{*} & 0 \\\\\n0 & x_{\\mathrm{aq}}^{*} & 0 & 0 & 0 & x_{\\mathrm{Q}}^{*}\n\\end{array}\\right] \n\n\\\\\n\nG^{*}=\\left[\\begin{array}{cccccc}\n0 & -x_{\\mathrm{q}}^{*} & 0 & 0 & 0 & -x_{a q}^{*} \\\\\nx_{d}^{*} & 0 & 0 & x_{\\mathrm{ad}}^{*} & x_{\\mathrm{ad}}^{*} & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0\n\\end{array}\\right]\n\\end{array}\n$$\n\n以上$G^*$为电压方程中角速度$\\omega^*$项的系数矩阵，反映了旋转电动势的项的系数大小，仅在电枢电压、$u_d^*$、$u_q^*$对应的行里有元素。\n\n可以看出，通过线性变换后，原来定子绕组a、b、c三相的各变量已被新的d、q、0坐标系统中各变量所取代。a、b、c三相绕组是实际存在的三个回路，其绕组轴线为静止的，且在空间上互差$2\\pi/3$电弧度。变换后的d、q、0坐标系统中各变量是d、q、0三个绕组回路的变量，其中d、q绕组的轴线与转子一道旋转，且d轴与转子直轴轴线(励磁绕组轴线)相重合，d、q轴在空间上相差$\\pi/2$电弧度。零轴绕组在电方面是独立的，与其他绕组无电磁耦合关系。\n\n从这以后，在一般不加说明的情况下，电机各量均采用标么值，并将表示标么值的“ * ”符号省去。","categories":["电气工程"]},{"title":"【电机瞬态分析】交流电机方程式（dq0坐标系）","url":"/2024/07/14/【电机瞬态分析】交流电机方程式（dq0坐标系）/","content":"### 概述\n上一篇文章对三相凸级同步电机在a、b、c坐标系下的电压方程式和磁链方程式，并且给出了定子和转子绕组之间的电感系数。在需要考虑气隙谐波磁场时，定子绕组的自感系数、互感系数，以及定子绕组和转子绕组之间的互感系数均是关于转子位置角$\\theta$的无穷级数。虽然工程中可以忽略高次项进行近似计算，但计算过程仍是非常复杂的。\n\n在仅考虑气隙磁场基波成分的前提下，通过Park变换，用dq0坐标系下的新变量替代原abc相坐标系下的变量，可使定子绕组的自感系数和互感系数又时变系数变为常系数。\n\n### 交流电机在dq0坐标系中的电压方程式和磁链方程式\n#### 相坐标系至dq0坐标系的变换\n由线性代数知识，当满秩线性变换时，新变量与原变量间具有单值的对应关系。此时，变换矩阵C（中间量）应为满秩。\n\n**满秩矩阵的充分必要条件是其行列式的值不为0。**\n\n在此变换下，线性变换和线性反变换式可写为：\n$$\nY = CX \\\\\nX = C^{-1}Y\n$$\n其中$C^{-1}$是$C$的逆矩阵。\n\n电机工程中最常用的坐标系即为dq0坐标系，即将原来静止的定子绕组a、b、c绕组变换至与转子同角速度旋转的d、q轴线及独立的零轴线代替，如下图所示。\n\n![电机绕组轴线位置](/images/1.2/raozuzhouxian.png)\n\n显然在使用dq0坐标系时，由于d、q轴随着转子旋转而与转子轴线呈相对静止，电枢绕组的自感和互感系数变为常数。零轴绕组在电磁方面为独立轴，与其他绕组无耦合关系。\n\n以电枢电流为例，变换后的新变量$i_d$，$i_q$，$i_0$与原变量$i_a$，$i_b$，$i_c$关系为：\n$$\n\\left[\\begin{array}{l}\ni_{d} \\\\\ni_{q} \\\\\ni_{0}\n\\end{array}\\right]=\\frac{2}{3}\\left[\\begin{array}{ccc}\n\\cos \\theta & \\cos \\left(\\theta-\\frac{2 \\pi}{3}\\right) & \\cos \\left(\\theta+\\frac{2 \\pi}{3}\\right) \\\\\n-\\sin \\theta & -\\sin \\left(\\theta-\\frac{2 \\pi}{3}\\right) & -\\sin \\left(\\theta+\\frac{2 \\pi}{3}\\right) \\\\\n\\frac{1}{2} & \\frac{1}{2} & \\frac{1}{2}\n\\end{array}\\right]\\left[\\begin{array}{l}\ni_{a} \\\\\ni_{b} \\\\\ni_{c}\n\\end{array}\\right]\n$$\n式中第三个新变量$i_0$与$i_a$，$i_b$，$i_c$的关系为\n$$\ni_0 = \\frac{1}{3}(i_a+i_b+i_c)\n$$\n$i_0$被称为定子绕组电流的零轴分量，为瞬时值。\n\n显然$i_0$与电机各项绕组连接方式有关：\n- 有中线连接时，$i_0$实际为电机中线电流的1/3\n- 无中线连接时。$i_0$为零\n\n后续分析同步电机及其系统时，若将电流分量变换至dq0坐标系，且原相坐标系中的电压、磁链等量也要同步变换至dq0坐标系，其变换矩阵$C$与电流变量的变换矩阵相同。\n\n#### 磁链方程式（dq0坐标系）\n将相坐标系中的磁链方程式转化为dq0坐标系中的磁链方程式，其过程如下：\n$$\n\\left[\\begin{array}{l}\n\\Psi_{dq0} \\\\\n\\Psi_{fDQ} \n\\end{array}\\right]=\\left[\\begin{array}{cc}\nC & 0 \\\\\n0 & E \n\\end{array}\\right]\\left[\\begin{array}{l}\n\\Psi_{abc} \\\\\n\\Psi_{fDQ} \n\\end{array}\\right]=\\left[\\begin{array}{cc}\nC & 0 \\\\\n0 & E \n\\end{array}\\right]\\left[\\begin{array}{cc}\nL_{ss} & L_{sr} \\\\\nL_{rs} & L_{rr}\n\\end{array}\\right]\\left[\\begin{array}{l}\nI_{abc} \\\\\nI_{fDQ}\n\\end{array}\\right]\n$$\n式中，$\\Psi_{dq0}$为电机电枢d、q、0三轴绕组的磁链矩阵表达式，$\\Psi_{dq0}=[\\phi_d \\quad \\phi_q \\quad \\phi_0]^{T}$；$\\Psi_{fDQ}$为电机电枢f、D、Q三轴绕组的磁链矩阵表达式，$\\Psi_{fDQ}=[\\phi_f \\quad \\phi_D \\quad \\phi_Q]^{T}$，$E$为单位矩阵。\n\n联立上述各式，可得计算后的结果为：\n$$\n\\left[\\begin{array}{l}\n\\psi_{d} \\\\\n\\psi_{q} \\\\\n\\psi_{0} \\\\\n\\psi_{f} \\\\\n\\psi_{D} \\\\\n\\psi_{Q}\n\\end{array}\\right]=\\left[\\begin{array}{cccccc}\nL_d & 0 & 0 & M_{af0} & M_{aD0} & 0\\\\\n0 & L_q & 0 & 0 & 0 & M_{aQ0}\\\\\n0 & 0 & L_0 & 0 & 0 & 0\\\\\n\\frac{3}{2}M_{af0} & 0 & 0 & L_f & M_{fD} & 0\\\\\n\\frac{3}{2}M_{aD0} & 0 & 0 & M_{Df} & L_{D} & 0\\\\\n0 & \\frac{3}{2}M_{aQ0} & 0 & 0 & 0 & L_Q\n\\end{array}\\right]\\left[\\begin{array}{l}\ni_{d} \\\\\ni_{q} \\\\\ni_{0} \\\\\ni_{f} \\\\\ni_{D} \\\\\ni_{Q}\n\\end{array}\\right]\n$$\n其中\n$$\nL_d = L_{aal}+M_{abl}+\\frac{3}{2}L_{mad}=L_{leak} + L_{ad} \\\\\nL_q = L_{aal}+M_{abl}+\\frac{3}{2}L_{maq}=L_{leak} + L_{aq} \\\\\nL_0 = L_{aal} - 2M_{abl}\n$$\n式中，$L_{aal}$为电枢a相绕组自漏感系数($l$意为$leak$)，$M_{abl}$为电枢a相和b相绕组之间的互漏感系数，$L_{aad}$为电枢a相绕组自感系数在d轴上的分量，$L_{aaq}$为电枢a相绕组自感系数在q轴上的分量。$M_{af0}$为定子a轴与励磁绕组d轴重合时所具有的最大互感系数，$M_{aD0}$为定子a轴与阻尼绕组D轴重合时所具有的最大互感系数，$M_{aQ0}$为定子a轴与阻尼绕组Q轴重合时所具有的最大互感系数，下标中的“0”表示该互感系数计算时仅考虑了基波分量。\n\n由上式可看出：\n\n- $L_d$和$L_q$分别是假想的电枢d轴绕组和电枢q轴绕组的自感系数。它包括不通过气隙的漏磁链所对应的自漏感系数$L_{leak}=L_{aal}+M_{abl}$以及通过气隙的主磁场所对应的电感系数$L_{ad}=\\frac{3}{2}L_{aad}$以及$L_{aq}=\\frac{3}{2}L_{aaq}$。\n\n- $L_0$是变换后假想的电枢零轴绕组的自感系数，其仅由漏感系数组成。\n\n- 电枢绕组从abc相绕组轴线转换为与转子同速旋转的d、q轴以及独立的零轴后，电枢绕组的自感系数及互感系数均由时变系数变为与$\\theta$角无关的常数。\n\n- 坐标变换使具有相互电磁耦合的abc相绕组变为没有耦合关系的假想的电枢d轴、q轴绕组，达到了解耦的目的。对于电机控制系统，该操作可获得更良好的控制性能。\n\n#### 电压方程式（dq0坐标系）\ndq0坐标系中的电压方程式可采用同样的方式从相坐标系统下的电压方程式转换而来，即\n$$\n\\left[\\begin{array}{l}\nU_{dq0} \\\\\nU_{fDQ} \n\\end{array}\\right]=\\left[\\begin{array}{cc}\nC & 0 \\\\\n0 & E \n\\end{array}\\right]\\left[\\begin{array}{l}\nU_{abc} \\\\\nU_{fDQ} \n\\end{array}\\right]=\\left[\\begin{array}{cc}\nC & 0 \\\\\n0 & E \n\\end{array}\\right]\\left[\\begin{array}{l}\np\\Psi_{abc} \\\\\np\\Psi_{fDQ}\n\\end{array}\\right]+\\left[\\begin{array}{cc}\nC & 0 \\\\\n0 & E \n\\end{array}\\right]\\left[\\begin{array}{cc}\nR_{abc} & 0 \\\\\n0 & R_{fDQ} \n\\end{array}\\right]\\left[\\begin{array}{l}\nI_{abc} \\\\\nI_{fDQ} \n\\end{array}\\right]\n$$\n\n式中，$U_{dq0}$为电枢d、q、0绕组轴端的电压矩阵，$U_{dq0}=[u_d \\quad u_q \\quad u_0]^{T}$。\n\n上式中等式右侧的第一项：\n$$\n\\left[\\begin{array}{cc}\nC & 0 \\\\\n0 & E \n\\end{array}\\right]\\left[\\begin{array}{l}\np\\Psi_{abc} \\\\\np\\Psi_{fDQ}\n\\end{array}\\right]=\\left[\\begin{array}{cc}\nC & (p \\quad \\Psi_{abc}) \\\\\np & \\Psi_{fDQ}\n\\end{array}\\right]\n$$\n根据磁链的Park变换：\n$$\n\\Psi_{dq0} = C \\Psi_{abc}\n$$\n故有\n$$\np \\Psi_{dq0} = (pC)\\Psi_{abc}+C(p \\quad \\Psi_{abc})\n$$\n可得\n$$\nC(p \\quad \\Psi_{abc}) = p\\Psi_{dq0} - (pC)\\Psi_{abc}\n$$\n可以证明其中\n$$\n-(pC)\\Psi_{abc} = -{pC}C^{-1}\\Psi_{dq0}=\\omega \\left[\\begin{array}{ccc}\n0 & -1 & 0 \\\\\n1 & 0 & 0 \\\\\n0 & 0 &0\n\\end{array}\\right]\\left[\\begin{array}{l}\n\\phi_d\\\\\n\\phi_q\\\\\n\\phi_0\n\\end{array}\\right]=\\left[\\begin{array}{c}\n-\\omega\\psi_q\\\\\n\\omega\\psi_d\\\\\n0\n\\end{array}\\right]\n$$\n式中$\\omega$为转子的瞬时转速，$\\omega = p \\theta$。\n\n转换式等式右侧的第二项（即电阻压降）可以写成：\n$$\n\\left[\\begin{array}{cc}\nC & 0 \\\\\n0 & E \n\\end{array}\\right]\\left[\\begin{array}{cc}\nR_{abc} & 0 \\\\\n0 & R_{fDQ} \n\\end{array}\\right]\\left[\\begin{array}{c}\nI_{abc} \\\\\nI_{fDQ} \n\\end{array}\\right]=\n\\left[\\begin{array}{cc}\nC & 0 \\\\\n0 & E \n\\end{array}\\right]\\left[\\begin{array}{cc}\nR_{abc} & 0 \\\\\n0 & R_{fDQ} \n\\end{array}\\right]\\left[\\begin{array}{cc}\nC^{-1} & 0 \\\\\n0 & E \n\\end{array}\\right]\\left[\\begin{array}{c}\nI_{dq0} \\\\\nI_{fDQ} \n\\end{array}\\right]\n=\n\\left[\\begin{array}{cc}\nR_{abc} & 0 \\\\\n0 & R_{fDQ} \n\\end{array}\\right]\\left[\\begin{array}{c}\nI_{dq0} \\\\\nI_{fDQ} \n\\end{array}\\right]\n$$\n联立上述各式，可导出dq0坐标系统下的电压方程式：\n$$\n\\begin{bmatrix}\nu_d \\\\\nu_q \\\\\nu_0 \\\\\nu_f \\\\\nu_D \\\\\nu_Q\n\\end{bmatrix}\n=p\n\\begin{bmatrix}\n\\psi_d \\\\\n\\psi_q \\\\\n\\psi_0 \\\\\n\\psi_f \\\\\n\\psi_D \\\\\n\\psi_Q\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nr_a & 0 & 0 & 0 & 0 & 0 \\\\\n0 & r_a & 0 & 0 & 0 & 0 \\\\\n0 & 0 & r_a & 0 & 0 & 0 \\\\\n0 & 0 & 0 & r_f & 0 & 0 \\\\\n0 & 0 & 0 & 0 & r_D & 0 \\\\\n0 & 0 & 0 & 0 & 0 & r_Q\n\\end{bmatrix}\n\\begin{bmatrix}\ni_d \\\\\ni_q \\\\\ni_0 \\\\\ni_f \\\\\ni_D \\\\\ni_Q\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n-\\omega \\psi_q \\\\\n\\omega \\psi_d \\\\\n0 \\\\\n0 \\\\\n0 \\\\\n0\n\\end{bmatrix}\n$$\n\n根据上式，显然假想的电枢d、q轴绕组的电压方程中，与a、b、c绕组的“静止绕组”相比，除$p\\psi$仅表示变压器电动势外，另有正比于角速度的运动电动势$\\omega\\psi$项存在。\n\n在dq0坐标系统中，因重新选取了电枢绕组的轴线，使得d、q轴线以$\\omega$转速旋转，而构成d、q绕组的线圈元件仍为静止，因而线圈元件与磁链之间存在相对运动，产生了运动电动势$\\omega\\psi$。这种绕组轴线与构成该绕组的线圈元件间存在相对运动的绕组称为“伪静止绕组”。\n\n#### 同步电机的派克（Park）方程\n\n派克变换(Park Transform)实际是以克拉克变换(Clark Transform，静止dq坐标系变换)推广而来。恒定幅值条件下的Clark线性变换矩阵即下图所示：\n\n![恒定幅值Clark变换矩阵](/images/1.2/park1.png)\n\n式中，矩阵前的常系数$\\frac{2}{3}$用于保证在变换后，变量的幅值仍保持不变。\n\n若需要进行恒功率Clark变换，变换矩阵可被替换为：\n\n![恒定功率Clark变换矩阵](/images/1.2/park2.png)\n\n当Clark变换被推广至旋转dq坐标系（即包含转子位置角$\\theta$作为变量）时，结合三角恒等变换，可导出Park变换方程。相关推导参见[《Clark变换与Park变换的推导》](https://blog.csdn.net/weixin_44462280/article/details/110290942)。\n\nPark方程为定常系数微分方程，在同步电机分析中使用该方程可以通过解析方法求解**恒速**运转时电机的瞬态和稳态运行问题。\n\n上述方程中各变量都是有名值,用有名值的好处是物理念明确,单位的量纲清楚,但在实际计算中往往有所不便,因此，分析计算电机的许多问题时，经常采用标么值。\n\n### dq0坐标系统与双反应理论\n电机学中已经介绍过，双反应理论是由Andre Blondel提出的一种解释同步电机内部磁场分布的方法。该理论假设同步电机的电枢磁动势（MMF）可以分解为两个独立的分量：\n\n- d轴反应：与转子磁链对齐的磁动势分量，主要影响电机的励磁电流。\n\n- q轴反应：与d轴垂直的磁动势分量，主要影响电机的转矩电流。\n\n双反应理论认为这两个反应是独立的，并且可以分别计算，从而简化了电机的分析。\n\ndq0坐标系统与双反应理论在概念和应用上具有很大的统一性。具体表现如下：\n\n- 坐标对齐：在dq0坐标系统中，d轴和q轴分别对应双反应理论中的d轴反应和q轴反应。这使得电机的磁动势和电流可以通过这两个独立的分量来表示。\n\n- 数学简化：两者都旨在简化电机的数学分析。dq0坐标系统将交流变量转换为直流变量，而双反应理论将复杂的三相系统分解为两个独立的轴。这两种方法结合使用，可以大大简化电机的动态建模和控制设计。\n\n- 独立性假设：双反应理论假设d轴反应和q轴反应是独立的，这在dq0坐标系统中也得到了体现。dq0系统中的电压和电流方程可以分别在d轴和q轴上进行解耦分析。\n\n同步电机的dq0坐标系统和双反应理论都为简化和深入理解电机内部的物理现象提供了工具。dq0坐标系统通过数学变换将电机的时变问题转换为静态问题，而双反应理论则通过物理解释将电机的磁动势分解为两个独立分量。两者在概念和实际应用上具有很强的统一性，结合使用能够更好地分析和控制同步电机。","categories":["电气工程"]},{"title":"将基于Hexo的个人网站提交至Google收录","url":"/2024/07/13/将基于Hexo的个人网站提交至Google收录/","content":"\n## 简介\nHexo博客生成并部署后，无论是部署至第三方平台（如Github Pages），还是部署至私有服务器然后定向至个人域名，都需要人工向搜索引擎提交收录。简单来说这一过程就是把该网站的内容和地址“告诉”搜索引擎，让搜索引擎“认识”你。这样当下次有人在搜索引擎中搜索与你博客有关联的内容时，搜索引擎就能够发现你了。\n\n我们以Google为例，要完成这个过程，通常需要以下步骤：\n\n- 确认博客是否被收录\n- 验证网站所有者\n- 生成并提交站点地图（sitemap）\n- 等待收录\n\n### 一、确认博客是否被收录\n以本网站为例，打开Google，输入`site:akichen891.github.io`\n![搜索结果](/images/sitemap/sousuo.png)\n\n如果Google提示“找不到相符的内容”，则说明你的网站尚未被Google收录。如果网站已经被收录，Google会自动查询和网站有关的内容。\n\n### 二、验证网站所有者\n只有向搜索引擎添加并认证网站，证明自己是该域名的拥有者和管理者后，搜索引擎可以快速批量添加该域名下的所有子站点，而无需一一验证。认证完成后还可以使用Google Console查看并管理网站的访问统计等、\n\n要进行验证，首先前往[Google Console](\nhttps://www.google.com/webmasters/tools/home?hl=zh-CN)。\n\nGoogle Console会要求选择资源类型。\n![选择资源类型](/images/sitemap/tianjia.png)\n\n选择“网址前缀”，在输入框中输入带`http://`或`https://`前缀的完整主域名，然后点击“继续”。\n\nGoogle提供五种验证方法：\n- HTML文件\n- HTML标记\n- Google Analytics\n- Google跟踪代码管理器\n- 域名提供商\n\n这几种方法依次为从简到难。这里只介绍头两种。\n#### HTML文件验证\n这是最简单的一种验证方法，具体步骤Google也写的很清楚。\n\n![HTML文件验证](/images/sitemap/1.png)\n\n点击下载这个`.html`文件，对于Hexo，将该文件放在Hexo根目录下`/source`文件中。然后`hexo g -d`，等待部署。当你能够在浏览器中输入`https://example.blog/googleXXXXXXX.html`并成功跳转时，说明该文件已经添加成功。\n\n回到Google Console，点击验证，正常情况下Google Console很快就会提示验证成功。\n\n如果使用该方法却一直提示验证失败，可以用第二种方法。\n\n#### HTML标记验证\n这种方法和第一种方法非常类似，只不过将验证文件变成了一个html元标记。\n![HTML标记验证](/images/sitemap/2.png)\n\n按照要求，复制元标记。对于Hexo博客，这个所谓的“首页”文件的位置可能有所不同。对于Fluid主题，该文件即为`\\node_modules\\hexo-theme-fluid\\layout\\_partials`目录下的`head.ejs`.\n\n按照Google的要求，在`<head>`中粘贴该元标记。\n![HTML标记验证](/images/sitemap/3.png)\n\n之后，`hexo clean`，然后`hexo g -d`，等待部署。部署完成后在Google Console中点击验证。\n\n## 三、站点地图(Sitemap)\n### 什么是站点地图？\n> 站点地图是网站上的一个文件，可以让 Google 知道应该了解网站上的哪些网页。如果您使用了网站托管服务（比如 Squarespace 或 Wix），这些服务可能会为您管理站点地图，这样的话，您就无需创建自己的站点地图，也无需使用此报告。若想了解站点地图的相关信息，请搜索您的托管服务提供商。如果您的网站规模较小（少于 100 个网页），并且您可以通过追踪首页上的一个或多个链接到达网站上的任何网页，则可能无需使用站点地图或此报告。在这种情况下，只需请求将您的首页编入索引即可（除非您使用的是上述网站托管服务，在这种情况下您无需执行任何操作）。\n\n### 为Hexo生成站点地图\n为启用站点地图，首先要在Hexo根目录中Git Bash来安装插件：\n```\nnpm install hexo-generator-sitemap --save\n```\n在**站点配置文件**（不是主题配置文件！）`_config.yml`中添加：\n```\n# Auto Generate sitemap\nsitemap:\npath: sitemap.xml\n```\n然后`hexo g -d`，若`/public`文件夹下生成了`sitemap.xml`，并且浏览器能够访问`https://example.blog/sitemap.xml`，说明创建成功。\n\n### 向Google提交站点地图\n在Google Console中，左侧栏选择“站点地图”，在“添加新的站点地图”中，输入你的站点地图网址，比如`sitemap.xml`。\n\n![添加站点地图](/images/sitemap/4.png)\n\n提交成功后，Google会在“已提交的站点地图”中显示该sitemap。\n![已提交的站点地图](/images/sitemap/5.png)\n\n索引需要一段时间编制并生效。通常情况下，48小时内Google即可完成收录。","categories":["建站相关"]},{"title":"在Hexo中启用新Markdown解释器并配置Katex","url":"/2024/07/11/在Hexo中启用新Markdown解释器并配置Katex/","content":"## Markdown编译器\n在 Hexo 中，如果默认的 Markdown 编译器无法正确渲染 LaTeX 公式，可以考虑使用支持 LaTeX 公式的 Markdown 编译器插件。常用的包括：\n- hexo-renderer-pandoc\n- hexo-renderer-markdown-it\n- hexo-filter-mathjax\n- hexo-renderer-markdown-it-plus\n\n推荐使用[hexo-renderer-markdown-it-plus](https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus).\n\n## hexo-renderer-markdown-it-plus 安装与配置\n\n- 卸载旧的渲染器：\n\n```\nnpm uninstall hexo-renderer-marked --save\n```\n\n- 安装`hexo-renderer-markdown-it-plus`：\n\n在Hexo根目录中打开Git Bash，然后：\n\n```\nnpm install hexo-renderer-markdown-it-plus --save\n```\n\n- 配置`_config.yml`：\n\n添加以下配置：\n\n```\nmarkdown:\n  render:\n    engine: markdown-it-plus\n    options:\n      html: true\n      xhtmlOut: true\n      breaks: true\n      linkify: true\n      typographer: true\n      quotes: '“”‘’'\n      plugins:\n        - plugin:\n            name: markdown-it-katex\n            options:\n              throwOnError: false\n              errorColor: '#cc0000'\n```\n## 引入KaTeX的CSS\n为了避免公式错位问题，需要确保正确引入 KaTeX 的 CSS 文件。在主题布局文件（通常是 themes/your-theme/layout/_partial/head.ejs）中添加以下代码：\n\n```\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css\">\n```\n\n","categories":["建站相关"]},{"title":"【电机瞬态分析】交流电机方程式（相坐标）","url":"/2024/07/11/【电机瞬态分析】交流电机方程式（相坐标）/","content":"## 凸级同步电机在相坐标系统中的电压方程式\n### 正方向规定中的电动机惯例与发电机惯例\n#### 电动机惯例\n磁链定义式为：\n$$\n\\lambda = N \\phi\n$$\n其中$N$为线圈匝数。\n\n根据惯例，认为一个线圈轴线的正方向极为该线圈产生磁场轴线的正方向。若按照右手螺旋定律来确定电流和电压的正方向，即认为二者符合电动机惯例，则该回路磁链方程式可列写为：\n$$\n\\psi_k = N \\phi = L_kI_k\n$$\n其中$L$为线圈电感，$I$为线圈中的电流。\n\n根据电磁感应定理和楞次定理，当磁链$\\psi$正向增长时，感生电动势必定是阻止磁链增长的，这也就意味着在等效电路中，电压源电位升高的方向与电流正方向相反。等效回路如下图所示。\n\n![图1 电动机惯例下回路压、流正方向](/images/1.1/Fig3.png)\n\n根据基尔霍夫第二定律，此时等效回路的电压方程式为：\n$$\nu_k = p \\psi + i_k r_k\n$$\n其中,$p$为微分算子，即$\\frac{d}{dt}$。$\\psi$为主磁路磁链。\n\n简单来说，电动机惯例下，电压、电流正方向的规定应当反映出：\n- 电流从电源流向电机内部。即定子绕组的电流方向是从电源到电机。\n- 电源向电机传递功率，电机消耗电能转换为机械能输出。\n- 在电动机运行时，电流从定子绕组流入，电枢电流方向与定子磁场方向相同或相近，电动机产生电磁转矩，带动机械负载运行。\n\n#### 发电机惯例\n\n如果保持电流的正方向规定规则不变，仍将产生正向磁链的电流方向规定为电流正方向，仅改变电压正方向的规定，令二者符合发电机惯例，则回路电压正方向与电流正方向的关系改为下图所示：\n\n![图2 发电机惯例下回路压、流正方向](/images/1.1/Fig1.png)\n\n根据基尔霍夫第二定律，回路电压方程式为：\n$$\nu_k = -p \\psi - i_k r_k\n$$\n\n简单来说，发电机惯例下，电压、电流正方向的规定应当反映出：\n- 电流从电机内部流向电源。即定子绕组的电流方向是从电机到电网或负载。\n- 电机向电源传递功率，电机将机械能转换为电能输出。\n- 在发电机运行时，外部机械力驱动转子旋转，定子绕组中的电流流出，定子绕组中的电流方向与定子磁场方向相反或相对，发电机将机械能转换为电能输出到电网或负载。\n\n### 凸级同步电机的电压方程式\n\n分析凸级同步电机运行问题前，为简化分析，作以下假定：\n- 电机铁磁部分的磁路为线性，即不计饱和、剩磁、磁滞和涡流的影响；\n- 电机的定、转子齿槽效应用气踪的卡氏系数表征，即认为定、转子表面光滑，只是气隙增大了一些；\n- 定子三相绕组对称，转子结构分别对直轴和交轴对称。\n\n由于假定磁路为线性，可应用叠加原理，即某绕组交链的总磁链等于各绕组电流分别产生并与之交链的磁链的代数和。实际电机饱和的影响，可根据电机的运行条件，近似地采用选择适当参数值的方法加以修正。\n\n开始分析前应当规定各变量的正方向，如下图所示。\n\n![图3 凸级同步电机内部变量正方向](/images/1.1/Fig2.png)\n\n显然图中a、b、c轴线分别表示定子三相绕组实际轴线的对应正方向，即各相绕组磁链正方向。以及为基础，规定产生正向磁链的电流方向为电流正方向。电压正方向与电流正方向的关系按照电动机惯例确定。\n\n#### 定子绕组\n按照电动机惯例，根据基尔霍夫第二定律，定子三相绕组的电压方程式可分别根据定子绕组回路列写为：\n$$\n\\left.\\begin{array}{l}\nu_{\\mathrm{a}}=p \\psi_{\\mathrm{a}}+r_{s} i_{\\mathrm{a}} \\\\\nu_{\\mathrm{b}}=p \\psi_{\\mathrm{b}}+r_{\\mathrm{s}} i_{\\mathrm{b}} \\\\\nu_{\\mathrm{c}}=p \\psi_{\\mathrm{c}}+r_{\\mathrm{s}} i_{\\mathrm{c}}\n\\end{array}\\right\\}\n$$\n\n#### 励磁绕组\n根据电动机惯例，励磁绕组电压方程为：\n$$\nu_f = -p \\psi_f - i_f r_f\n$$\n\n#### 阻尼绕组\n阻尼绕组广泛应用于电力系统中需要高稳定性的同步电机，如发电机和大型工业电动机。其主要目的是保证电机在启动、停止以及负载变化时的平稳运行，防止系统失步和振荡。\n\n阻尼绕组一般由安装在磁极极靴上的阻尼条和阻尼环组成，阻尼条由阻尼环部分或全部短接，其分布对于直轴或交轴而言通常都是对称的。其结构、安装位置和简单示意图如下所示。\n\n<p align=center>\n<img src=/images/1.1/zuniraozu.png width=50% title=阻尼绕组安装位置>\n</p>\n\n![阻尼绕组简单示意图](/images/1.1/zuniraozu2.png)\n\n可见阻尼条构成的回路是网状的，为了方便起见，通常电流回路的选取均对称于直轴或交轴。上图表示每个磁极有四根阻尼条的阻尼绕组，其中回路1d、2d对称于d轴，回路1q、2q对称于q轴，阻尼条中流过的实际电流即为相应的d轴和q轴回路电流的代数和。\n\n当只考虑气隙磁场（定、转子合成磁场）基波时，若基于以上规则划分阻尼绕组电流回路，则d轴回路和q轴回路在空间中恰好相差90°的电角度，而转子结构显然相对于d轴或q轴又是对称的，因此在d轴回路和q轴回路之间不产生互感，进而可把实际的阻尼绕组看成是两组假想的阻尼绕组，即直轴阻尼绕组和交轴阻尼绕组。\n\n若按照实际情况单独计算每一根阻尼条的电流和磁链关系，可进一步给出每一根阻尼条的实际电流，但是计算量非常大。在不需研究阻尼绕组内部情况的条件下，可将实际的直轴及轴的多个回路的阻尼绕组分别用一个直轴及交轴的等效阻尼统组D和Q来代替,从而大为简化分析计算工作。这样虽会给计算带来一些误差，但在工程计算中是允许的，也是常用的一种方法。简化的直轴及交轴等效阻尼绕组的电压方程式为：\n\n$$\n\\left.\\begin{array}{l}\n0 = p \\psi_D + r_D i_D \\\\\n0 = p \\psi_Q + r_Q i_Q\n\\end{array}\\right\\}\n$$\n\n#### 联立\n联立定子绕组、励磁绕组和阻尼绕组的电压方程式，用矩阵形式表示为：\n$$\nU = p \\Psi + R I \n$$\n式中\n$$\nU = [u_a \\quad u_b \\quad u_c  \\quad u_f \\quad 0 \\quad 0]^{T}\n$$\n\n$$\nI = [i_a \\quad i_b \\quad i_c  \\quad i_f \\quad i_D \\quad i_Q]^{T}\n$$\n\n$$\n\\Psi = [\\psi_a \\quad \\psi_b \\quad \\psi_c  \\quad \\psi_f \\quad \\psi_D \\quad \\psi_Q]^{T}\n$$\n\n$$\nR =\n\\begin{bmatrix}\nr_a & & & & & \\\\\n& r_b & & & & \\\\\n& & r_c & & & \\\\\n& & & r_f & & \\\\\n& & & & r_D & \\\\\n& & & & & r_Q \\\\\n\\end{bmatrix}\n$$\n\n由上式，每个电压方程式均由两项构成：\n- 与绕组交链的主磁链随时间变化而产生的感应电动势$p\\psi$\n- 电流通过绕组电阻产生的压降$ri$\n\n在上述的分析中，无论是定子绕组、励磁绕组还是阻尼绕组，不管其本身是旋转还是停止，其绕组的轴线与构成该绕组的线圈元件之间永远保持相对静止。这类绕组也被称为“静止绕组” 。\n\n## 凸级同步电机在相坐标系统中的磁链方程式\n上文导出的电压方程式中，与每个绕组交链的主磁链是以下两个部分的代数和：\n- 绕组自身通过变化电流产生的磁通（自感）\n- 与该绕组相交链的互感磁链（互感）\n\n这些磁链与电流及电感系数的关系用矩阵形式表示为：\n$$\\begin{bmatrix}\\psi_\\mathrm{a}\\\\\\psi_\\mathrm{b}\\\\\\psi_\\mathrm{c}\\\\\\psi_\\mathrm{f}\\\\\\psi_\\mathrm{D}\\\\\\psi_\\mathrm{Q}\\end{bmatrix}=\\begin{bmatrix}L_\\mathrm{aa}&M_\\mathrm{ab}&M_\\mathrm{ac}&M_\\mathrm{af}&M_\\mathrm{aD}&M_\\mathrm{aQ}\\\\M_\\mathrm{ba}&L_\\mathrm{bb}&M_\\mathrm{bc}&M_\\mathrm{bf}&M_\\mathrm{bD}&M_\\mathrm{bQ}\\\\M_\\mathrm{ca}&M_\\mathrm{cb}&L_\\mathrm{cc}&M_d&M_\\mathrm{cD}&M_\\mathrm{cQ}\\\\M_\\mathrm{fa}&M_\\mathrm{fb}&M_\\mathrm{fc}&L_\\mathrm{f}&M_\\mathrm{fD}&0\\\\M_\\mathrm{Da}&M_\\mathrm{Db}&M_\\mathrm{Dc}&M_\\mathrm{Df}&L_\\mathrm{D}&0\\\\M_\\mathrm{Qa}&M_\\mathrm{Qb}&M_\\mathrm{Qc}&0&0&L_\\mathrm{Q}\\end{bmatrix}\\begin{bmatrix}i_\\mathrm{a}\\\\i_\\mathrm{b}\\\\i_\\mathrm{c}\\\\i_\\mathrm{f}\\\\i_\\mathrm{D}\\\\i_\\mathrm{Q}\\end{bmatrix}$$\n\n*注意*：矩阵中的公式仍可通过$\\lambda = LI$导出，这里的$L$既可以是自感系数也可以是互感系数，其表示意义即为自感磁链或互感磁链。该矩阵中的互感系数也是可逆的。\n\n上式可改写为：\n$$\n\\begin{bmatrix}\\Psi_{abc}\\\\\\Psi_{fDQ}\\end{bmatrix}=\\begin{bmatrix}L_{ss}&L_{sr}\\\\L_{rs} & L_{rr}\\end{bmatrix}\\begin{bmatrix}I_{abc}\\\\I_{fDQ}\\end{bmatrix}\n$$\n\n其中，$L_{ss}、L_{sr}$为定、转子自感系数矩阵，$L_{sr}、L_{rs}$为定、转子互感系数矩阵。\n\n显然，由于交轴等效阻尼绕组Q与直轴等效阻尼绕组D，还有励磁绕组$f$的轴线在空间中相差90°电角度，因此二者互感系数为0。这就是为什么矩阵中$M_{fQ}、M_{DQ}、M_{Qf}、M_{QD}$四者均等于0。\n\n## 凸级同步电机的自感系数与互感系数\n### 磁动势、磁导、自感系数、互感系数\n回顾一下磁导的概念：\n> 磁导（magnetic conductance,$\\mu$）是衡量磁性材料对磁场线的导通能力的物理量，它类似于电导在电路中的作用。磁导越大，表示材料对磁场线的导通能力越强。具体来说，磁导是磁通量与磁动势的比值，反映了材料在磁场中的导磁性能。磁导越大，说明该部分对磁通量的阻碍越小，即导磁能力越强，磁阻（magnetic reluctance）越小。\n\n> 磁路中的磁导定义为：$\\Lambda = \\frac{\\Phi}{F}$，其中$\\Lambda$为磁导，单位安培每韦伯（$A/Wb$），$\\Phi$为磁通量，单位韦伯（$Wb$），$F$为磁动势，单位安培($A$)。\n\n已经自感系数定义为：\n$$\nL = \\frac{N\\Phi}{I}\n$$\n磁导定义为：\n$$\n\\Lambda = \\frac{\\Phi}{F} = \\frac{1}{R_m}\n$$\n\n根据磁路欧姆定律：\n$$\nF = \\Phi R_m = NI\n$$\n式中$F$为作用于该磁路上的磁动势，$\\Phi$为磁路内磁通量，$R_m$为磁阻。\n\n联立以上式子，可导出：\n$$\nL = N^2 \\Lambda\n$$\n\n该方法也可被推广至分析两个线圈间互感系数的关系。\n\n由以上推导可知：\n- 线圈自感系数为线圈内通过单位电流所产生的自感磁链，其大小与该线圈匝数的平方（$N^2$）及自感磁通所经磁路磁导($\\mu$)的乘积成正比\n- 线圈1和线圈2间的互感系数为线圈1内通过单位电流所产生的与线圈2相交链的互感磁链，其大小与两线圈匝数的乘积（$N_1N_2$）成正比，并与互感磁通所经磁路的磁导($\\mu$)成正比\n\n凸级同步电机在转子旋转时，显然部分绕组之间的相对空间位置以及所对应磁路的磁导随转子位置变化而变化，因此相应的自感系数$L$或互感系数$M$将是转子位置角$\\theta$的函数，即时变函数。\n### 定子绕组自感系数\n首先分析定子a相绕组的自感系数$L_{aa}$。当绕组匝数确定时，$L_{aa}$的大小主要取决于对应磁路磁导的大小。当a相绕组中轴线与磁极直轴（d轴）轴线重合，即$\\theta=0$时，a相绕组磁场对应磁路的磁导$\\Lambda$最大，因而在此位置自感系数达到最大值$L_{aad}$；当转子旋转至$\\theta = \\pi /2$电弧度时，a相绕组轴线与转子q轴重合，对应磁路的磁导最小，自感系数为最小值$L_{aaq}$。当转子旋转至$\\theta = \\pi$电弧度时，对应磁路的磁导$\\Lambda$和自感系数$L$又达到最大值。\n\n![a相绕组自感系数](/images/1.1/azigan.png)\n\n显然a相绕组自感系数随$\\theta$的角的变化可以用余弦级数表示为：\n$$\nL_{aa}=L_{aa0}+L_{aa2}cos{2\\theta}+L_{aa4}cos{4\\theta}+...\n$$\n\n可见用该种方式计算绕组自感系数非常复杂。就工程设计而言，一般只需考虑气隙的基波磁动势和气隙的基波磁场。\n\n仅考虑隙的基波磁动势和气隙的基波磁场时，a相绕组自感系数$L_{aa}$由以下二者构成：\n- 不通过气隙的漏磁场所对应的漏电感$L_{aal}$\n- 通过气隙的主合成磁场对应的主电感$L_{aam}$\n\n漏电感$L_{aal}$一般仅和漏磁场的分布情况以及磁路性质有关，与转子空间位置无关，为一常数。主电感$L_{aam}$是关于转子位置角$\\theta$的函数。\n\n令a相绕组有效匝数为$W$，由磁动势定义式，绕组线圈通过单位电流所产生的基波磁动势为$F_{am}=W$，轴线为a轴。将该磁动势分解至磁导$\\Lambda$为恒值的d轴和q轴上，即$F_{amd}=Wcos\\theta$, $F_{amq}=-Wsin\\theta$。令d轴和q轴的磁导分别为$\\Lambda_d$和$\\Lambda_q$，则a相磁动势在d轴和q轴产生的基波磁通大小分别为：\n$$\n\\phi_d=F_{amd}\\Lambda_d=W\\Lambda_d cos\\theta\\\\\n\\phi_q=F_{amq}\\Lambda_q=-W\\Lambda_q sin\\theta\n$$\n\n二者与a相绕组交链的自感磁链等于相绕组的有效匝数$W$与d轴、q轴磁通在a轴上的分量乘积的代数和：\n$$\n\\Psi_{aam}=W(\\phi_d cos\\theta-\\phi_q sin\\theta)=W^2\\Lambda_d cos^2{\\theta}+W^2\\Lambda_q sin^2{\\theta}\n$$\n\na相绕组通过单位电流时产生的主电感的表达式为：\n$$\nL_{aam}=L_{aad}cos^2{\\theta}+L_{aaq}sin^2{\\theta}=\\frac{1}{2}(L_{aad}+L_{aaq})+\\frac{1}{2}(L_{aad}-L_{aaq})cos{2\\theta}\n$$\n\na相绕组的自感系数$L_{aa}$为主电感$L_{aam}$和漏电感$L_{aal}$的代数和，即\n$$\nL_{aa} = L_{aam} + L_{aal} = L_{aa0}+L_{aa2}cos{2\\theta}\n$$\n同理\n$$\nL_{bb} = L_{aa0}+L_{aa2}cos{2(\\theta-\\frac{2\\pi}{3})}\\\\\nL_{cc} = L_{aa0}+L_{aa2}cos{2(\\theta+\\frac{2\\pi}{3})}\n$$\n式中\n$$\nL_{aa0} = L_{aal}+\\frac{1}{2}(L_{aad}+L_{aaq})\\\\\nL_{aa2} = \\frac{1}{2}(L_{aad}-L_{aaq})\n$$\n\n显然，当只考虑空间基波磁场时，凸级同步电机三相定子绕组二点自感系数只有常数项和转子位置角$\\theta$的二次项，其他高次谐波项不存在，给计算带来很大的方便。\n\n*注意*：隐级同步电机和感应电机由于具有均匀分布的气隙，故各项绕组的自感系数与转子位置角$\\theta$无关，为一常数。\n\n### 定子两相绕组间的互感系数\n\n定子三相绕组结构相同，但绕组轴线在空间上互差$2\\pi/3$电弧度。a相绕组通过单位电流所产生的与b相绕组相交链的互感磁链，此为a、b相的互感系数$M_{ab}$。\n\n互感系数也由两部分构成：\n- 与不通过气隙的漏磁通对应的互漏感系数$M_{abl}$\n- 与通过气隙的主磁通对应的互感系数$M_{abm}$\n\n与自感系数类似，互漏感系数$M_{abl}$为一常值，互感系数$M_{abm}$随转子位置变化而变化。\n\n上文已经求出仅考虑空间基波磁场分布下a相绕组单位电流产生的直轴磁通$\\phi_d$和交轴磁通$\\phi_q$。它们与b相绕组相交链的互感磁链，等于相绕组有效匝数$W$与它们在b轴上的磁通量分量乘积的代数和：\n$$\n\\begin{aligned}\n\\psi_{\\mathrm{abm}} & =W\\left[\\phi_{d} \\cos \\left(\\theta-\\frac{2 \\pi}{3}\\right)\\right]-W\\left[\\phi_{q} \\sin \\left(\\theta-\\frac{2 \\pi}{3}\\right)\\right] \\\\\n& =W^{2} \\Lambda_{d} \\cos \\theta \\cos \\left(\\theta-\\frac{2 \\pi}{3}\\right)+W^{2} \\Lambda_{q} \\sin \\theta \\sin \\left(\\theta-\\frac{2 \\pi}{3}\\right)\n\\end{aligned}\n$$\n\n所以a相绕组通过单位电路时产生的通过气隙的磁通与b轴绕组相交链的互感磁链，即a、b相间的互感系数为：\n$$\nM_{abm}=L_{aad}cos\\theta cos(\\theta-\\frac{2\\pi}{3})+L_{aaq}sin\\theta sin(\\theta-\\frac{2\\pi}{3})\\\\\n=-\\frac{L_{aad}+L_{aaq}}{4}+\\frac{L_{aad}-L_{aaq}}{2}cos(2\\theta-\\frac{2\\pi}{3})\n$$\n\na相和b相间的互感系数$M_{ab}$应为互漏电感系数$-M_{abl}$和互电感系数$M_{abm}$之和，即\n$$\nM_{ab}=-M_{abl}-\\frac{L_{aad}+L_{aaq}}{4}+\\frac{L_{aad}-L_{aaq}}{2}cos(2\\theta-\\frac{2\\pi}{3})\\\\\n= - M_{ab0}+L_{aa2}cos{2(\\theta + \\frac{2\\pi}{3})}\n$$\n\n同理\n\n$$\nM_{bc}=- M_{ab0}+L_{aa2}cos{2\\theta}\\\\\nM_{ca}=- M_{ab0}+L_{aa2}cos{2(\\theta-\\frac{2\\pi}{3})}\n$$\n\n式中$M_{ab0} = M_{abl}+\\frac{L_{aad}+L_{aaq}}{4}$\n\n由于三相绕组轴线间夹角互为120°电角度，其值大于90°，因此其互感系数均为负值。定子绕组b相和c相间的互感系数$M_{bc}$随转子位置的变化曲线如下图所示。\n\n![b、c相绕组间的互感系数](/images/1.1/bchugan.png)\n\n可见，$\\theta = 0$时，b相和c相的互感系数的绝对值最小；$\\theta = \\pi /2$时，互感系数绝对值最大，这与自感系数的变化规律是相反的。\n\n### 定子绕组和转子绕组间的互感系数\n#### 定子绕组和励磁绕组间的互感系数\n励磁绕组通过单位电流时所产生的与定子a相绕组交链的互感磁链即为定子绕组与励磁绕组间的互感系数$M_{af}$。互感磁链遵循以下规律：\n\n- 当励磁绕组d轴与a相绕组轴线重合时，互感磁链为最大；\n- 转子d轴旋转90°电角度后，两轴线正交，互感磁链为0；\n- 当转子d轴旋转180°电角度时，互感磁链为负的最大值；\n- 当转子d轴旋转270°电角度时，两轴线正交，互感磁链为0；\n\n因此，一般情况下有：\n$$\nM_{af} = M_{fa} = M_{af0}cos\\theta + M_{af3}cos{3\\theta}+...\n$$\n\n同理可推广至b相和c相：\n$$\nM_{bf} = M_{fb} = M_{af0}cos(\\theta-\\frac{2\\pi}{3}) + M_{af3}cos(\\theta-\\frac{2\\pi}{3})+...\\\\\nM_{cf} = M_{fc} = M_{af0}cos(\\theta+\\frac{2\\pi}{3}) + M_{af3}cos(\\theta+\\frac{2\\pi}{3})+...\n$$\n\n仅考虑基波磁通时，显然互感系数只有基波分量，即：\n$$\nM_{af} = M_{fa} = M_{af0}cos\\theta \\\\\nM_{bf} = M_{fb} = M_{af0}cos(\\theta-\\frac{2\\pi}{3})\\\\\nM_{cf} = M_{fc} = M_{af0}cos(\\theta+\\frac{2\\pi}{3}) \n$$\n式中$M_{af0}$为a轴与励磁绕组d轴重合时所具有的最大互感系数。下标中的“0”表示该互感系数计算时仅考虑了基波分量。\n\n$M_{af}$随$\\theta$的关系如下图所示。\n![定子a相绕组与励磁绕组间的互感系数](/images/1.1/maf.png)\n\n#### 定子绕组与直轴阻尼绕组间的互感系数\n直轴阻尼绕组与励磁绕组轴线重合，故定子绕组与直轴阻尼绕组间的互感系数变化规律可由定子绕组与励磁绕组的互感系数变化规律推广得来（仅考虑基波分量）：\n$$\nM_{aD} = M_{Da} = M_{aD0}cos\\theta \\\\\nM_{bD} = M_{Db} = M_{aD0}cos(\\theta-\\frac{2\\pi}{3})\\\\\nM_{cD} = M_{Dc} = M_{aD0}cos(\\theta+\\frac{2\\pi}{3}) \n$$\n式中$M_{aD0}$为定子绕组a轴与直轴阻尼绕组D轴重合时所具有的最大互感系数。\n\n#### 定子绕组与交轴阻尼绕组间的互感系数\n显然交轴提前直轴90°电角度，以$\\theta + \\frac{\\pi}{2}$代换上小节公式中的$\\theta$角，并考虑直轴和交轴的磁导不同，推导得（仅考虑基波分量）：\n$$\nM_{aQ} = M_{Qa} = M_{aQ0}cos\\theta \\\\\nM_{bQ} = M_{Qb} = M_{aQ0}cos(\\theta-\\frac{2\\pi}{3})\\\\\nM_{cQ} = M_{Qc} = M_{aQ0}cos(\\theta+\\frac{2\\pi}{3}) \n$$\n式中$M_{aQ0}$为定子绕组a轴与交轴阻尼绕组Q轴重合时所具有的最大互感系数。\n\n#### 转子绕组的自感系数\n转子绕组通过单位电流时产生的自感磁链即为转子绕组的自感系数。由于定子铁心为圆环形，转子上各绕组产生的自感磁链大小与转子位置无关，均为恒值。\n\n励磁绕组自感系数由两部分组成，即\n$$\nL_f = L_{fl} + L_{fm}\n$$\n式中 $L_{fl}$对应励磁绕组漏磁通的漏电感系数，$L_{fm}$对应励磁绕组气隙磁通的主电感系数。\n\n直轴阻尼绕组和交轴阻尼绕组的自感系数分别为：\n\n$$\nL_D = L_{Dl} + L_{Dm} \\\\\n\nL_Q = L_{Ql} + L_{Qm}\n$$\n\n式中 $L_{Dl}$和$L_{Ql}$对应于D、Q绕组漏磁通的漏电感系数，$L_{Dm}$和$L_{Qm}$对应于D、Q绕组气隙磁通的主电感系数。\n\n#### 转子绕组间的互感系数\n因转子分别对直轴和交轴对称，且两轴正交，故交轴阻尼绕组Q与直轴阻尼绕组D、励磁绕组$f$间的互感系数为0.绕组D与绕组$f$同在直轴上且式中相对静止，有\n$$\nM_{fD}=M_{Df}=M_{fDl}+M_{fDm}\n$$\n\n### 小结\n以上讨论的凸极同步电机电感系数，从变化规律上看，可分为三种类型：\n- 定子绕组的自感系数和互感系数。其变化周期为$\\pi$。引起这类电感系数变化的原因是转子直轴和交轴的磁导不同,当电机转子为圆柱形时,如隐极同步电机及感应电机，转子直轴和交轴的磁导相同，则电感系数$L_{aad}=L_{aaq}$，定子绕组的自感系数和互感系数均为常数，与转子位置角$\\theta$无关。\n\n- 定子与转子绕组间的互感系数。其变化周期为2$\\pi$。引起这类电感系数变化的原因是定子绕组轴线与转子绕组轴线间有相对运动，导致互感磁链周期性变化。因此，即使在隐极同步电机和感应电机中，这类互感系数仍是转子位置角$\\theta$的函数。\n\n- 转子绕组的自感系数与互感系数。由于定子铁心为圆环形，对转子直轴或交轴而言，磁导是不变的，且转子绕组轴线间无相对运动。上述引起电感系数变化的两个原因均不存在，故转子绕组的自感系数与互感系数均为常数。\n","categories":["电气工程"]}]