[{"title":"RNN：原理、组成与简单实现","url":"/2024/12/12/RNN%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E7%BB%84%E6%88%90%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","content":" 传统RNN\n循环神经网络（RNN）最早可以追溯到1980年代末，当时的研究者希望设计一种能够处理时间序列数据或具有时序依赖关系的数据的神经网络模型。RNN的设计灵感来自生物神经网络的工作原理，它模拟了大脑神经元的反馈机制，通过递归连接来捕捉数据中前后时刻的依赖关系。\n 历史\nRNN的初期发展可追溯到1986年，David Rumelhart 和 Geoffrey Hinton 等人提出了反向传播算法，并在此基础上构建了简单的RNN模型。最初的RNN能够通过训练学习输入数据的时序模式。RNN 跟传统神经网络最大的区别在于每次都会将前一次的输出结果，带到下一次的隐藏层中，一起训练。\n 工作原理\n以一个最简单的语序为例：用户输入了一句“what time is it”，首先需要对这句话进行分词：\n\n将分词结果按顺序输入RNN。首先输入“what”：\n\n按顺序输入剩下的分词，第三步输入“time”。按照RNN的结构，输入&quot;time&quot;时，之前输入的&quot;what&quot;会对RNN的输出产生影响（隐藏层中有一半是黑色的）\n\n以此类推，每一个历史输入都会对未来输出产生影响，直观显示为每一个圆形隐藏层中都包含了之前所有历史输入所指代的颜色。\n\n最后需要输出结果（此处是判断这句话的意图）时，只需要输出最后一层的结果。\n 组成和基本结构\nRNN的核心组成部分是循环结构，它使得网络能够记住之前时刻的信息，并通过这种“记忆”来影响当前时刻的计算。RNN的基本结构可以通过以下几个部分来理解：\n 1. 输入层（Input Layer）\n输入序列数据，通常表示为一个时间步的输入向量 $ x_t $。例如，在自然语言处理任务中，输入可以是一个词向量；在时间序列预测任务中，输入可以是某一时刻的传感器数据。\n 2. 隐层（Hidden Layer）\n隐藏层由多个神经元组成，每个神经元的输出不仅受到当前输入的影响，还受到前一时刻隐层状态的影响。该层的计算过程可以表示为：\nht=f(Wxhxt+Whhht−1+bh)h_t = f(W_{xh}x_t + W_{hh}h_{t-1} + b_h)\nht​=f(Wxh​xt​+Whh​ht−1​+bh​)\n其中，$ h_t $ 是当前时刻的隐层状态，$ x_t $ 是当前输入，$ h_{t-1} $ 是前一时刻的隐层状态，$ W_{xh} $ 和 $W_{hh} $ 是权重矩阵，$ b_h $ 是偏置项，$ f $ 是激活函数（如tanh或ReLU）。\n 3. 输出层（Output Layer）\n输出层用于生成预测结果，通常可以表示为：\nyt=g(Whyht+by)y_t = g(W_{hy}h_t + b_y)\nyt​=g(Why​ht​+by​)\n其中，$ y_t $ 是当前时刻的输出，$ W_{hy} $ 是从隐层到输出的权重矩阵，$ b_y $ 是输出层的偏置项，$ g $ 是输出的激活函数（例如softmax或sigmoid，取决于任务）。\n 应用\nRNN在时间序列数据处理中的优势是能够捕捉时间序列的动态变化和时序依赖关系，因此它特别适用于处理和预测具有时序特征的数据。\nRNN的缺点也很明显，即短期的记忆影响较大，长期的记忆影响较小。若整个时间序列非常长，RNN甚至可能丢失很久之前的历史输入。同时，训练RNN也需要大量的成本，并且很容易带来梯度消失和梯度爆炸问题。这就引出了后来的变种：门控循环单元（GRU）与长短期记忆网络（LSTM）。\n 门控循环单元（GRU）\n参考文献：Cho, K., Van Merriënboer, B., Bahdanau, D., &amp; Bengio, Y. (2014). On the properties of neural machine translation: encoder-decoder approaches. arXiv preprint arXiv:1409.1259.\n 来源\nGRU被用于解决传统RNN的梯度异常问题。这种梯度异常问题在序列问题中是非常常见的，比如：\n\n早期观测值对预测所有未来观测值具有非常重要的意义。 考虑一个极端情况，其中第一个观测值包含一个校验和， 目标是在序列的末尾辨别校验和是否正确。 在这种情况下，第一个词元的影响至关重要。 我们希望有某些机制能够在一个记忆元里存储重要的早期信息。 如果没有这样的机制，我们将不得不给这个观测值指定一个非常大的梯度， 因为它会影响所有后续的观测值。\n一些特征或现象没有相关的观测值。 例如，在对网页内容进行情感分析时， 可能有一些辅助HTML代码与网页传达的情绪无关。 我们希望有一些机制来跳过隐状态表示中的此类词元。\n序列的各个部分之间存在逻辑中断。 例如，书的章节之间可能会有过渡存在， 或者证券的熊市和牛市之间可能会有过渡存在。 在这种情况下，最好有一种方法来重置我们的内部状态表示。\n\n 工作原理\nGRU与传统RNN的关键区别在于，GRU支持隐状态的门控。这意味着模型有专门的机制来确定应该何时更新隐状态， 以及应该何时重置隐状态。 这些机制是可学习的，并且能够解决了上面列出的问题。 例如，如果第一个序列数据变化现象非常重要（如发电机故障中匝间短路的那一瞬间）， 模型将学会在第一次观测之后不更新隐状态。同样，模型也可以学会跳过不相关的临时观测。最后，模型还将学会在需要的时候重置隐状态。\n 重置门（Reset Gate）\n重置门用于决定当前时刻的输入数据在计算当前状态时对之前状态的影响程度。即它决定在计算新的候选隐藏状态时，前一时刻的隐层状态应该有多大的影响。\n公式表示为：\nrt=σ(Wrxt+Urht−1+br)r_t = \\sigma(W_r x_t + U_r h_{t-1} + b_r)\nrt​=σ(Wr​xt​+Ur​ht−1​+br​)\n其中，rtr_trt​ 是重置门的输出，WrW_rWr​ 和 UrU_rUr​ 是权重矩阵，xtx_txt​ 是当前时刻的输入，ht−1h_{t-1}ht−1​ 是前一时刻的隐藏状态，brb_rbr​ 是偏置项，σ\\sigmaσ 是sigmoid激活函数。\n当 rtr_trt​ 接近0时，表示前一时刻的隐藏状态对当前时刻的影响很小，网络将“重置”之前的记忆。\n 更新门（Update Gate）\n更新门控制着当前时刻的隐藏状态应该如何更新，它决定了当前时刻的输出应保留多少来自上一时刻的状态，多少来自当前输入的候选隐藏状态。更新门的值接近1时，意味着当前时刻的隐藏状态保留更多来自前一时刻的记忆；而接近0时，意味着更多的依赖于当前输入。\n公式表示为：\nzt=σ(Wzxt+Uzht−1+bz)z_t = \\sigma(W_z x_t + U_z h_{t-1} + b_z)\nzt​=σ(Wz​xt​+Uz​ht−1​+bz​)\n其中，ztz_tzt​ 是更新门的输出，WzW_zWz​ 和 UzU_zUz​ 是权重矩阵，xtx_txt​ 是当前时刻的输入，ht−1h_{t-1}ht−1​ 是前一时刻的隐藏状态，bzb_zbz​ 是偏置项。\n\n 候选隐藏状态（Candidate Hidden State）\n候选隐藏状态是GRU网络根据当前输入和重置门的作用计算出来的，表示网络在当前时刻希望更新的“记忆”。它是基于当前输入和前一时刻的记忆状态计算的。\n公式表示为：\nh~t=tanh⁡(Whxt+Uh(rt⋅ht−1)+bh)\\tilde{h}_t = \\tanh(W_h x_t + U_h (r_t \\cdot h_{t-1}) + b_h)\nh~t​=tanh(Wh​xt​+Uh​(rt​⋅ht−1​)+bh​)\n其中，h~t\\tilde{h}_th~t​ 是候选隐藏状态，WhW_hWh​ 和 UhU_hUh​ 是权重矩阵，rtr_trt​ 是重置门的输出，⋅\\cdot⋅ 表示按元素相乘（Hadamard积），tanh⁡\\tanhtanh 是tanh激活函数。\n\n 最终隐藏状态（Final Hidden State）\n最终的隐藏状态是当前时刻候选隐藏状态和上一时刻的隐藏状态的加权平均。加权系数由更新门 ztz_tzt​ 控制，表示信息应该更新多少，保留多少。\n公式表示为：\nht=(1−zt)⋅h~t+zt⋅ht−1h_t = (1 - z_t) \\cdot \\tilde{h}_t + z_t \\cdot h_{t-1}\nht​=(1−zt​)⋅h~t​+zt​⋅ht−1​\n其中，hth_tht​ 是当前时刻的最终隐藏状态，h~t\\tilde{h}_th~t​ 是候选隐藏状态，ztz_tzt​ 是更新门，ht−1h_{t-1}ht−1​ 是前一时刻的隐藏状态。\n\n","categories":["深度学习"]},{"title":"STM32 UART在循环DMA模式下接收大量不定字长数据并进行乒乓缓存","url":"/2024/11/25/STM32%20UART%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%9B%BA%E5%AE%9A%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE/","content":"串口(uart)是一种低速的串行异步通信，适用于低速通信场景，通常使用的波特率小于或等于115200bps。\n对于小于或者等于115200bps波特率的，而且数据量不大的通信场景，一般没必要使用DMA，或者说使用DMA并未能充分发挥出DMA的作用。\n对于数量大，或者波特率提高时，必须使用DMA以释放CPU资源，因为高波特率可能带来这样的问题：\n\n\n对于发送，使用循环发送，可能阻塞线程，需要消耗大量CPU资源“搬运”数据，浪费CPU\n\n\n对于发送，使用中断发送，不会阻塞线程，但需浪费大量中断资源，CPU频繁响应中断；以115200bps波特率，1s传输11520字节，大约69us需响应一次中断，如波特率再提高，将消耗更多CPU资源\n\n\n对于接收，如仍采用传统的中断模式接收，同样会因为频繁中断导致消耗大量CPU资源\n因此，高波特率场景下，串口非常有必要使用DMA。\n\n\n 中断轮询模式(IT)\n使用HAL_UARTEx_ReceiveToIdle_IT函数，该函数会持续接收数据，直到缓冲区溢出或触发空闲事件。\n/**  * @brief Receive an amount of data in interrupt mode till either the expected number of data is received or an IDLE event occurs.  * @note   Reception is initiated by this function call. Further progress of reception is achieved thanks  *         to UART interrupts raised by RXNE and IDLE events. Callback is called at end of reception indicating  *         number of received data elements.  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M = 01),  *         the received data is handled as a set of uint16_t. In this case, Size must indicate the number  *         of uint16_t available through pData.  * @param huart UART handle.  * @param pData Pointer to data buffer (uint8_t or uint16_t data elements).  * @param Size  Amount of data elements (uint8_t or uint16_t) to be received.  * @retval HAL status  */HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)&#123;  HAL_StatusTypeDef status;  /* 检查没有正在进行的接收过程 */  if (huart-&gt;RxState == HAL_UART_STATE_READY)  &#123;    if ((pData == NULL) || (Size == 0U))    &#123;      return HAL_ERROR;    &#125;    /* 接收数据，直到空闲事件发生*/    huart-&gt;ReceptionType = HAL_UART_RECEPTION_TOIDLE;    huart-&gt;RxEventType = HAL_UART_RXEVENT_TC;    status =  UART_Start_Receive_IT(huart, pData, Size);    /* 检查接收是否成功开始 */    if (status == HAL_OK)    &#123;      if (huart-&gt;ReceptionType == HAL_UART_RECEPTION_TOIDLE)      &#123;        __HAL_UART_CLEAR_IDLEFLAG(huart);        ATOMIC_SET_BIT(huart-&gt;Instance-&gt;CR1, USART_CR1_IDLEIE);      &#125;      else      &#123;        /* 如果在开始接收时已有错误待处理，则可能已引发中断并导致接收中止 */        status = HAL_ERROR;      &#125;    &#125;    return status;  &#125;  else  &#123;    return HAL_BUSY;  &#125;&#125;\n main.c\n/* USER CODE BEGIN 2 */HAL_UARTEx_ReceiveToIdle_IT(&amp;huart1, (uint8_t *)RxBuffer, RX_BUFFER_SIZE);/* USER CODE END 2 */\n usart.c\n每次接收完数据（指溢出或空闲后）进入该回调，将缓冲区数据传回上位机，然后重新准备下一次接收\n/* USER CODE BEGIN 1 */void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)&#123;  //uint16_t index = Size;  //HAL_UARTEx_ReceiveToIdle_IT(&amp;huart1, (uint8_t *)RxBuffer, RX_BUFFER_SIZE);  HAL_UART_Transmit_IT(&amp;huart1, (uint8_t *)RxBuffer, sizeof(RxBuffer));  HAL_UARTEx_ReceiveToIdle_IT(&amp;huart1, (uint8_t *)RxBuffer, RX_BUFFER_SIZE);&#125;/* USER CODE END 1 */\n DMA模式（少量数据）\nDMA绕过CPU进行数据传输（外设-内存），因此可以节省CPU资源。DMA分为正常（Normal）模式和循环(Circular)模式，一般大规模数据传输时使用循环模式。\n使用 HAL_UARTEx_ReceiveToIdle_DMA函数，仅需在最开始调用一次。当接收完成（达到指定字节数）或触发Idle事件时接收停止。每次接收事件完成后触发HAL_UARTEx_RxEventCallback中断回调。\n应用要求：输入一段文字，若MCU成功接收则回复“Wilco”。\n main.c\n在loop前调用一次以启动接收：\nHAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, (uint8_t *)RxBuffer, RX_BUFFER_SIZE);\n usart.c\n/* USER CODE BEGIN 1 */int count = 0;  //接收次数uint16_t index = 0; //接收数据量uint8_t Wilco[] = &quot;wilco\\n&quot;;  //发送缓冲区/*  @name: UART接收中断回调函数*/void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)&#123;  index = Size;  count++;  HAL_UART_Transmit_IT(&amp;huart1, (uint8_t *)Wilco, sizeof(Wilco));   //中断轮询发送以免DMA冲突/*   for (int i = 0; i &lt; RX_BUFFER_SIZE; i++)   &#123;    RxBuffer[i] = 0;  // 清空接收缓冲区（可选）  &#125; */  HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, (uint8_t *)RxBuffer, RX_BUFFER_SIZE); //重新开启接收&#125;/* USER CODE END 1 */\n\n DMA模式（大量数据）与乒乓缓存\n参考文献：\n一个严谨的STM32串口DMA发送&amp;接收（1.5Mbps波特率）机制\nSTM32 HAL 库实现乒乓缓存加空闲中断的串口 DMA 收发机制，轻松跑上 2M 波特率\nMaJerla(Github)\nDMA在循环模式下工作时，如果在大规模传输数据时仍旧空闲中断（或传输完成中断）会有风险，因为当DMA传输数据完成，CPU介入开始拷贝DMA通道缓冲区数据时，如果此时UART继续有数据进来，DMA继续搬运数据到缓冲区，就有可能将数据覆盖，因为DMA数据搬运是不受CPU控制的，即使你关闭了CPU中断。\n因此严谨的做法需要建立双buffer，CPU和DMA各自使用一块内存交替访问，即乒乓缓存，处理流程为：\n\nDMA先将数据搬运到buf1，搬运完成通知CPU来拷贝buf1数据\nDMA将数据搬运到buf2，与CPU拷贝buf1数据不会冲突\nbuf2数据搬运完成，通知CPU来拷贝buf2数据\nDMA继续开始拷贝新数据\n\nSTM32大多数型号不提供现成的双缓存机制，但提供“半满中断”，即数据搬运到buf大小的一半时，可以产生一个中断信号。基于这个机制，我们可以实现双缓存功能，只需将buf空间开辟大一点即可。\n\nDMA将数据搬运完成buf的前一半时，触发“半满中断”事件，Callback中通知CPU来拷贝buf前半部分数据\nDMA继续将数据搬运到buf的后半部分，与CPU拷贝buf前半部数据不会冲突\nbuf后半部分数据搬运完成，触发“溢满中断”，Callback通知CPU来拷贝buf后半部分数据\nDMA循环拷贝新数据\n\n基于上述描述机制，DMA方式接收串口数据，有三种中断场景需要CPU去将buf数据拷贝到final中，分别是：\n\nDMA通道buf溢满（传输完成）场景，触发满溢中断（HAL_UARTEx_RxEventCallback）\nDMA通道buf半满场景，触发半满中断（HAL_UART_RxHalfCpltCallback）\n串口空闲中断场景，触发空闲中断（UART_FLAG_IDLE）\n\n\n\n也就是说，代码总共需要考虑以下几种情况：\n\n数据量未达到半满，触发空闲中断\n数据量达到半满，未达到满溢，先触发半满中断，后触发空闲中断\n数据量刚好达到满溢，先触发半满中断，后触发满溢中断\n数据量大于缓冲区长度，DMA循环覆盖溢出的字节\n\n对于情况1：在空闲中断中拷贝全部数据\n对于情况2：在半满中断中通知CPU拷贝一半的数据，DMA继续接收剩下的数据，最后在空闲中断中拷贝剩下的数据\n对于情况3：在半满中断中通知CPU拷贝一半的数据，DMA继续接收剩下的数据，最后在满溢中断中拷贝剩下的一半数据\n对于情况4：综合处理\n下面这个代码经过试验不太好使，空闲中断和满溢中断似乎有冲突，导致接收完成后MCU进不去满溢中断。\n/* USER CODE BEGIN USART1_IRQn 0 */if (__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_IDLE))&#123;  __HAL_UART_CLEAR_FLAG(&amp;huart1, UART_FLAG_IDLE);  HAL_UART_DMAStop(&amp;huart1);  uint32_t temp = RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(&amp;hdma_usart1_rx);  //已接收的数据大小  if (temp != 0)  //如果接收到了数据  &#123;    uint8_t txbuffer[] = &quot;rx ok in idle IT\\n&quot;;    HAL_UART_Transmit(&amp;huart1, txbuffer, sizeof(txbuffer), 0xFFFF);    if (rx_half_flag == 0)    //如果半满中断尚未触发过（前半段）    &#123;      for (int i = 0; i &lt; temp; i++)      &#123;        RX_final[final_index] = Rx_buffer[i];        final_index++;        HAL_UART_Receive_DMA(&amp;huart1, Rx_buffer, RX_BUFFER_SIZE - temp);      &#125;    &#125;    else if (rx_half_flag)    //如果半满中断已触发过（后半段）    &#123;      uint32_t temp_size = RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(&amp;hdma_usart1_rx) - RX_BUFFER_SIZE / 2;      for (int i = RX_BUFFER_SIZE / 2; i &lt; RX_BUFFER_SIZE / 2 + temp_size; i++)      &#123;        RX_final[final_index] = Rx_buffer[i];        final_index++;      &#125;      HAL_UART_Receive_DMA(&amp;huart1, Rx_buffer, RX_BUFFER_SIZE/2 - temp_size);    &#125;  &#125;  else if (temp == RX_BUFFER_SIZE)  &#123;    HAL_UART_Receive_DMA(&amp;huart1, Rx_buffer, RX_BUFFER_SIZE);  &#125;&#125;\n    /* USER CODE BEGIN 1 */void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)&#123;  if (huart-&gt;Instance == USART1)  &#123;    rx_half_flag = 1;        uint8_t sendbuffer[] = &quot;rxhalf IT\\n&quot;;    HAL_UART_Transmit(&amp;huart1, (uint8_t *)sendbuffer, sizeof(sendbuffer), 0xFFFF);    for (int i = 0; i &lt; RX_BUFFER_SIZE / 2; i++)    &#123;      RX_final[final_index] = Rx_buffer[i];      final_index++;    &#125;    HAL_UART_Receive_DMA(&amp;huart1, (uint8_t *) Rx_buffer, RX_BUFFER_SIZE / 2);  &#125;&#125;void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)&#123;  if (huart-&gt;Instance == USART1)  &#123;    uint8_t sendbuffer[] = &quot;rx ok\\n&quot;;    HAL_UART_Transmit(&amp;huart1, (uint8_t *)sendbuffer, sizeof(sendbuffer), 0xFFFF);    for (int i = RX_BUFFER_SIZE / 2; i &lt; RX_BUFFER_SIZE; i++)    &#123;      RX_final[final_index] = Rx_buffer[i];      final_index++;    &#125;    rx_half_flag = 0;  &#125;  HAL_UART_Receive_DMA(&amp;huart1, (uint8_t *) Rx_buffer, RX_BUFFER_SIZE);&#125;/* USER CODE END 1 */\n继续调试，删掉除打印测试信息以外的所有功能性代码：\n  /* USER CODE BEGIN USART1_IRQn 0 */  uint32_t temp_size = 0;  if (__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_IDLE))  &#123;    __HAL_UART_CLEAR_IDLEFLAG(&amp;huart1);    HAL_UART_DMAStop(&amp;huart1);    temp_size = RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(&amp;hdma_usart1_rx);  //已接收数据长度    if (temp_size != 0)    &#123;      uint8_t txbuf3[] = &quot;rxidle\\n&quot;;      HAL_UART_Transmit(&amp;huart1, txbuf3, sizeof(txbuf3), 0xFFFF);          &#125;  &#125;  /* USER CODE END USART1_IRQn 0 */  /* USER CODE BEGIN 1 */void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)&#123;  if (huart-&gt;Instance == USART1)  &#123;    uint8_t txbuf1[] = &quot;rxhalf\\n&quot;;    HAL_UART_Transmit(&amp;huart1, txbuf1, sizeof(txbuf1), 0xFFFF);  &#125;&#125;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123;  if (huart-&gt;Instance == USART1)  &#123;    uint8_t txbuf2[] = &quot;rxfull\\n&quot;;    HAL_UART_Transmit(&amp;huart1, txbuf2, sizeof(txbuf2), 0xFFFF);  &#125;&#125;/* USER CODE END 1 */\n正常情况下，接收缓冲区大小为10，当发送“12”（实际为&quot;12\\r\\n“四个字节）时，应只触发空闲中断；发送“123”时，触发半满中断和空闲中断；发送“12345678”时，触发半满中断和满溢中断。但测试发现，发送“12345678”共计十个字节数据，也就是预期接收数据大小等于缓冲区大小时，只能触发一次半满中断，满溢中断无法触发。若禁用空闲中断，发送“12345678”时，半满中断和溢满中断都能触发，初步判断是空闲中断的问题。\n由于DMA配置在循环模式，当接收数据大小等于缓冲区大小时，RX总线仍会处于空闲状态，因为即将到来的新的数据会覆盖掉环形队列的第一项，因此实际上NVIC会先触发空闲中断，而空闲中断中有这一段代码：\ntemp_size = RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(&amp;hdma_usart1_rx);  //已接收数据长度if (temp_size != 0)&#123;  uint8_t txbuf3[] = &quot;rxidle\\n&quot;;  HAL_UART_Transmit(&amp;huart1, txbuf3, sizeof(txbuf3), 0xFFFF);&#125;\n当接收数据大小等于缓冲区大小时，temp_size实际上等于0，导致程序在空闲中断中直接跳过了满溢判断，开始下一次接收。因此需要单独对temp_size == 0这种情况进行处理：\n/* USER CODE BEGIN USART1_IRQn 0 */uint32_t temp_size = 0;if (__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_IDLE))&#123;  temp_size = RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(&amp;hdma_usart1_rx);   idle_flag = 1;  __HAL_UART_CLEAR_IDLEFLAG(&amp;huart1);  if (temp_size == 0) //满溢  &#123;     //满溢回调  &#125;  else if (temp_size != 0)  //非满溢  &#123;    HAL_UART_DMAStop(&amp;huart1);    uint8_t txbuf3[] = &quot;rxidle\\n&quot;;    HAL_UART_Transmit(&amp;huart1, txbuf3, sizeof(txbuf3), 0xFFFF);    HAL_UART_Receive_DMA(&amp;huart1, Rx_buffer, RX_BUFFER_SIZE);  &#125;&#125;/* USER CODE END USART1_IRQn 0 */\n这样，空闲中断在数据填满缓冲区时不会进行任何操作而直接跳出。只有当数据未填满缓冲区时才会进行原先的操作（主要是DMAStop这一步）。到这里，三个中断触发的逻辑总算是理顺了，接下来只需要进行搬运数据的处理就可以了。\nusart.c：\n/* USER CODE BEGIN 1 */void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)&#123;  if (huart-&gt;Instance == USART1)  &#123;    Rx_half_flag = 1; //半满标记    uint8_t txbuf1[] = &quot;rxhalf\\n&quot;;    HAL_UART_Transmit(&amp;huart1, txbuf1, sizeof(txbuf1), 0xFFFF);    Rx_buffer_head = Rx_buffer_tail;    Rx_buffer_tail = RX_BUFFER_SIZE / 2 - 1;    for (int i = Rx_buffer_head; i &lt;= Rx_buffer_tail; i++)    &#123;      Rx_final[Rx_final_index] = Rx_buffer[i];      Rx_final_index++;    &#125;      &#125;&#125;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123;  if (huart-&gt;Instance == USART1)  &#123;    Rx_half_flag = 0; //清除半满标记    uint8_t txbuf2[] = &quot;rxfull\\n&quot;;    HAL_UART_Transmit(&amp;huart1, txbuf2, sizeof(txbuf2), 0xFFFF);    Rx_buffer_head = Rx_buffer_tail + 1;    Rx_buffer_tail = RX_BUFFER_SIZE - 1;    for (int i = Rx_buffer_head; i &lt;= Rx_buffer_tail; i++)    &#123;      Rx_final[Rx_final_index] = Rx_buffer[i];      Rx_final_index++;    &#125;  &#125;&#125;/* USER CODE END 1 */\n中断服务函数：\n/* USER CODE BEGIN USART1_IRQn 0 */  uint32_t temp_size = 0;  if (__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_IDLE))  &#123;    temp_size = RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(&amp;hdma_usart1_rx); //本次接收到的数据大小    //idle_flag = 1;    __HAL_UART_CLEAR_IDLEFLAG(&amp;huart1); //清除Idle标记    if (temp_size == 0) //满溢    &#123;       //满溢回调    &#125;    else if (temp_size != 0)  //非满 ??    &#123;      HAL_UART_DMAStop(&amp;huart1);            uint8_t txbuf3[] = &quot;rxidle\\n&quot;;      HAL_UART_Transmit(&amp;huart1, txbuf3, sizeof(txbuf3), 0xFFFF);      if (Rx_half_flag == 0)  //未半满，前半段触发空闲      &#123;        Rx_buffer_head = Rx_buffer_tail;          Rx_buffer_tail = Rx_buffer_tail + temp_size - 1;         //拷贝数据        for (int i = Rx_buffer_head; i &lt;= Rx_buffer_tail; i++)        &#123;          Rx_final[Rx_final_index] = Rx_buffer[i];          Rx_final_index++;        &#125;        &#125;      else if (Rx_half_flag != 0) //已半满，后半段触发空闲      &#123;        Rx_buffer_head = Rx_buffer_tail + 1;        Rx_buffer_tail = Rx_buffer_tail + temp_size - RX_BUFFER_SIZE / 2;        for (int i = Rx_buffer_head; i &lt;= Rx_buffer_tail; i++)        &#123;          Rx_final[Rx_final_index] = Rx_buffer[i];          Rx_final_index++;        &#125;      &#125;      temp_size = 0;      Rx_buffer_head = 0;      Rx_buffer_tail = 0;      Rx_half_flag = 0;      HAL_UART_Receive_DMA(&amp;huart1,(uint8_t *) Rx_buffer, RX_BUFFER_SIZE);    &#125;  &#125;  /* USER CODE END USART1_IRQn 0 */\n写到这里只处理了单次接收数据大小小于缓冲区长度的情况，可以发现代码量还是挺大的。尤其是这么写代码存在一个比较麻烦的逻辑：当DMA接收的数据量大于缓冲区大小RX_BUFFER_SIZE时，由于DMA工作在循环模式，那么溢出的数据会被DMA重新放到缓冲区的开始部分，从而覆盖原有的数据。要处理这部分数据势必要引入比较复杂的判断机制，还要实时更新队首和队尾的指针，导致整个程序变得比较复杂。\n好在HAL库除了普通的HAL_UART_Receive_DMA()和HAL_UART_RxCpltCallback()外，HAL库还提供了HAL_UARTEx_RxEventCallback回调。\n/**  * @brief  Reception Event Callback (Rx event notification called after use of advanced reception service).  * @param  huart UART handle  * @param  Size  Number of data available in application reception buffer (indicates a position in  *               reception buffer until which, data are available)  * @retval None  */__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)&#123;  /* Prevent unused argument(s) compilation warning */  UNUSED(huart);  UNUSED(Size);  /* NOTE : This function should not be modified, when the callback is needed,            the HAL_UARTEx_RxEventCallback can be implemented in the user file.   */&#125;\n该回调函数会在“advanced reception service”事件发生后触发，这里的所谓高级接收服务就包括之前需要分开判断的DMA半满中断、DMA满溢中断和空闲中断（实际上还有一个错误中断）。这三个中断触发后都会回调HAL_UARTEx_RxEventCallback()函数。在拷贝数据时，无需再单独进行中断回调类型的判断。由于DMA工作不依赖CPU，因此在该函数内要做的就是将缓冲区内的数据拷贝至目标地址。注意这里的形参Size表示缓冲区可用数据长度（从这个位置开始往后的位置都为空），而不是本次回调所接收的数据长度。\n\n再对照一下这张图，红色的部分就是rx_size，其值等于Size（缓冲区总的有效数据长度）减去rx_buf_head（头指针）。当缓冲区溢出并循环存储新数据至缓冲区开头时，Size会同步更新。\n原先的三个中断中的代码可以合到一个中实现：\n/* USER CODE BEGIN 1 */void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)&#123;  uint8_t txbuf[] = &quot;rx done\\n&quot;;  HAL_UART_Transmit_IT(&amp;huart1, txbuf, sizeof(txbuf));  static uint8_t rx_buf_head = 0;  static uint8_t rx_size; //待处理数据长度   rx_size = Size - rx_buf_head;  for (uint16_t i = 0; i &lt; rx_size; i++)  &#123;      RxFinal[final_index++] = RxBuf[(rx_buf_head + i) % RxBufSize]; // 环形缓冲处理      if (final_index &gt;= RxFinalSize) final_index = 0; // 避免 RxFinal 溢出  &#125;  rx_buf_head = rx_buf_head + rx_size;  if (rx_buf_head &gt;= RxBufSize) rx_buf_head = 0;&#125;/* USER CODE END 1 */\n这么写就无需判断到底是哪个中断触发的回调，只需要通过Size和头指针位置计算本次接收到的数据长度，然后按照队列逻辑按次序拷贝即可，因DMA循环而引起的溢出可通过取模操作来处理。\n验证：\n\n\n输入“12345678\\r\\n”:\n\n\n输入“123456789abcdefghijklmn”：\n\n\n先输入&quot;123&quot;，再输入&quot;1234567“，再输入&quot;12&quot;，再输入&quot;123456789”：\n\n\n验证成功。\nGithub项目地址\n","categories":["嵌入式（裸机开发）"]},{"title":"STM32F4 内部温度传感器（Internal Temperature Sensor）","url":"/2024/12/04/STM32%E5%86%85%E9%83%A8%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E9%87%87%E9%9B%86/","content":"STM32F4系列MCU内置有温度传感器，用于采集片内温度，其绑定在ADC1的IN18通道，CubeMX中显示为&quot;Temperature sensor channel&quot;。\n ADC配置\nADC的结构体hadc1配置如下：\nhadc1.Instance = ADC1;hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;hadc1.Init.Resolution = ADC_RESOLUTION_12B;hadc1.Init.ScanConvMode = DISABLE;hadc1.Init.ContinuousConvMode = DISABLE;hadc1.Init.DiscontinuousConvMode = DISABLE;hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;hadc1.Init.NbrOfConversion = 1;hadc1.Init.DMAContinuousRequests = DISABLE;hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;\n\nClockPrescaler：预分频系数，默认为PCLK2 / 4，此例为90 / 4 = 22.5MHz\nResolution：ADC分辨率，可选有 12 位、10 位、8 位和 6 位。分辨率越高，转换数据精度越高，转换时间也越长；反之分辨率越低，转换数据精度越低，转换时间也越\n短。\nScanConvMode：是否使用扫描。多通道启用，单通道禁用。\nContinuousConvMode：启用为自动连续转换，禁用为单次转换。如果设置为单次转换，那么每次转换后都要人工介入才能开启新的转换\nDiscontinuousConvMode：配置是否使用不连续的采样模式。该参数只有在ScanConvMode启用，且ContinuousConvMode关闭的情况下才有效\nExternalTrigConv：外部触发方式选择。若为软件触发则外部触发会关闭。\nExternalTrigConvEdge：外部触发极性选择（禁止触发检测、上升沿检测、下降沿检测或均可）\nDataAlign：数据对齐方式，默认右对齐\nNbrOfConversion：常规转换通道数目，范围1~16\nDMAContinuousRequests：指定DMA请求是否以一次性模式执行（达到转换次数时DMA传输停止）或在连续模式下执行（DMA传输无限制，无论转换数量如何）。在连续模式下执行时，DMA必须配置在循环（Circular）模式，否则DMA传输缓冲区被填满时将发生溢出。\nEOCSelection：指定转换结束后是否产生EOS中断或事件参数\n\nSTM32F429的ADC总转换时间可以通过下式计算：\nTconversion=Tsampling+12×TadcT_{conversion} = T_{sampling} + 12 \\times T_{adc}\nTconversion​=Tsampling​+12×Tadc​\n对于每个ADC通道，采样时间可以通过ADC_SMPR1（用于通道10-18）或ADC_SMPR2（用于通道0-9）寄存器的相应位来配置。例如，通道0的采样时间是通过ADC_SMPR2的SMPR2[2:0]位设置。采样时间也可在adc.c中用代码定义，通常默认为3个ADC周期（SMP=000），可获得最快的采样速度：\n/** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. */ sConfig.Channel = ADC_CHANNEL_TEMPSENSOR; sConfig.Rank = 1; sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;\n12个周期由ADC输入时钟ADC_CLK决定，其由APB2（ 即PCLK2）分频产生，在ClockPrescaler中可修改。\n若采样时间为3个ADC周期，则ADC转换总时间为15个ADC周期，APB2时钟频率为90MHz，PCLK2/4分频后为22.5MHz，那么转换时间就是0.6667us。\n DMA配置\n启用DMA2，ADC1转换后的原始数据存储到16位缓冲区Rx_Buf中。由于ADC分辨率为12位，即采回的数据为12位，正好能够被16位缓冲区存下，便于后续观察和管理内存中的采样值。如果用32位缓冲区，一个区域会存两个采样值，不方便查看和后续的转换。\n 采样\nADC直接采样会存在跳变或抖动，通常需要进行一定的软件滤波，最常见的方法是简单平均法。\n/*    @ brief:ADC采样并取平均    @ param:times:平均次数    @ return:计算得到的平均值*/uint16_t adc1_get_average_value(uint8_t times)&#123;  uint16_t temp_value = 0;  uint8_t t;  /* ADC 配置在单次模式，每次采样都需要手动重启ADC服务 */  HAL_ADC_Start_DMA(&amp;hadc1, (uint32_t *) Rx_Buf, Rx_Buf_Size);  //强制转换Rx_Buf为32位以满足形参限制  /* 采样值取平均 */  for (t = 0; t &lt; times; t++)  &#123;    temp_value = temp_value + HAL_ADC_GetValue(&amp;hadc1);    HAL_Delay(5);  &#125;  /* 返回平均值 */  return temp_value / times;&#125;\n因分辨率为12位，ADC每次采样返回的数值即为12位无符号整型（十进制0~4095）。DMA将会传输每一次的采样值至缓冲区，为了能够更好的查看每一次返回的数值，该例程事先将缓冲区定义成了uint16_t类型，这样缓冲区数组的每一个单元正好能够存下一个采样值。在调用ADC采样函数时，只需要将其声明为uint32_t类型指针，这样DMA会按4个字节（32位）来传输数据。DMA本身并不关心传输的采样值到底是几位的，他只会读取4个字节的数据然后传递至内存，因此，每两个 uint16_t 数据（即 2 个采样值）会合并成一个 uint32_t，在内存中形成连续的数据块。\n以此类推，如果采样值为8位(uint8_t)，那么DMA每次将会打包4个采样值为一个uint32_t数值传回同样定义为uint8_t的缓冲区然后解包，缓冲区中的每个单元都显示一个采样值。\n然后进行温度的读取。温度传感器换算公式为（单位为摄氏度）：\nT=((Vsense−V25)/AvgSlope)+25T = ((V_{sense}-V_{25})/AvgSlope) + 25\nT=((Vsense​−V25​)/AvgSlope)+25\n式中参数取典型值，有V25=0.76V_{25}=0.76V25​=0.76，AvgSlope=2.5mv/℃AvgSlope = 2.5mv/℃AvgSlope=2.5mv/℃\n采集温度：\n/*    @ brief:采集温度    @ param:NULL    @ return:温度值（short）*/double read_temperature(void)&#123;  uint16_t adc_value;  double temperature; //返回温度为双精度值  adc_value = adc1_get_average_value(10);  temperature = ((float)adc_value * 3.3 / 4096.0 - 0.76) / 0.0025 + 25.0;  return temperature;&#125;\nmain.c：\nic_temp = read_temperature();uint8_t txbuf[15];sprintf(txbuf, &quot;temp is: %.2f\\n&quot;, ic_temp); //转换为字符串HAL_UART_Transmit(&amp;huart1, (uint8_t *)txbuf, strlen(txbuf), 0xFFFF);  //串口轮询发送温度值\n 结果\n\n\n","categories":["嵌入式（裸机开发）"]},{"title":"【电机瞬态分析】交流电机在相坐标系统中的状态方程式、电磁转矩和转子运动方程式","url":"/2024/07/24/%E3%80%90%E7%94%B5%E6%9C%BA%E7%9E%AC%E6%80%81%E5%88%86%E6%9E%90%E3%80%91%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E5%9C%A8%E7%9B%B8%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E5%BC%8F%E3%80%81%E7%94%B5%E7%A3%81%E8%BD%AC%E7%9F%A9%E5%92%8C%E8%BD%AC%E5%AD%90%E8%BF%90%E5%8A%A8%E6%96%B9%E7%A8%8B%E5%BC%8F/","content":" 交流电机在相坐标系统中的状态方程式\n将先前得出的磁链方程式代入电压方程式，即可得到交流电机在相坐标系统中的电压方程式：\n[uaubucufuDuQ]=p[LaaMabMacMafMaDMaQMbaLbbMbcMbfMbDMbQMcaMcbLccMcfMcDMcQMfaMfbMfcLfMfD0MDaMDbMDcMDfLD0MQaMQbMQc00LQ][iaibicifiDiQ]+[rarbrcrfrDrQ][iaibicifiDiQ]\\begin{bmatrix}\nu_a \\\\\nu_b \\\\\nu_c \\\\\nu_f \\\\\nu_D \\\\\nu_Q\n\\end{bmatrix}=\np\n\\begin{bmatrix}\nL_{aa} &amp; M_{ab} &amp; M_{ac} &amp; M_{af} &amp; M_{aD} &amp; M_{aQ}\\\\\nM_{ba} &amp; L_{bb} &amp; M_{bc} &amp; M_{bf} &amp; M_{bD} &amp; M_{bQ}\\\\\nM_{ca} &amp; M_{cb} &amp; L_{cc} &amp; M_{cf} &amp; M_{cD} &amp; M_{cQ}\\\\\nM_{fa} &amp; M_{fb} &amp; M_{fc} &amp; L_{f}  &amp; M_{fD} &amp; 0 \\\\\nM_{Da} &amp; M_{Db} &amp; M_{Dc} &amp; M_{Df} &amp; L_{D} &amp; 0  \\\\\nM_{Qa} &amp; M_{Qb} &amp; M_{Qc} &amp; 0 &amp; 0 &amp; L_{Q}\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\ni_a\\\\\ni_b\\\\\ni_c\\\\\ni_f\\\\\ni_D\\\\\ni_Q\n\\end{bmatrix}+\n\\begin{bmatrix}\nr_a &amp; &amp; &amp; &amp; &amp; \\\\\n &amp; r_b &amp; &amp; &amp; &amp; \\\\\n &amp; &amp; r_c &amp; &amp; &amp; \\\\\n &amp; &amp; &amp; r_f &amp; &amp; \\\\\n &amp; &amp; &amp; &amp; r_D &amp; \\\\\n &amp; &amp; &amp; &amp; &amp; r_Q \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\ni_a\\\\\ni_b\\\\\ni_c\\\\\ni_f\\\\\ni_D\\\\\ni_Q\n\\end{bmatrix}\n⎣⎢⎢⎢⎢⎢⎢⎢⎡​ua​ub​uc​uf​uD​uQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=p⎣⎢⎢⎢⎢⎢⎢⎢⎡​Laa​Mba​Mca​Mfa​MDa​MQa​​Mab​Lbb​Mcb​Mfb​MDb​MQb​​Mac​Mbc​Lcc​Mfc​MDc​MQc​​Maf​Mbf​Mcf​Lf​MDf​0​MaD​MbD​McD​MfD​LD​0​MaQ​MbQ​McQ​00LQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎢⎡​ia​ib​ic​if​iD​iQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​+⎣⎢⎢⎢⎢⎢⎢⎢⎡​ra​​rb​​rc​​rf​​rD​​rQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎢⎡​ia​ib​ic​if​iD​iQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n即\nU=p(LI)+RIU=p(LI)+RI\nU=p(LI)+RI\n矩阵中各绕组的自感系数和互感系数在之前的文章中已有推导。\n这是一组表述电机基本电磁关系的时变系数的微分方程组，在已知电感系数和电阻的情况下，利用这组方程就可以求解恒速运转时电机的瞬态和稳态运行问题。由于定子绕组电感系数和定、转子绕组间的互感系数均为位置角θ\\thetaθ的函数，即为时间的函数，因此，在求解上述电压方程式时,不能采用解析方法,而需采用数值解法。\n用数值法求解微分方程组,可将式U=p(LI)+RIU=p(LI)+RIU=p(LI)+RI改写为状态方程组。状态方程是一组一阶的微分方程式。在电机分析中利用状态变量法时，一般可选取各绕组回路中的电流或磁链作为状态变量，这些变量都是不能突变的量。此处的更多内容请参阅《线性控制理论》。\n若选取定子三相电流iai_aia​、ibi_bib​、ici_cic​，及转子绕组电流ifi_fif​、iDi_DiD​、iQi_QiQ​为状态变量，则电压方程式可改写为：\nU=pLI+RI=(pL)I+LpI+RIU=pLI+RI=(pL)I+LpI+RI\nU=pLI+RI=(pL)I+LpI+RI\n式中pLpLpL为电感系数矩阵的一阶导数。\n用状态方程组的标准形式将上式表示如下\nI˙=AI+BU\\dot I = AI + BU\nI˙=AI+BU\n式中\nA=−L−1[D+R]D=pLB=L−1A=-L^{-1}[D+R]\\\\\nD=pL\\\\\nB=L^{-1}\nA=−L−1[D+R]D=pLB=L−1\n当需要考虑电感系数的高次谐波项时，由于定子绕组的自感系数和互感系数，及定、转子绕组间的互感系数均为位置角θ\\thetaθ的无穷三角级数，系数矩阵LLL及其导数DDD的计算工作量很大，用手工计算是不可能的，因而随着计算机技术的发展和广泛应用，可利用计算机求解上述状态方程组的数值解。\n相坐标系统下导出的凸极同步电机的电压方程式，只要作相应的变化，就可适用于隐极同步电机和感应电机。隐极同步电机与凸极同步电机的差别是隐极同步电机的气隙为均匀的。感应电机与隐极同步电机相比，定子结构都是相同的，气隙也是均匀的，只是感应电机转子绕组中没有励磁绕组，感应电机的短路转子绕组相当于同步电机的阻尼绕组。所以从凸极同步电机入手推导的方程式，只需作很小的变动，就可以方便地用于隐极同步电机和感应电机。\n相坐标系统下交流电机的电压方程式的特点是可以考虑空间气隙磁场谐波，适用于计算磁场谐波很强的电机。利用这些方程，可求解恒速运转时的电机瞬态和稳态运行问题。如果再加上电机的电磁转矩和转子运动方程，电机变速运转时的机电过渡过程也可求解。下节将对电机的电磁转矩和转子运动方程加以讨论。\n 交流电机电磁转矩和转子运动方程式\n电磁转矩是电机进行机电能量转换的关键量，也是表征电机性能的重要量。而转子运动方程是根据牛顿定律写出的作用在电机转子上的转矩之间的平衡方程式，当考虑转子转速变化时，除上述电压方程式外，尚需增加转子运动方程式联立求解。下面先讨论交流电机的电磁转矩。\n设交流电机的定子绕组有mmm个回路，以下标&quot;smsmsm&quot;表示定子第mmm个回路；转子绕组有nnn个回路，以下标&quot;rnrnrn&quot;表示定子第nnn个回路。假设磁路为线性，则电机的总磁场能量为\nWm=12(ψs1is1+ψs2is2+...+ψsmism+ψr1ir1+ψr2ir2+...+ψrnirn)W_{m}=\\frac{1}{2}(\\psi_{s1}i_{s1}+\\psi_{s2}i_{s2}+...+\\psi_{sm}i_{sm}+\\psi_{r1}i_{r1}+\\psi_{r2}i_{r2}+...+\\psi_{rn}i_{rn})\nWm​=21​(ψs1​is1​+ψs2​is2​+...+ψsm​ism​+ψr1​ir1​+ψr2​ir2​+...+ψrn​irn​)\n式中各回路的磁链分别为\nψs1=Ls1is1+...+Ms1smism+Ms1r1ir1+...+Ms1rnirn...ψsm=Msms1is1+...+Lsmism+Msmr1ir1+...+Msmrnirnψr1=Mr1s1ir1+...+Mr1smism+Lr1ir1+...+Mr1rnirn...ψrn=Mrns1is1+...+Mrnsmism+Mrnr1ir1+...+Lrnirn\\psi_{s1}=L_{s1}i_{s1}+...+M_{s1sm}i_{sm}+M_{s1r1}i_{r1}+...+M_{s1rn}i_{rn}\\\\\n...\\\\\n\\psi_{sm}=M_{sms1}i_{s1}+...+L_{sm}i_{sm}+M_{smr1}i_{r1}+...+M_{smrn}i_{rn}\\\\\n\\psi_{r1}=M_{r1s1}i_{r1}+...+M_{r1sm}i_{sm}+L_{r1}i_{r1}+...+M_{r1rn}i_{rn}\\\\\n...\\\\\n\\psi_{rn}=M_{rns1}i_{s1}+...+M_{rnsm}i_{sm}+M_{rnr1}i_{r1}+...+L_{rn}i_{rn}\nψs1​=Ls1​is1​+...+Ms1sm​ism​+Ms1r1​ir1​+...+Ms1rn​irn​...ψsm​=Msms1​is1​+...+Lsm​ism​+Msmr1​ir1​+...+Msmrn​irn​ψr1​=Mr1s1​ir1​+...+Mr1sm​ism​+Lr1​ir1​+...+Mr1rn​irn​...ψrn​=Mrns1​is1​+...+Mrnsm​ism​+Mrnr1​ir1​+...+Lrn​irn​\n若改写为矩阵形式，可表示为\nWm=12ITLIW_m=\\frac{1}{2}I^TLI\nWm​=21​ITLI\n根据虚位移定理，当各回路电流保持不变时，有\nf=∂Wm∂g∣i=constf=\\frac{\\partial W_m}{\\partial g}|i=const\nf=∂g∂Wm​​∣i=const\n式中fff为广义力，ggg为广义位移。\n若视广义位移为转子绕组参考轴线领先于定子绕组参考轴线的机械角度γ\\gammaγ，则广义力即为电机的电磁转矩TemT_{em}Tem​，有\nTem=∂Wm∂γ=∂(12ITLI)∂γ=12IT∂L∂γIT_{em}=\\frac{\\partial W_m}{\\partial \\gamma}=\\frac{\\partial (\\frac{1}{2}I^TLI)}{\\partial \\gamma}=\\frac{1}{2}I^T\\frac{\\partial L}{\\partial \\gamma}I\nTem​=∂γ∂Wm​​=∂γ∂(21​ITLI)​=21​IT∂γ∂L​I\n电机极对数为ppp，θ\\thetaθ为转子绕组参考轴线领先于定子绕组参考轴线的电角度，γ\\gammaγ为同步电机d轴领先于a轴的位置角（机械角度），则有\nγ=θ/p\\gamma = \\theta / p\nγ=θ/p\n电磁转矩可继续改写为\nTem=p2IT∂L∂θIT_{em}=\\frac{p}{2}I^T\\frac{\\partial L}{\\partial \\theta}I\nTem​=2p​IT∂θ∂L​I\n在建立转子运动方程时，按电动机惯例选用电磁转矩的正方向，它的正方向与转子正常旋转方向一致。如下图；\n\n其中TemT_{em}Tem​为电动机的电磁转矩，是驱动转矩；TmT_mTm​为负载的机械转矩，是制动转矩；剩余转矩Tem−TmT_{em}-T_mTem​−Tm​则为加速转矩。由此可得转子运动方程为\nJdΩdt=Tem−TmJ\\frac{d\\Omega}{dt}=T_{em}-T_m\nJdtdΩ​=Tem​−Tm​\n式中JJJ为转动惯量(kgm2kgm^2kgm2)，Ω\\OmegaΩ为转子机械角速度，Ω=dγdt\\Omega=\\frac{d\\gamma}{dt}Ω=dtdγ​。\n电机中常用电弧度来表示角度，将上式改写为：\nJ1p×dωdt=J1p×d2θdt2=Tem−TmJ\\frac{1}{p} \\times \\frac{d\\omega}{dt}=J\\frac{1}{p} \\times \\frac{d^2\\theta}{dt^2}=T_{em}-T_m\nJp1​×dtdω​=Jp1​×dt2d2θ​=Tem​−Tm​\n式中ω\\omegaω为转子转速(rad/srad/srad/s)，ω=dθdt\\omega = \\frac{d\\theta}{dt}ω=dtdθ​。\n根据电力拖动内容，若转动部分飞轮转矩为GD2GD^2GD2，工程常用单位为t⋅m2t·m^2t⋅m2，则\nJ=14GD2×103kgm2J=\\frac{1}{4}GD^2 \\times 10^3 kgm^2\nJ=41​GD2×103kgm2\n联立转化为状态方程为\ndωdt=pJ(Tem−Tm)dθdt=ω\\frac{d\\omega}{dt}=\\frac{p}{J}(T_{em}-T_m)\\\\\n\\frac{d\\theta}{dt}=\\omega\ndtdω​=Jp​(Tem​−Tm​)dtdθ​=ω\n当需要求解电机变速问题，即ω\\omegaω不为常系数时，需通过联立求解两个状态方程式（上节和本节）得到各状态变量。此时θ≠ωt+θ0\\theta \\neq \\omega t + \\theta_0θ=ωt+θ0​，需通过上式中的第二式解出θ\\thetaθ。\n 转子运动方程式的标幺值形式\n工程实践中，转子运动方程式常用标幺值形式。转矩的基值一般选为\nTb=SN×1032πn60T_b=\\frac{S_N \\times 10^3}{\\frac{2\\pi n}{60}}\nTb​=602πn​SN​×103​\n式中SNS_NSN​为电机额定视在功率(kVAkVAkVA)，nnn为电机同步转速(r/minr/minr/min)。\n时间基值一般选为τb=12πf\\tau_b=\\frac{1}{2\\pi f}τb​=2πf1​，即为电机转过一个电弧度所需的时间。用转矩基值除原式的两侧，可得\nHd2θdt2=Hdω∗dt∗=(Tem∗−Tm∗)H\\frac{d^2\\theta}{dt^2}=H\\frac{d\\omega^*}{dt^*}=(T_{em}^*-T_m^*)\nHdt2d2θ​=Hdt∗dω∗​=(Tem∗​−Tm∗​)\n其中HHH被称为惯性常数，可导出为\nH=1p×GD2SN2π3f2(n60)=2π3f×GD2SN(n60)2H=\\frac{1}{p} \\times \\frac{GD^2}{S_N}2\\pi^3f^2(\\frac{n}{60})=2\\pi^3f\\times \\frac{GD^2}{S_N}(\\frac{n}{60})^2\nH=p1​×SN​GD2​2π3f2(60n​)=2π3f×SN​GD2​(60n​)2\nHHH和时间标幺值之间有简单的关系：\ndt∗=Hdω∗Tem∗−Tm∗dt^*=\\frac{Hd\\omega^*}{T_{em}^*-T_m^*}\ndt∗=Tem∗​−Tm∗​Hdω∗​\n假设剩余转矩Tem∗−Tm∗=1T_{em}^*-T_m^*=1Tem∗​−Tm∗​=1，电机转速从零上升至同步转速(ω∗=1\\omega^*=1ω∗=1)所需的时间为τ\\tauτ，则\nτ=∫0τdt∗=∫01Hdω∗=H\\tau = \\int_{0}^{\\tau}dt^*=\\int_{0}^{1}Hd\\omega^*=H\nτ=∫0τ​dt∗=∫01​Hdω∗=H\n可见，在原来静止的电机转子上加上标幺值为1的剩余转矩后，转速由零上升至同步转速的时间标幺值等于HHH。\n","categories":["电气工程"]},{"title":"STM32中的I2C通信","url":"/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1/","content":" I2C简介\nI2C是由数据线SDA和时钟线SCL构成的串行总线，用于发送或接收数据。其中SDA用于传输数据。SCL用于同步时钟信号。I2C还有以下特征：\n\n主从架构\n\n主机（Master）：控制通信过程，生成时钟信号并启动通信\n从机（Slave）：响应主机指令，按地址匹配参与通信\n\n\n地址：每个从设备具有唯一的7位或10位地址，用于识别通信目标。主设备在通信开始时发送从设备地址，从设备响应后开始数据传输\n半双工通信： 数据线支持双向通信，但同一时刻只允许数据单向传输\n数据速率：\n\n标准模式（Standard Mode）：最大速率100 kbps\n快速模式（Fast Mode）：最大速率400 kbps\n高速模式（High-Speed Mode）：最大速率3.4 Mbps\n\n\n开漏设计：信号线通常采用开漏驱动，需要外部上拉电阻将信号线拉高到逻辑高电平。因此总线空闲时，SDA和DCL都为高电平。\n多设备连接：可以有多个具备 IIC 通信能力的设备挂载在上面，同时支持多个主机和多个从机，连接到总线的接口数量只由总线电容 400pF 的限制决定。\n\n I2C时序和读写操作\n 时序信号\n\n\n起始信号：主机发出，为电平跳变信号而非恒电平信号。SCL为高电平期间，SDA由高电平跳变至低电平，总线被占用，准备数据传输\n停止信号：主机发出，为电平跳变信号而非恒电平信号。SCL为高电平期间，SDA由低电平跳变至高电平，总线空闲\n应答信号：发送器每发送一个字节，就在时钟脉冲 9 期间释放数据线，由接收器反馈一个应答信号。应答信号为低电平时，规定为有效应答位（ACK 简称应答位），表示接收器已经成功地接收了该字节。应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功\n数据有效性：总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。数据在 SCL 的上升沿到来之前就需准备好。并在下降沿到来之前必须稳定\n数据传输：总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在 SCL 串行时钟的配合下，在 SDA 上逐位地串行传送每一位数据。数据位的传输是边沿触发\n空闲状态：SDA 和 SCL两条信号线同时处于高电平时，规定为总线的空闲状态。此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高\n\n 写操作\n\n\n主机发送起始信号，令总线上的所有从机等待接收数据\n主机发送从机地址+‘0’（写操作）组成的8位数据。从机接收到地址后，比对该地址是否为本机地址。若为本机地址，从机发送应答信号\n主机向从机发送数据\n\n 读操作\n\n\n主机发送起始信号，令总线上的所有从机等待接收数据\n主机发送从机地址+‘1’（读操作）组成的8位数据。从机接收到地址后，比对该地址是否为本机地址。若为本机地址，从机发送应答信号\n从机向主机发送数据\n\n若主机一直返回应答信号，那么从机可以一直发送数据，直到主机发送NACK信号为止。\n 24C02时序\n24C02 是一个 2K bit 的串行 EEPROM 存储器，内部含有 256 个字节。在 24C02 里面还有一个 8 字节的页写缓冲器。该设备的通信方式为 IIC，通过其 SCL 和 SDA 与其他设备通信。\n\nWP为写保护引脚，高电平只读，低电平开放读写功能。24C02的设备地址共8位，包含不可编程部分和可编程部分，可编程部分根据硬件Pin A0、A1、A2决定；设备地址最后一位用于设置是读操作还是写操作。具体为：\n\n本文中A0、A1、A2均接地，故24C02设备读操作地址为0xA1，写操作地址为0xA0。\n 24C02读写操作\n\n主机在 IIC 总线发送第 1 个字节的数据为24C02的设备地址0xA0，用于寻找总线上的24C02，在获得24C02的应答信号之后，继续发送第 2 个字节数据，该字节数据是 24C02 的内存地址，再等到 24C02 的应答信号，主机继续发送第 3 字节数据，这里的数据即是写入在第 2 字节内存地址的数据。主机完成写操作后，可以发出停止信号，终止数据传输。这种写操作每次只能写入1字节数据。\n\n写操作时，24C02可以使用页写时序，其和普通写时序的区别是页写时序只需要告知一次内存地址1，后面的数据会按照写入顺序存入内存地址2、内存地址3等，节省通信时间。\n\n24C02读取数据的过程是一个复合的时序，其中包含写时序和读时序。通常第一个通信过程为写时序，起始信号产生后，主机发送24C02设备地址0xA0，获取从机应答信号后，接着发送需要读取的内存地址；在随后的读时序中，起始信号产生后，主机发送24C02设备地址0xA1, 获取从机应答信号后，从机返回刚刚在写时序中传递的内存地址的数据，以字节为单位传输在总线上，假如主机获取数据后返回的是应答信号，那么从机会一直传输数据，当主机发出的是非应答信号并以停止信号发出为结束，从机结束传输。\n 软件模拟I2C\nHAL库自带的硬件I2C函数比较复杂，多采用软件模拟I2C的方式操作GPIO以获得I2C时序。\n custom_i2c.h（头文件）\n/** **************************************************************************************************** * @file        custom_i2c.h * @author      Aki * @version     V1.0 * @date        2024-12-11 * @brief       软件IIC头文件 **************************************************************************************************** */#ifndef __MYIIC_H#define __MYIIC_H#include &quot;sys.h&quot;/******************************************************************************************//* 引脚定义 */#define IIC_SCL_GPIO_PORT               GPIOH#define IIC_SCL_GPIO_PIN                GPIO_PIN_4#define IIC_SCL_GPIO_CLK_ENABLE()       do&#123; __HAL_RCC_GPIOH_CLK_ENABLE(); &#125;while(0)   /* PH口时钟使能 */#define IIC_SDA_GPIO_PORT               GPIOH#define IIC_SDA_GPIO_PIN                GPIO_PIN_5#define IIC_SDA_GPIO_CLK_ENABLE()       do&#123; __HAL_RCC_GPIOH_CLK_ENABLE(); &#125;while(0)   /* PH口时钟使能 *//******************************************************************************************//* IO操作 */#define IIC_SCL(x)        do&#123; x ? \\                              HAL_GPIO_WritePin(IIC_SCL_GPIO_PORT, IIC_SCL_GPIO_PIN, GPIO_PIN_SET) : \\                              HAL_GPIO_WritePin(IIC_SCL_GPIO_PORT, IIC_SCL_GPIO_PIN, GPIO_PIN_RESET); \\                          &#125;while(0)       /* SCL */#define IIC_SDA(x)        do&#123; x ? \\                              HAL_GPIO_WritePin(IIC_SDA_GPIO_PORT, IIC_SDA_GPIO_PIN, GPIO_PIN_SET) : \\                              HAL_GPIO_WritePin(IIC_SDA_GPIO_PORT, IIC_SDA_GPIO_PIN, GPIO_PIN_RESET); \\                          &#125;while(0)       /* SDA */#define IIC_READ_SDA     HAL_GPIO_ReadPin(IIC_SDA_GPIO_PORT, IIC_SDA_GPIO_PIN)        /* 读取SDA电平 *//******************************************************************************************/void iic_init(void);                        void iic_start(void);                       void iic_stop(void);                      void iic_ack(void);                        void iic_nack(void);                       uint8_t iic_wait_ack(void);                 void iic_send_byte(uint8_t data);          uint8_t iic_read_byte(unsigned char ack);   #endif\n这里宏定义利用了两个小技巧：\n\n三目运算符：x ? … : … 是一个条件（三目）运算符。它的工作原理是：根据 x 的值（x 是一个表达式），判断执行哪一部分代码。如果 x 为 true（非零），执行冒号前的表达式；如果 x 为 false（零），执行冒号后的表达式。\ndo &#123; ... &#125; while(0)：确保宏只执行一次且不会干扰外部代码结构的惯用法。这样做可以确保宏在使用时，代码不会因缺少括号而引发语法错误。\n\n custom_i2c.c\n 初始化\n/**     @brief:IIC初始化    @param:NULL    @return:NULL**/void iic_init(void)&#123;    GPIO_InitTypeDef gpio_init_struct;    IIC_SCL_GPIO_CLK_ENABLE();  /* SCL引脚时钟使能 */    IIC_SDA_GPIO_CLK_ENABLE();  /* SDA引脚时钟使能 */    /* SCL */    gpio_init_struct.Pin = IIC_SCL_GPIO_PIN;    gpio_init_struct.Mode = GPIO_MODE_OUTPUT_PP;    /* 推挽输出 */    gpio_init_struct.Pull = GPIO_PULLUP;            /* 上拉 */    gpio_init_struct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;    HAL_GPIO_Init(IIC_SCL_GPIO_PORT, &amp;gpio_init_struct);    /* SDA */    gpio_init_struct.Pin = IIC_SDA_GPIO_PIN;    gpio_init_struct.Mode = GPIO_MODE_OUTPUT_OD;    /* 开漏输出 */    HAL_GPIO_Init(IIC_SDA_GPIO_PORT, &amp;gpio_init_struct);    iic_stop();     /* 停止总线上所有设备 */&#125;\n这里SDA线使用开漏输出，这意味着当SDA引脚输出低电平时，设备直接将线拉低（输出低电平）；而当设备输出高电平时，它并不直接将线拉高，而是将SDA引脚设置为高阻态（即不驱动该引脚。当一个设备希望发送数据时，如果它需要输出0（低电平），它会直接将SDA引脚拉低。当它需要发送1（高电平），它不会直接将SDA引脚拉高，而是让SDA引脚处于高阻态，让总线上的其他设备（如果有）通过拉高SDA线来实现高电平。这么做可以有效避免连接多个从机时发生电平冲突。STM32F429使用开漏模式时，必须外界上拉电阻。\n 延时\n/**     @brief:IIC延时函数    @param:NULL    @return:NULL**/static void iic_delay(void)&#123;    delay_us(2);    /* 读写速度在250Khz以内 */&#125;\n为获得稳定的读写结果，需限制读写速度，此处通过延时2us的形式实现。\n 起始信号与停止信号\n/**     @brief:IIC起始信号    @param:NULL    @return:NULL**/void iic_start(void)&#123;    IIC_SDA(1);    IIC_SCL(1);    iic_delay();    IIC_SDA(0);   /* START信号 */    iic_delay();    IIC_SCL(0);   /* 钳住总线，准备发送或接收数据（SCL只有低电平期间允许改变SDA状态） */    iic_delay();&#125;/**     @brief:IIC停止信号    @param:NULL    @return:NULL**/void iic_stop(void)&#123;    IIC_SDA(0);     /* STOP信号 */    iic_delay();    IIC_SCL(1);    iic_delay();    IIC_SDA(1);     /* 总线结束信号 */    iic_delay();&#125;\n\n根据IIC时序图，起始信号和停止信号分别为：\n\nSTART：SCL高电平，SDA从1跳变至0\nSTOP：SCL高电平，SDA从0跳变至1\n\n上面的两个函数实现的就是这个功能，同时加入了延时来保证能得到稳定的电平。需要注意，停止信号发出时，SCL需要在SDA电平开始跳变前就保持高电平。\n 发送字节\n/**     @brief:IIC发送一个字节    @param:data：要发送的数据    @return:NULL**/void iic_send_byte(uint8_t data)&#123;    uint8_t t;    for (t = 0; t &lt; 8; t++)    &#123;        IIC_SDA((data &amp; 0x80) &gt;&gt; 7);    /* 提取高位 */        iic_delay();        IIC_SCL(1);     /* 拉高SCL并维持高电平，开始发送 */        iic_delay();        IIC_SCL(0);     /* 发送结束，拉低SCL，准备下一位数据 */        data &lt;&lt;= 1;     /* 左移1位，循环发送 */    &#125;    IIC_SDA(1);     /* 发送完成，释放SDA线 */&#125;\n\n发送字节时，由于一个时钟周期内I2C只能发送一位(bit)数据，因此发送需要循环8次，模拟8个时钟信号，才能把形参的8位数据都发送出去。也就是我们需要提取出形参的每一位并发送。这里使用了(data &amp; 0x80) &gt;&gt; 7的方式。(data &amp; 0x80)是将形参与0x80，也就是10000000进行与运算，然后右移7位，提取出形参的最高位。如果最高位是1，那么SDA就拉高；反之SDA则拉低。每个周期完成后，data左移1位，将原先是次高位的数移到最高位，重复这个过程8次。全部发送完成后，释放SDA线。\n 读取字节\n/**     @brief:IIC读取一个字节    @param:ack: ack=1时，发送ack; ack=0时，发送nack    @return:接收到的数据**/uint8_t iic_read_byte(uint8_t ack)&#123;    uint8_t i, receive = 0x00;    /* 1个字节共8位，单次接收1位，循环8次 */    for (i = 0; i &lt; 8; i++)    &#123;        receive &lt;&lt;= 1;      /* 输出时高位先输出，因此接收时先收到的数据是高位，要左移 */        IIC_SCL(1);         /* 拉高SCL，SDA准备接收 */        iic_delay();        if (IIC_READ_SDA)   /* 如果SDA为高电平 */        &#123;            receive++;      /* 第0位（低位）置1 */        &#125;        IIC_SCL(0);         /* 接收结束，拉低SCL */        iic_delay();    &#125;    if (!ack)    &#123;        iic_nack();         /* 发送nACK信号 */    &#125;    else    &#123;        iic_ack();          /* 发送ACK信号 */    &#125;    return receive;&#125;\n在时序方面，I2C读取字节和写入字节是一致的。\n 应答信号（ACK）\n/**     @brief:等待应答信号    @param:NULL    @return:1=失败；0=成功**/uint8_t iic_wait_ack(void)&#123;    uint8_t waittime = 0;    uint8_t rack = 0;    IIC_SDA(1);     /* 主机释放SDA（外部器件此时可拉低SDA电平） */    iic_delay();    IIC_SCL(1);     /* 拉高SCL，从机此时可返回ACK */    iic_delay();    while (IIC_READ_SDA)    /* 等待应答 */    &#123;        waittime++;        if (waittime &gt; 250)        &#123;            iic_stop();            rack = 1;            break;        &#125;    &#125;    IIC_SCL(0);     /* SCL=0，结束ACK检查 */    iic_delay();    return rack;&#125;\n等待应答信号一般用在写时序中，在iic_send_byte后调用。当读取到SDA为低电平时，表示ACK信号；SDA为高电平则为NACK信号。若等待超时，则主机会直接发出停止信号。若正常接收到ACK信号，主机拉低SCL线，返回flag。这一段内容对应总线时序图中的红圈3，也就是脉冲9。\n/**     @brief:产生ACK应答    @param:NULL    @return:NULL    @note：ACK应答时，SDA拉低，SCL=0-&gt;1-&gt;0**/void iic_ack(void)&#123;    IIC_SDA(0);         iic_delay();    IIC_SCL(1);         iic_delay();    IIC_SCL(0);         iic_delay();    IIC_SDA(1);         iic_delay();&#125;/**     @brief:不产生ACK应答（NACK）    @param:NULL    @return:NULL    @note：NACK应答时，SDA拉高，SCL=0-&gt;1-&gt;0**/void iic_nack(void)&#123;    IIC_SDA(1);    iic_delay();    IIC_SCL(1);    iic_delay();    IIC_SCL(0);    iic_delay();&#125;\n以上两个函数用于主机作为接收端时，在接收完数据后向从机返回ACK或NACK信号。二者对应的也是线时序图中的红圈3，也就是脉冲9。\n","categories":["嵌入式（裸机开发）"]},{"title":"【电机瞬态分析】交流电机方程式（dq0坐标系）","url":"/2024/07/14/%E3%80%90%E7%94%B5%E6%9C%BA%E7%9E%AC%E6%80%81%E5%88%86%E6%9E%90%E3%80%91%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E6%96%B9%E7%A8%8B%E5%BC%8F%EF%BC%88dq0%E5%9D%90%E6%A0%87%E7%B3%BB%EF%BC%89/","content":" 概述\n上一篇文章对三相凸级同步电机在a、b、c坐标系下的电压方程式和磁链方程式，并且给出了定子和转子绕组之间的电感系数。在需要考虑气隙谐波磁场时，定子绕组的自感系数、互感系数，以及定子绕组和转子绕组之间的互感系数均是关于转子位置角θ\\thetaθ的无穷级数。虽然工程中可以忽略高次项进行近似计算，但计算过程仍是非常复杂的。\n在仅考虑气隙磁场基波成分的前提下，通过Park变换，用dq0坐标系下的新变量替代原abc相坐标系下的变量，可使定子绕组的自感系数和互感系数又时变系数变为常系数。\n 交流电机在dq0坐标系中的电压方程式和磁链方程式\n 相坐标系至dq0坐标系的变换\n由线性代数知识，当满秩线性变换时，新变量与原变量间具有单值的对应关系。此时，变换矩阵C（中间量）应为满秩。\n满秩矩阵的充分必要条件是其行列式的值不为0。\n在此变换下，线性变换和线性反变换式可写为：\nY=CXX=C−1YY = CX \\\\\nX = C^{-1}Y\nY=CXX=C−1Y\n其中C−1C^{-1}C−1是CCC的逆矩阵。\n电机工程中最常用的坐标系即为dq0坐标系，即将原来静止的定子绕组a、b、c绕组变换至与转子同角速度旋转的d、q轴线及独立的零轴线代替，如下图所示。\n\n显然在使用dq0坐标系时，由于d、q轴随着转子旋转而与转子轴线呈相对静止，电枢绕组的自感和互感系数变为常数。零轴绕组在电磁方面为独立轴，与其他绕组无耦合关系。\n以电枢电流为例，变换后的新变量idi_did​，iqi_qiq​，i0i_0i0​与原变量iai_aia​，ibi_bib​，ici_cic​关系为：\n[idiqi0]=23[cos⁡θcos⁡(θ−2π3)cos⁡(θ+2π3)−sin⁡θ−sin⁡(θ−2π3)−sin⁡(θ+2π3)121212][iaibic]\\left[\\begin{array}{l}\ni_{d} \\\\\ni_{q} \\\\\ni_{0}\n\\end{array}\\right]=\\frac{2}{3}\\left[\\begin{array}{ccc}\n\\cos \\theta &amp; \\cos \\left(\\theta-\\frac{2 \\pi}{3}\\right) &amp; \\cos \\left(\\theta+\\frac{2 \\pi}{3}\\right) \\\\\n-\\sin \\theta &amp; -\\sin \\left(\\theta-\\frac{2 \\pi}{3}\\right) &amp; -\\sin \\left(\\theta+\\frac{2 \\pi}{3}\\right) \\\\\n\\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{1}{2}\n\\end{array}\\right]\\left[\\begin{array}{l}\ni_{a} \\\\\ni_{b} \\\\\ni_{c}\n\\end{array}\\right]\n⎣⎢⎡​id​iq​i0​​⎦⎥⎤​=32​⎣⎢⎡​cosθ−sinθ21​​cos(θ−32π​)−sin(θ−32π​)21​​cos(θ+32π​)−sin(θ+32π​)21​​⎦⎥⎤​⎣⎢⎡​ia​ib​ic​​⎦⎥⎤​\n式中第三个新变量i0i_0i0​与iai_aia​，ibi_bib​，ici_cic​的关系为\ni0=13(ia+ib+ic)i_0 = \\frac{1}{3}(i_a+i_b+i_c)\ni0​=31​(ia​+ib​+ic​)\ni0i_0i0​被称为定子绕组电流的零轴分量，为瞬时值。\n显然i0i_0i0​与电机各项绕组连接方式有关：\n\n有中线连接时，i0i_0i0​实际为电机中线电流的1/3\n无中线连接时。i0i_0i0​为零\n\n后续分析同步电机及其系统时，若将电流分量变换至dq0坐标系，且原相坐标系中的电压、磁链等量也要同步变换至dq0坐标系，其变换矩阵CCC与电流变量的变换矩阵相同。\n 磁链方程式（dq0坐标系）\n将相坐标系中的磁链方程式转化为dq0坐标系中的磁链方程式，其过程如下：\n[Ψdq0ΨfDQ]=[C00E][ΨabcΨfDQ]=[C00E][LssLsrLrsLrr][IabcIfDQ]\\left[\\begin{array}{l}\n\\Psi_{dq0} \\\\\n\\Psi_{fDQ} \n\\end{array}\\right]=\\left[\\begin{array}{cc}\nC &amp; 0 \\\\\n0 &amp; E \n\\end{array}\\right]\\left[\\begin{array}{l}\n\\Psi_{abc} \\\\\n\\Psi_{fDQ} \n\\end{array}\\right]=\\left[\\begin{array}{cc}\nC &amp; 0 \\\\\n0 &amp; E \n\\end{array}\\right]\\left[\\begin{array}{cc}\nL_{ss} &amp; L_{sr} \\\\\nL_{rs} &amp; L_{rr}\n\\end{array}\\right]\\left[\\begin{array}{l}\nI_{abc} \\\\\nI_{fDQ}\n\\end{array}\\right]\n[Ψdq0​ΨfDQ​​]=[C0​0E​][Ψabc​ΨfDQ​​]=[C0​0E​][Lss​Lrs​​Lsr​Lrr​​][Iabc​IfDQ​​]\n式中，Ψdq0\\Psi_{dq0}Ψdq0​为电机电枢d、q、0三轴绕组的磁链矩阵表达式，Ψdq0=[ϕdϕqϕ0]T\\Psi_{dq0}=[\\phi_d \\quad \\phi_q \\quad \\phi_0]^{T}Ψdq0​=[ϕd​ϕq​ϕ0​]T；ΨfDQ\\Psi_{fDQ}ΨfDQ​为电机电枢f、D、Q三轴绕组的磁链矩阵表达式，ΨfDQ=[ϕfϕDϕQ]T\\Psi_{fDQ}=[\\phi_f \\quad \\phi_D \\quad \\phi_Q]^{T}ΨfDQ​=[ϕf​ϕD​ϕQ​]T，EEE为单位矩阵。\n联立上述各式，可得计算后的结果为：\n[ψdψqψ0ψfψDψQ]=[Ld00Maf0MaD000Lq000MaQ000L000032Maf000LfMfD032MaD000MDfLD0032MaQ0000LQ][idiqi0ifiDiQ]\\left[\\begin{array}{l}\n\\psi_{d} \\\\\n\\psi_{q} \\\\\n\\psi_{0} \\\\\n\\psi_{f} \\\\\n\\psi_{D} \\\\\n\\psi_{Q}\n\\end{array}\\right]=\\left[\\begin{array}{cccccc}\nL_d &amp; 0 &amp; 0 &amp; M_{af0} &amp; M_{aD0} &amp; 0\\\\\n0 &amp; L_q &amp; 0 &amp; 0 &amp; 0 &amp; M_{aQ0}\\\\\n0 &amp; 0 &amp; L_0 &amp; 0 &amp; 0 &amp; 0\\\\\n\\frac{3}{2}M_{af0} &amp; 0 &amp; 0 &amp; L_f &amp; M_{fD} &amp; 0\\\\\n\\frac{3}{2}M_{aD0} &amp; 0 &amp; 0 &amp; M_{Df} &amp; L_{D} &amp; 0\\\\\n0 &amp; \\frac{3}{2}M_{aQ0} &amp; 0 &amp; 0 &amp; 0 &amp; L_Q\n\\end{array}\\right]\\left[\\begin{array}{l}\ni_{d} \\\\\ni_{q} \\\\\ni_{0} \\\\\ni_{f} \\\\\ni_{D} \\\\\ni_{Q}\n\\end{array}\\right]\n⎣⎢⎢⎢⎢⎢⎢⎢⎡​ψd​ψq​ψ0​ψf​ψD​ψQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎢⎡​Ld​0023​Maf0​23​MaD0​0​0Lq​00023​MaQ0​​00L0​000​Maf0​00Lf​MDf​0​MaD0​00MfD​LD​0​0MaQ0​000LQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎢⎡​id​iq​i0​if​iD​iQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n其中\nLd=Laal+Mabl+32Lmad=Lleak+LadLq=Laal+Mabl+32Lmaq=Lleak+LaqL0=Laal−2MablL_d = L_{aal}+M_{abl}+\\frac{3}{2}L_{mad}=L_{leak} + L_{ad} \\\\\nL_q = L_{aal}+M_{abl}+\\frac{3}{2}L_{maq}=L_{leak} + L_{aq} \\\\\nL_0 = L_{aal} - 2M_{abl}\nLd​=Laal​+Mabl​+23​Lmad​=Lleak​+Lad​Lq​=Laal​+Mabl​+23​Lmaq​=Lleak​+Laq​L0​=Laal​−2Mabl​\n式中，LaalL_{aal}Laal​为电枢a相绕组自漏感系数(lll意为leakleakleak)，MablM_{abl}Mabl​为电枢a相和b相绕组之间的互漏感系数，LaadL_{aad}Laad​为电枢a相绕组自感系数在d轴上的分量，LaaqL_{aaq}Laaq​为电枢a相绕组自感系数在q轴上的分量。Maf0M_{af0}Maf0​为定子a轴与励磁绕组d轴重合时所具有的最大互感系数，MaD0M_{aD0}MaD0​为定子a轴与阻尼绕组D轴重合时所具有的最大互感系数，MaQ0M_{aQ0}MaQ0​为定子a轴与阻尼绕组Q轴重合时所具有的最大互感系数，下标中的“0”表示该互感系数计算时仅考虑了基波分量。\n由上式可看出：\n\n\nLdL_dLd​和LqL_qLq​分别是假想的电枢d轴绕组和电枢q轴绕组的自感系数。它包括不通过气隙的漏磁链所对应的自漏感系数Lleak=Laal+MablL_{leak}=L_{aal}+M_{abl}Lleak​=Laal​+Mabl​以及通过气隙的主磁场所对应的电感系数Lad=32LaadL_{ad}=\\frac{3}{2}L_{aad}Lad​=23​Laad​以及Laq=32LaaqL_{aq}=\\frac{3}{2}L_{aaq}Laq​=23​Laaq​。\n\n\nL0L_0L0​是变换后假想的电枢零轴绕组的自感系数，其仅由漏感系数组成。\n\n\n电枢绕组从abc相绕组轴线转换为与转子同速旋转的d、q轴以及独立的零轴后，电枢绕组的自感系数及互感系数均由时变系数变为与θ\\thetaθ角无关的常数。\n\n\n坐标变换使具有相互电磁耦合的abc相绕组变为没有耦合关系的假想的电枢d轴、q轴绕组，达到了解耦的目的。对于电机控制系统，该操作可获得更良好的控制性能。\n\n\n 电压方程式（dq0坐标系）\ndq0坐标系中的电压方程式可采用同样的方式从相坐标系统下的电压方程式转换而来，即\n[Udq0UfDQ]=[C00E][UabcUfDQ]=[C00E][pΨabcpΨfDQ]+[C00E][Rabc00RfDQ][IabcIfDQ]\\left[\\begin{array}{l}\nU_{dq0} \\\\\nU_{fDQ} \n\\end{array}\\right]=\\left[\\begin{array}{cc}\nC &amp; 0 \\\\\n0 &amp; E \n\\end{array}\\right]\\left[\\begin{array}{l}\nU_{abc} \\\\\nU_{fDQ} \n\\end{array}\\right]=\\left[\\begin{array}{cc}\nC &amp; 0 \\\\\n0 &amp; E \n\\end{array}\\right]\\left[\\begin{array}{l}\np\\Psi_{abc} \\\\\np\\Psi_{fDQ}\n\\end{array}\\right]+\\left[\\begin{array}{cc}\nC &amp; 0 \\\\\n0 &amp; E \n\\end{array}\\right]\\left[\\begin{array}{cc}\nR_{abc} &amp; 0 \\\\\n0 &amp; R_{fDQ} \n\\end{array}\\right]\\left[\\begin{array}{l}\nI_{abc} \\\\\nI_{fDQ} \n\\end{array}\\right]\n[Udq0​UfDQ​​]=[C0​0E​][Uabc​UfDQ​​]=[C0​0E​][pΨabc​pΨfDQ​​]+[C0​0E​][Rabc​0​0RfDQ​​][Iabc​IfDQ​​]\n式中，Udq0U_{dq0}Udq0​为电枢d、q、0绕组轴端的电压矩阵，Udq0=[uduqu0]TU_{dq0}=[u_d \\quad u_q \\quad u_0]^{T}Udq0​=[ud​uq​u0​]T。\n上式中等式右侧的第一项：\n[C00E][pΨabcpΨfDQ]=[C(pΨabc)pΨfDQ]\\left[\\begin{array}{cc}\nC &amp; 0 \\\\\n0 &amp; E \n\\end{array}\\right]\\left[\\begin{array}{l}\np\\Psi_{abc} \\\\\np\\Psi_{fDQ}\n\\end{array}\\right]=\\left[\\begin{array}{cc}\nC &amp; (p \\quad \\Psi_{abc}) \\\\\np &amp; \\Psi_{fDQ}\n\\end{array}\\right]\n[C0​0E​][pΨabc​pΨfDQ​​]=[Cp​(pΨabc​)ΨfDQ​​]\n根据磁链的Park变换：\nΨdq0=CΨabc\\Psi_{dq0} = C \\Psi_{abc}\nΨdq0​=CΨabc​\n故有\npΨdq0=(pC)Ψabc+C(pΨabc)p \\Psi_{dq0} = (pC)\\Psi_{abc}+C(p \\quad \\Psi_{abc})\npΨdq0​=(pC)Ψabc​+C(pΨabc​)\n可得\nC(pΨabc)=pΨdq0−(pC)ΨabcC(p \\quad \\Psi_{abc}) = p\\Psi_{dq0} - (pC)\\Psi_{abc}\nC(pΨabc​)=pΨdq0​−(pC)Ψabc​\n可以证明其中\n−(pC)Ψabc=−pCC−1Ψdq0=ω[0−10100000][ϕdϕqϕ0]=[−ωψqωψd0]-(pC)\\Psi_{abc} = -{pC}C^{-1}\\Psi_{dq0}=\\omega \\left[\\begin{array}{ccc}\n0 &amp; -1 &amp; 0 \\\\\n1 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp;0\n\\end{array}\\right]\\left[\\begin{array}{l}\n\\phi_d\\\\\n\\phi_q\\\\\n\\phi_0\n\\end{array}\\right]=\\left[\\begin{array}{c}\n-\\omega\\psi_q\\\\\n\\omega\\psi_d\\\\\n0\n\\end{array}\\right]\n−(pC)Ψabc​=−pCC−1Ψdq0​=ω⎣⎢⎡​010​−100​000​⎦⎥⎤​⎣⎢⎡​ϕd​ϕq​ϕ0​​⎦⎥⎤​=⎣⎢⎡​−ωψq​ωψd​0​⎦⎥⎤​\n式中ω\\omegaω为转子的瞬时转速，ω=pθ\\omega = p \\thetaω=pθ。\n转换式等式右侧的第二项（即电阻压降）可以写成：\n[C00E][Rabc00RfDQ][IabcIfDQ]=[C00E][Rabc00RfDQ][C−100E][Idq0IfDQ]=[Rabc00RfDQ][Idq0IfDQ]\\left[\\begin{array}{cc}\nC &amp; 0 \\\\\n0 &amp; E \n\\end{array}\\right]\\left[\\begin{array}{cc}\nR_{abc} &amp; 0 \\\\\n0 &amp; R_{fDQ} \n\\end{array}\\right]\\left[\\begin{array}{c}\nI_{abc} \\\\\nI_{fDQ} \n\\end{array}\\right]=\n\\left[\\begin{array}{cc}\nC &amp; 0 \\\\\n0 &amp; E \n\\end{array}\\right]\\left[\\begin{array}{cc}\nR_{abc} &amp; 0 \\\\\n0 &amp; R_{fDQ} \n\\end{array}\\right]\\left[\\begin{array}{cc}\nC^{-1} &amp; 0 \\\\\n0 &amp; E \n\\end{array}\\right]\\left[\\begin{array}{c}\nI_{dq0} \\\\\nI_{fDQ} \n\\end{array}\\right]\n=\n\\left[\\begin{array}{cc}\nR_{abc} &amp; 0 \\\\\n0 &amp; R_{fDQ} \n\\end{array}\\right]\\left[\\begin{array}{c}\nI_{dq0} \\\\\nI_{fDQ} \n\\end{array}\\right]\n[C0​0E​][Rabc​0​0RfDQ​​][Iabc​IfDQ​​]=[C0​0E​][Rabc​0​0RfDQ​​][C−10​0E​][Idq0​IfDQ​​]=[Rabc​0​0RfDQ​​][Idq0​IfDQ​​]\n联立上述各式，可导出dq0坐标系统下的电压方程式：\n[uduqu0ufuDuQ]=p[ψdψqψ0ψfψDψQ]+[ra000000ra000000ra000000rf000000rD000000rQ][idiqi0ifiDiQ]+[−ωψqωψd0000]\\begin{bmatrix}\nu_d \\\\\nu_q \\\\\nu_0 \\\\\nu_f \\\\\nu_D \\\\\nu_Q\n\\end{bmatrix}\n=p\n\\begin{bmatrix}\n\\psi_d \\\\\n\\psi_q \\\\\n\\psi_0 \\\\\n\\psi_f \\\\\n\\psi_D \\\\\n\\psi_Q\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nr_a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; r_a &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; r_a &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; r_f &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; r_D &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; r_Q\n\\end{bmatrix}\n\\begin{bmatrix}\ni_d \\\\\ni_q \\\\\ni_0 \\\\\ni_f \\\\\ni_D \\\\\ni_Q\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n-\\omega \\psi_q \\\\\n\\omega \\psi_d \\\\\n0 \\\\\n0 \\\\\n0 \\\\\n0\n\\end{bmatrix}\n⎣⎢⎢⎢⎢⎢⎢⎢⎡​ud​uq​u0​uf​uD​uQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=p⎣⎢⎢⎢⎢⎢⎢⎢⎡​ψd​ψq​ψ0​ψf​ψD​ψQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​+⎣⎢⎢⎢⎢⎢⎢⎢⎡​ra​00000​0ra​0000​00ra​000​000rf​00​0000rD​0​00000rQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎢⎡​id​iq​i0​if​iD​iQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​+⎣⎢⎢⎢⎢⎢⎢⎢⎡​−ωψq​ωψd​0000​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n根据上式，显然假想的电枢d、q轴绕组的电压方程中，与a、b、c绕组的“静止绕组”相比，除pψp\\psipψ仅表示变压器电动势外，另有正比于角速度的运动电动势ωψ\\omega\\psiωψ项存在。\n在dq0坐标系统中，因重新选取了电枢绕组的轴线，使得d、q轴线以ω\\omegaω转速旋转，而构成d、q绕组的线圈元件仍为静止，因而线圈元件与磁链之间存在相对运动，产生了运动电动势ωψ\\omega\\psiωψ。这种绕组轴线与构成该绕组的线圈元件间存在相对运动的绕组称为“伪静止绕组”。\n 同步电机的派克（Park）方程\n派克变换(Park Transform)实际是以克拉克变换(Clark Transform，静止dq坐标系变换)推广而来。恒定幅值条件下的Clark线性变换矩阵即下图所示：\n\n式中，矩阵前的常系数23\\frac{2}{3}32​用于保证在变换后，变量的幅值仍保持不变。\n若需要进行恒功率Clark变换，变换矩阵可被替换为：\n\n当Clark变换被推广至旋转dq坐标系（即包含转子位置角θ\\thetaθ作为变量）时，结合三角恒等变换，可导出Park变换方程。相关推导参见《Clark变换与Park变换的推导》。\nPark方程为定常系数微分方程，在同步电机分析中使用该方程可以通过解析方法求解恒速运转时电机的瞬态和稳态运行问题。\n上述方程中各变量都是有名值,用有名值的好处是物理念明确,单位的量纲清楚,但在实际计算中往往有所不便,因此，分析计算电机的许多问题时，经常采用标么值。\n dq0坐标系统与双反应理论\n电机学中已经介绍过，双反应理论是由Andre Blondel提出的一种解释同步电机内部磁场分布的方法。该理论假设同步电机的电枢磁动势（MMF）可以分解为两个独立的分量：\n\n\nd轴反应：与转子磁链对齐的磁动势分量，主要影响电机的励磁电流。\n\n\nq轴反应：与d轴垂直的磁动势分量，主要影响电机的转矩电流。\n\n\n双反应理论认为这两个反应是独立的，并且可以分别计算，从而简化了电机的分析。\ndq0坐标系统与双反应理论在概念和应用上具有很大的统一性。具体表现如下：\n\n\n坐标对齐：在dq0坐标系统中，d轴和q轴分别对应双反应理论中的d轴反应和q轴反应。这使得电机的磁动势和电流可以通过这两个独立的分量来表示。\n\n\n数学简化：两者都旨在简化电机的数学分析。dq0坐标系统将交流变量转换为直流变量，而双反应理论将复杂的三相系统分解为两个独立的轴。这两种方法结合使用，可以大大简化电机的动态建模和控制设计。\n\n\n独立性假设：双反应理论假设d轴反应和q轴反应是独立的，这在dq0坐标系统中也得到了体现。dq0系统中的电压和电流方程可以分别在d轴和q轴上进行解耦分析。\n\n\n同步电机的dq0坐标系统和双反应理论都为简化和深入理解电机内部的物理现象提供了工具。dq0坐标系统通过数学变换将电机的时变问题转换为静态问题，而双反应理论则通过物理解释将电机的磁动势分解为两个独立分量。两者在概念和实际应用上具有很强的统一性，结合使用能够更好地分析和控制同步电机。\n","categories":["电气工程"]},{"title":"【电机瞬态分析】交流电机方程式（相坐标）","url":"/2024/07/11/%E3%80%90%E7%94%B5%E6%9C%BA%E7%9E%AC%E6%80%81%E5%88%86%E6%9E%90%E3%80%91%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E6%96%B9%E7%A8%8B%E5%BC%8F%EF%BC%88%E7%9B%B8%E5%9D%90%E6%A0%87%EF%BC%89/","content":" 凸级同步电机在相坐标系统中的电压方程式\n 正方向规定中的电动机惯例与发电机惯例\n 电动机惯例\n磁链定义式为：\nλ=Nϕ\\lambda = N \\phi\nλ=Nϕ\n其中NNN为线圈匝数。\n根据惯例，认为一个线圈轴线的正方向极为该线圈产生磁场轴线的正方向。若按照右手螺旋定律来确定电流和电压的正方向，即认为二者符合电动机惯例，则该回路磁链方程式可列写为：\nψk=Nϕ=LkIk\\psi_k = N \\phi = L_kI_k\nψk​=Nϕ=Lk​Ik​\n其中LLL为线圈电感，III为线圈中的电流。\n根据电磁感应定理和楞次定理，当磁链ψ\\psiψ正向增长时，感生电动势必定是阻止磁链增长的，这也就意味着在等效电路中，电压源电位升高的方向与电流正方向相反。等效回路如下图所示。\n\n根据基尔霍夫第二定律，此时等效回路的电压方程式为：\nuk=pψ+ikrku_k = p \\psi + i_k r_k\nuk​=pψ+ik​rk​\n其中,ppp为微分算子，即ddt\\frac{d}{dt}dtd​。ψ\\psiψ为主磁路磁链。\n简单来说，电动机惯例下，电压、电流正方向的规定应当反映出：\n\n电流从电源流向电机内部。即定子绕组的电流方向是从电源到电机。\n电源向电机传递功率，电机消耗电能转换为机械能输出。\n在电动机运行时，电流从定子绕组流入，电枢电流方向与定子磁场方向相同或相近，电动机产生电磁转矩，带动机械负载运行。\n\n 发电机惯例\n如果保持电流的正方向规定规则不变，仍将产生正向磁链的电流方向规定为电流正方向，仅改变电压正方向的规定，令二者符合发电机惯例，则回路电压正方向与电流正方向的关系改为下图所示：\n\n根据基尔霍夫第二定律，回路电压方程式为：\nuk=−pψ−ikrku_k = -p \\psi - i_k r_k\nuk​=−pψ−ik​rk​\n简单来说，发电机惯例下，电压、电流正方向的规定应当反映出：\n\n电流从电机内部流向电源。即定子绕组的电流方向是从电机到电网或负载。\n电机向电源传递功率，电机将机械能转换为电能输出。\n在发电机运行时，外部机械力驱动转子旋转，定子绕组中的电流流出，定子绕组中的电流方向与定子磁场方向相反或相对，发电机将机械能转换为电能输出到电网或负载。\n\n 凸级同步电机的电压方程式\n分析凸级同步电机运行问题前，为简化分析，作以下假定：\n\n电机铁磁部分的磁路为线性，即不计饱和、剩磁、磁滞和涡流的影响；\n电机的定、转子齿槽效应用气踪的卡氏系数表征，即认为定、转子表面光滑，只是气隙增大了一些；\n定子三相绕组对称，转子结构分别对直轴和交轴对称。\n\n由于假定磁路为线性，可应用叠加原理，即某绕组交链的总磁链等于各绕组电流分别产生并与之交链的磁链的代数和。实际电机饱和的影响，可根据电机的运行条件，近似地采用选择适当参数值的方法加以修正。\n开始分析前应当规定各变量的正方向，如下图所示。\n\n显然图中a、b、c轴线分别表示定子三相绕组实际轴线的对应正方向，即各相绕组磁链正方向。以及为基础，规定产生正向磁链的电流方向为电流正方向。电压正方向与电流正方向的关系按照电动机惯例确定。\n 定子绕组\n按照电动机惯例，根据基尔霍夫第二定律，定子三相绕组的电压方程式可分别根据定子绕组回路列写为：\nua=pψa+rsiaub=pψb+rsibuc=pψc+rsic}\\left.\\begin{array}{l}\nu_{\\mathrm{a}}=p \\psi_{\\mathrm{a}}+r_{s} i_{\\mathrm{a}} \\\\\nu_{\\mathrm{b}}=p \\psi_{\\mathrm{b}}+r_{\\mathrm{s}} i_{\\mathrm{b}} \\\\\nu_{\\mathrm{c}}=p \\psi_{\\mathrm{c}}+r_{\\mathrm{s}} i_{\\mathrm{c}}\n\\end{array}\\right\\}\nua​=pψa​+rs​ia​ub​=pψb​+rs​ib​uc​=pψc​+rs​ic​​⎭⎪⎬⎪⎫​\n 励磁绕组\n根据电动机惯例，励磁绕组电压方程为：\nuf=−pψf−ifrfu_f = -p \\psi_f - i_f r_f\nuf​=−pψf​−if​rf​\n 阻尼绕组\n阻尼绕组广泛应用于电力系统中需要高稳定性的同步电机，如发电机和大型工业电动机。其主要目的是保证电机在启动、停止以及负载变化时的平稳运行，防止系统失步和振荡。\n阻尼绕组一般由安装在磁极极靴上的阻尼条和阻尼环组成，阻尼条由阻尼环部分或全部短接，其分布对于直轴或交轴而言通常都是对称的。其结构、安装位置和简单示意图如下所示。\n\n\n\n\n可见阻尼条构成的回路是网状的，为了方便起见，通常电流回路的选取均对称于直轴或交轴。上图表示每个磁极有四根阻尼条的阻尼绕组，其中回路1d、2d对称于d轴，回路1q、2q对称于q轴，阻尼条中流过的实际电流即为相应的d轴和q轴回路电流的代数和。\n当只考虑气隙磁场（定、转子合成磁场）基波时，若基于以上规则划分阻尼绕组电流回路，则d轴回路和q轴回路在空间中恰好相差90°的电角度，而转子结构显然相对于d轴或q轴又是对称的，因此在d轴回路和q轴回路之间不产生互感，进而可把实际的阻尼绕组看成是两组假想的阻尼绕组，即直轴阻尼绕组和交轴阻尼绕组。\n若按照实际情况单独计算每一根阻尼条的电流和磁链关系，可进一步给出每一根阻尼条的实际电流，但是计算量非常大。在不需研究阻尼绕组内部情况的条件下，可将实际的直轴及轴的多个回路的阻尼绕组分别用一个直轴及交轴的等效阻尼统组D和Q来代替,从而大为简化分析计算工作。这样虽会给计算带来一些误差，但在工程计算中是允许的，也是常用的一种方法。简化的直轴及交轴等效阻尼绕组的电压方程式为：\n0=pψD+rDiD0=pψQ+rQiQ}\\left.\\begin{array}{l}\n0 = p \\psi_D + r_D i_D \\\\\n0 = p \\psi_Q + r_Q i_Q\n\\end{array}\\right\\}\n0=pψD​+rD​iD​0=pψQ​+rQ​iQ​​}\n 联立\n联立定子绕组、励磁绕组和阻尼绕组的电压方程式，用矩阵形式表示为：\nU=pΨ+RIU = p \\Psi + R I \nU=pΨ+RI\n式中\nU=[uaubucuf00]TU = [u_a \\quad u_b \\quad u_c  \\quad u_f \\quad 0 \\quad 0]^{T}\nU=[ua​ub​uc​uf​00]T\nI=[iaibicifiDiQ]TI = [i_a \\quad i_b \\quad i_c  \\quad i_f \\quad i_D \\quad i_Q]^{T}\nI=[ia​ib​ic​if​iD​iQ​]T\nΨ=[ψaψbψcψfψDψQ]T\\Psi = [\\psi_a \\quad \\psi_b \\quad \\psi_c  \\quad \\psi_f \\quad \\psi_D \\quad \\psi_Q]^{T}\nΨ=[ψa​ψb​ψc​ψf​ψD​ψQ​]T\nR=[rarbrcrfrDrQ]R =\n\\begin{bmatrix}\nr_a &amp; &amp; &amp; &amp; &amp; \\\\\n&amp; r_b &amp; &amp; &amp; &amp; \\\\\n&amp; &amp; r_c &amp; &amp; &amp; \\\\\n&amp; &amp; &amp; r_f &amp; &amp; \\\\\n&amp; &amp; &amp; &amp; r_D &amp; \\\\\n&amp; &amp; &amp; &amp; &amp; r_Q \\\\\n\\end{bmatrix}\nR=⎣⎢⎢⎢⎢⎢⎢⎢⎡​ra​​rb​​rc​​rf​​rD​​rQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n由上式，每个电压方程式均由两项构成：\n\n与绕组交链的主磁链随时间变化而产生的感应电动势pψp\\psipψ\n电流通过绕组电阻产生的压降ririri\n\n在上述的分析中，无论是定子绕组、励磁绕组还是阻尼绕组，不管其本身是旋转还是停止，其绕组的轴线与构成该绕组的线圈元件之间永远保持相对静止。这类绕组也被称为“静止绕组” 。\n 凸级同步电机在相坐标系统中的磁链方程式\n上文导出的电压方程式中，与每个绕组交链的主磁链是以下两个部分的代数和：\n\n绕组自身通过变化电流产生的磁通（自感）\n与该绕组相交链的互感磁链（互感）\n\n这些磁链与电流及电感系数的关系用矩阵形式表示为：\n[ψaψbψcψfψDψQ]=[LaaMabMacMafMaDMaQMbaLbbMbcMbfMbDMbQMcaMcbLccMdMcDMcQMfaMfbMfcLfMfD0MDaMDbMDcMDfLD0MQaMQbMQc00LQ][iaibicifiDiQ]\\begin{bmatrix}\\psi_\\mathrm{a}\\\\\\psi_\\mathrm{b}\\\\\\psi_\\mathrm{c}\\\\\\psi_\\mathrm{f}\\\\\\psi_\\mathrm{D}\\\\\\psi_\\mathrm{Q}\\end{bmatrix}=\\begin{bmatrix}L_\\mathrm{aa}&amp;M_\\mathrm{ab}&amp;M_\\mathrm{ac}&amp;M_\\mathrm{af}&amp;M_\\mathrm{aD}&amp;M_\\mathrm{aQ}\\\\M_\\mathrm{ba}&amp;L_\\mathrm{bb}&amp;M_\\mathrm{bc}&amp;M_\\mathrm{bf}&amp;M_\\mathrm{bD}&amp;M_\\mathrm{bQ}\\\\M_\\mathrm{ca}&amp;M_\\mathrm{cb}&amp;L_\\mathrm{cc}&amp;M_d&amp;M_\\mathrm{cD}&amp;M_\\mathrm{cQ}\\\\M_\\mathrm{fa}&amp;M_\\mathrm{fb}&amp;M_\\mathrm{fc}&amp;L_\\mathrm{f}&amp;M_\\mathrm{fD}&amp;0\\\\M_\\mathrm{Da}&amp;M_\\mathrm{Db}&amp;M_\\mathrm{Dc}&amp;M_\\mathrm{Df}&amp;L_\\mathrm{D}&amp;0\\\\M_\\mathrm{Qa}&amp;M_\\mathrm{Qb}&amp;M_\\mathrm{Qc}&amp;0&amp;0&amp;L_\\mathrm{Q}\\end{bmatrix}\\begin{bmatrix}i_\\mathrm{a}\\\\i_\\mathrm{b}\\\\i_\\mathrm{c}\\\\i_\\mathrm{f}\\\\i_\\mathrm{D}\\\\i_\\mathrm{Q}\\end{bmatrix}\n⎣⎢⎢⎢⎢⎢⎢⎢⎡​ψa​ψb​ψc​ψf​ψD​ψQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎢⎡​Laa​Mba​Mca​Mfa​MDa​MQa​​Mab​Lbb​Mcb​Mfb​MDb​MQb​​Mac​Mbc​Lcc​Mfc​MDc​MQc​​Maf​Mbf​Md​Lf​MDf​0​MaD​MbD​McD​MfD​LD​0​MaQ​MbQ​McQ​00LQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎢⎡​ia​ib​ic​if​iD​iQ​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n注意：矩阵中的公式仍可通过λ=LI\\lambda = LIλ=LI导出，这里的LLL既可以是自感系数也可以是互感系数，其表示意义即为自感磁链或互感磁链。该矩阵中的互感系数也是可逆的。\n上式可改写为：\n[ΨabcΨfDQ]=[LssLsrLrsLrr][IabcIfDQ]\\begin{bmatrix}\\Psi_{abc}\\\\\\Psi_{fDQ}\\end{bmatrix}=\\begin{bmatrix}L_{ss}&amp;L_{sr}\\\\L_{rs} &amp; L_{rr}\\end{bmatrix}\\begin{bmatrix}I_{abc}\\\\I_{fDQ}\\end{bmatrix}\n[Ψabc​ΨfDQ​​]=[Lss​Lrs​​Lsr​Lrr​​][Iabc​IfDQ​​]\n其中，Lss、LsrL_{ss}、L_{sr}Lss​、Lsr​为定、转子自感系数矩阵，Lsr、LrsL_{sr}、L_{rs}Lsr​、Lrs​为定、转子互感系数矩阵。\n显然，由于交轴等效阻尼绕组Q与直轴等效阻尼绕组D，还有励磁绕组fff的轴线在空间中相差90°电角度，因此二者互感系数为0。这就是为什么矩阵中MfQ、MDQ、MQf、MQDM_{fQ}、M_{DQ}、M_{Qf}、M_{QD}MfQ​、MDQ​、MQf​、MQD​四者均等于0。\n 凸级同步电机的自感系数与互感系数\n 磁动势、磁导、自感系数、互感系数\n回顾一下磁导的概念：\n\n磁导（magnetic conductance,μ\\muμ）是衡量磁性材料对磁场线的导通能力的物理量，它类似于电导在电路中的作用。磁导越大，表示材料对磁场线的导通能力越强。具体来说，磁导是磁通量与磁动势的比值，反映了材料在磁场中的导磁性能。磁导越大，说明该部分对磁通量的阻碍越小，即导磁能力越强，磁阻（magnetic reluctance）越小。\n\n\n磁路中的磁导定义为：Λ=ΦF\\Lambda = \\frac{\\Phi}{F}Λ=FΦ​，其中Λ\\LambdaΛ为磁导，单位安培每韦伯（A/WbA/WbA/Wb），Φ\\PhiΦ为磁通量，单位韦伯（WbWbWb），FFF为磁动势，单位安培(AAA)。\n\n已经自感系数定义为：\nL=NΦIL = \\frac{N\\Phi}{I}\nL=INΦ​\n磁导定义为：\nΛ=ΦF=1Rm\\Lambda = \\frac{\\Phi}{F} = \\frac{1}{R_m}\nΛ=FΦ​=Rm​1​\n根据磁路欧姆定律：\nF=ΦRm=NIF = \\Phi R_m = NI\nF=ΦRm​=NI\n式中FFF为作用于该磁路上的磁动势，Φ\\PhiΦ为磁路内磁通量，RmR_mRm​为磁阻。\n联立以上式子，可导出：\nL=N2ΛL = N^2 \\Lambda\nL=N2Λ\n该方法也可被推广至分析两个线圈间互感系数的关系。\n由以上推导可知：\n\n线圈自感系数为线圈内通过单位电流所产生的自感磁链，其大小与该线圈匝数的平方（N2N^2N2）及自感磁通所经磁路磁导(μ\\muμ)的乘积成正比\n线圈1和线圈2间的互感系数为线圈1内通过单位电流所产生的与线圈2相交链的互感磁链，其大小与两线圈匝数的乘积（N1N2N_1N_2N1​N2​）成正比，并与互感磁通所经磁路的磁导(μ\\muμ)成正比\n\n凸级同步电机在转子旋转时，显然部分绕组之间的相对空间位置以及所对应磁路的磁导随转子位置变化而变化，因此相应的自感系数LLL或互感系数MMM将是转子位置角θ\\thetaθ的函数，即时变函数。\n 定子绕组自感系数\n首先分析定子a相绕组的自感系数LaaL_{aa}Laa​。当绕组匝数确定时，LaaL_{aa}Laa​的大小主要取决于对应磁路磁导的大小。当a相绕组中轴线与磁极直轴（d轴）轴线重合，即θ=0\\theta=0θ=0时，a相绕组磁场对应磁路的磁导Λ\\LambdaΛ最大，因而在此位置自感系数达到最大值LaadL_{aad}Laad​；当转子旋转至θ=π/2\\theta = \\pi /2θ=π/2电弧度时，a相绕组轴线与转子q轴重合，对应磁路的磁导最小，自感系数为最小值LaaqL_{aaq}Laaq​。当转子旋转至θ=π\\theta = \\piθ=π电弧度时，对应磁路的磁导Λ\\LambdaΛ和自感系数LLL又达到最大值。\n\n显然a相绕组自感系数随θ\\thetaθ的角的变化可以用余弦级数表示为：\nLaa=Laa0+Laa2cos2θ+Laa4cos4θ+...L_{aa}=L_{aa0}+L_{aa2}cos{2\\theta}+L_{aa4}cos{4\\theta}+...\nLaa​=Laa0​+Laa2​cos2θ+Laa4​cos4θ+...\n可见用该种方式计算绕组自感系数非常复杂。就工程设计而言，一般只需考虑气隙的基波磁动势和气隙的基波磁场。\n仅考虑隙的基波磁动势和气隙的基波磁场时，a相绕组自感系数LaaL_{aa}Laa​由以下二者构成：\n\n不通过气隙的漏磁场所对应的漏电感LaalL_{aal}Laal​\n通过气隙的主合成磁场对应的主电感LaamL_{aam}Laam​\n\n漏电感LaalL_{aal}Laal​一般仅和漏磁场的分布情况以及磁路性质有关，与转子空间位置无关，为一常数。主电感LaamL_{aam}Laam​是关于转子位置角θ\\thetaθ的函数。\n令a相绕组有效匝数为WWW，由磁动势定义式，绕组线圈通过单位电流所产生的基波磁动势为Fam=WF_{am}=WFam​=W，轴线为a轴。将该磁动势分解至磁导Λ\\LambdaΛ为恒值的d轴和q轴上，即Famd=WcosθF_{amd}=Wcos\\thetaFamd​=Wcosθ, Famq=−WsinθF_{amq}=-Wsin\\thetaFamq​=−Wsinθ。令d轴和q轴的磁导分别为Λd\\Lambda_dΛd​和Λq\\Lambda_qΛq​，则a相磁动势在d轴和q轴产生的基波磁通大小分别为：\nϕd=FamdΛd=WΛdcosθϕq=FamqΛq=−WΛqsinθ\\phi_d=F_{amd}\\Lambda_d=W\\Lambda_d cos\\theta\\\\\n\\phi_q=F_{amq}\\Lambda_q=-W\\Lambda_q sin\\theta\nϕd​=Famd​Λd​=WΛd​cosθϕq​=Famq​Λq​=−WΛq​sinθ\n二者与a相绕组交链的自感磁链等于相绕组的有效匝数WWW与d轴、q轴磁通在a轴上的分量乘积的代数和：\nΨaam=W(ϕdcosθ−ϕqsinθ)=W2Λdcos2θ+W2Λqsin2θ\\Psi_{aam}=W(\\phi_d cos\\theta-\\phi_q sin\\theta)=W^2\\Lambda_d cos^2{\\theta}+W^2\\Lambda_q sin^2{\\theta}\nΨaam​=W(ϕd​cosθ−ϕq​sinθ)=W2Λd​cos2θ+W2Λq​sin2θ\na相绕组通过单位电流时产生的主电感的表达式为：\nLaam=Laadcos2θ+Laaqsin2θ=12(Laad+Laaq)+12(Laad−Laaq)cos2θL_{aam}=L_{aad}cos^2{\\theta}+L_{aaq}sin^2{\\theta}=\\frac{1}{2}(L_{aad}+L_{aaq})+\\frac{1}{2}(L_{aad}-L_{aaq})cos{2\\theta}\nLaam​=Laad​cos2θ+Laaq​sin2θ=21​(Laad​+Laaq​)+21​(Laad​−Laaq​)cos2θ\na相绕组的自感系数LaaL_{aa}Laa​为主电感LaamL_{aam}Laam​和漏电感LaalL_{aal}Laal​的代数和，即\nLaa=Laam+Laal=Laa0+Laa2cos2θL_{aa} = L_{aam} + L_{aal} = L_{aa0}+L_{aa2}cos{2\\theta}\nLaa​=Laam​+Laal​=Laa0​+Laa2​cos2θ\n同理\nLbb=Laa0+Laa2cos2(θ−2π3)Lcc=Laa0+Laa2cos2(θ+2π3)L_{bb} = L_{aa0}+L_{aa2}cos{2(\\theta-\\frac{2\\pi}{3})}\\\\\nL_{cc} = L_{aa0}+L_{aa2}cos{2(\\theta+\\frac{2\\pi}{3})}\nLbb​=Laa0​+Laa2​cos2(θ−32π​)Lcc​=Laa0​+Laa2​cos2(θ+32π​)\n式中\nLaa0=Laal+12(Laad+Laaq)Laa2=12(Laad−Laaq)L_{aa0} = L_{aal}+\\frac{1}{2}(L_{aad}+L_{aaq})\\\\\nL_{aa2} = \\frac{1}{2}(L_{aad}-L_{aaq})\nLaa0​=Laal​+21​(Laad​+Laaq​)Laa2​=21​(Laad​−Laaq​)\n显然，当只考虑空间基波磁场时，凸级同步电机三相定子绕组二点自感系数只有常数项和转子位置角θ\\thetaθ的二次项，其他高次谐波项不存在，给计算带来很大的方便。\n注意：隐级同步电机和感应电机由于具有均匀分布的气隙，故各项绕组的自感系数与转子位置角θ\\thetaθ无关，为一常数。\n 定子两相绕组间的互感系数\n定子三相绕组结构相同，但绕组轴线在空间上互差2π/32\\pi/32π/3电弧度。a相绕组通过单位电流所产生的与b相绕组相交链的互感磁链，此为a、b相的互感系数MabM_{ab}Mab​。\n互感系数也由两部分构成：\n\n与不通过气隙的漏磁通对应的互漏感系数MablM_{abl}Mabl​\n与通过气隙的主磁通对应的互感系数MabmM_{abm}Mabm​\n\n与自感系数类似，互漏感系数MablM_{abl}Mabl​为一常值，互感系数MabmM_{abm}Mabm​随转子位置变化而变化。\n上文已经求出仅考虑空间基波磁场分布下a相绕组单位电流产生的直轴磁通ϕd\\phi_dϕd​和交轴磁通ϕq\\phi_qϕq​。它们与b相绕组相交链的互感磁链，等于相绕组有效匝数WWW与它们在b轴上的磁通量分量乘积的代数和：\nψabm=W[ϕdcos⁡(θ−2π3)]−W[ϕqsin⁡(θ−2π3)]=W2Λdcos⁡θcos⁡(θ−2π3)+W2Λqsin⁡θsin⁡(θ−2π3)\\begin{aligned}\n\\psi_{\\mathrm{abm}} &amp; =W\\left[\\phi_{d} \\cos \\left(\\theta-\\frac{2 \\pi}{3}\\right)\\right]-W\\left[\\phi_{q} \\sin \\left(\\theta-\\frac{2 \\pi}{3}\\right)\\right] \\\\\n&amp; =W^{2} \\Lambda_{d} \\cos \\theta \\cos \\left(\\theta-\\frac{2 \\pi}{3}\\right)+W^{2} \\Lambda_{q} \\sin \\theta \\sin \\left(\\theta-\\frac{2 \\pi}{3}\\right)\n\\end{aligned}\nψabm​​=W[ϕd​cos(θ−32π​)]−W[ϕq​sin(θ−32π​)]=W2Λd​cosθcos(θ−32π​)+W2Λq​sinθsin(θ−32π​)​\n所以a相绕组通过单位电路时产生的通过气隙的磁通与b轴绕组相交链的互感磁链，即a、b相间的互感系数为：\nMabm=Laadcosθcos(θ−2π3)+Laaqsinθsin(θ−2π3)=−Laad+Laaq4+Laad−Laaq2cos(2θ−2π3)M_{abm}=L_{aad}cos\\theta cos(\\theta-\\frac{2\\pi}{3})+L_{aaq}sin\\theta sin(\\theta-\\frac{2\\pi}{3})\\\\\n=-\\frac{L_{aad}+L_{aaq}}{4}+\\frac{L_{aad}-L_{aaq}}{2}cos(2\\theta-\\frac{2\\pi}{3})\nMabm​=Laad​cosθcos(θ−32π​)+Laaq​sinθsin(θ−32π​)=−4Laad​+Laaq​​+2Laad​−Laaq​​cos(2θ−32π​)\na相和b相间的互感系数MabM_{ab}Mab​应为互漏电感系数−Mabl-M_{abl}−Mabl​和互电感系数MabmM_{abm}Mabm​之和，即\nMab=−Mabl−Laad+Laaq4+Laad−Laaq2cos(2θ−2π3)=−Mab0+Laa2cos2(θ+2π3)M_{ab}=-M_{abl}-\\frac{L_{aad}+L_{aaq}}{4}+\\frac{L_{aad}-L_{aaq}}{2}cos(2\\theta-\\frac{2\\pi}{3})\\\\\n= - M_{ab0}+L_{aa2}cos{2(\\theta + \\frac{2\\pi}{3})}\nMab​=−Mabl​−4Laad​+Laaq​​+2Laad​−Laaq​​cos(2θ−32π​)=−Mab0​+Laa2​cos2(θ+32π​)\n同理\nMbc=−Mab0+Laa2cos2θMca=−Mab0+Laa2cos2(θ−2π3)M_{bc}=- M_{ab0}+L_{aa2}cos{2\\theta}\\\\\nM_{ca}=- M_{ab0}+L_{aa2}cos{2(\\theta-\\frac{2\\pi}{3})}\nMbc​=−Mab0​+Laa2​cos2θMca​=−Mab0​+Laa2​cos2(θ−32π​)\n式中Mab0=Mabl+Laad+Laaq4M_{ab0} = M_{abl}+\\frac{L_{aad}+L_{aaq}}{4}Mab0​=Mabl​+4Laad​+Laaq​​\n由于三相绕组轴线间夹角互为120°电角度，其值大于90°，因此其互感系数均为负值。定子绕组b相和c相间的互感系数MbcM_{bc}Mbc​随转子位置的变化曲线如下图所示。\n\n可见，θ=0\\theta = 0θ=0时，b相和c相的互感系数的绝对值最小；θ=π/2\\theta = \\pi /2θ=π/2时，互感系数绝对值最大，这与自感系数的变化规律是相反的。\n 定子绕组和转子绕组间的互感系数\n 定子绕组和励磁绕组间的互感系数\n励磁绕组通过单位电流时所产生的与定子a相绕组交链的互感磁链即为定子绕组与励磁绕组间的互感系数MafM_{af}Maf​。互感磁链遵循以下规律：\n\n当励磁绕组d轴与a相绕组轴线重合时，互感磁链为最大；\n转子d轴旋转90°电角度后，两轴线正交，互感磁链为0；\n当转子d轴旋转180°电角度时，互感磁链为负的最大值；\n当转子d轴旋转270°电角度时，两轴线正交，互感磁链为0；\n\n因此，一般情况下有：\nMaf=Mfa=Maf0cosθ+Maf3cos3θ+...M_{af} = M_{fa} = M_{af0}cos\\theta + M_{af3}cos{3\\theta}+...\nMaf​=Mfa​=Maf0​cosθ+Maf3​cos3θ+...\n同理可推广至b相和c相：\nMbf=Mfb=Maf0cos(θ−2π3)+Maf3cos(θ−2π3)+...Mcf=Mfc=Maf0cos(θ+2π3)+Maf3cos(θ+2π3)+...M_{bf} = M_{fb} = M_{af0}cos(\\theta-\\frac{2\\pi}{3}) + M_{af3}cos(\\theta-\\frac{2\\pi}{3})+...\\\\\nM_{cf} = M_{fc} = M_{af0}cos(\\theta+\\frac{2\\pi}{3}) + M_{af3}cos(\\theta+\\frac{2\\pi}{3})+...\nMbf​=Mfb​=Maf0​cos(θ−32π​)+Maf3​cos(θ−32π​)+...Mcf​=Mfc​=Maf0​cos(θ+32π​)+Maf3​cos(θ+32π​)+...\n仅考虑基波磁通时，显然互感系数只有基波分量，即：\nMaf=Mfa=Maf0cosθMbf=Mfb=Maf0cos(θ−2π3)Mcf=Mfc=Maf0cos(θ+2π3)M_{af} = M_{fa} = M_{af0}cos\\theta \\\\\nM_{bf} = M_{fb} = M_{af0}cos(\\theta-\\frac{2\\pi}{3})\\\\\nM_{cf} = M_{fc} = M_{af0}cos(\\theta+\\frac{2\\pi}{3}) \nMaf​=Mfa​=Maf0​cosθMbf​=Mfb​=Maf0​cos(θ−32π​)Mcf​=Mfc​=Maf0​cos(θ+32π​)\n式中Maf0M_{af0}Maf0​为a轴与励磁绕组d轴重合时所具有的最大互感系数。下标中的“0”表示该互感系数计算时仅考虑了基波分量。\nMafM_{af}Maf​随θ\\thetaθ的关系如下图所示。\n\n 定子绕组与直轴阻尼绕组间的互感系数\n直轴阻尼绕组与励磁绕组轴线重合，故定子绕组与直轴阻尼绕组间的互感系数变化规律可由定子绕组与励磁绕组的互感系数变化规律推广得来（仅考虑基波分量）：\nMaD=MDa=MaD0cosθMbD=MDb=MaD0cos(θ−2π3)McD=MDc=MaD0cos(θ+2π3)M_{aD} = M_{Da} = M_{aD0}cos\\theta \\\\\nM_{bD} = M_{Db} = M_{aD0}cos(\\theta-\\frac{2\\pi}{3})\\\\\nM_{cD} = M_{Dc} = M_{aD0}cos(\\theta+\\frac{2\\pi}{3}) \nMaD​=MDa​=MaD0​cosθMbD​=MDb​=MaD0​cos(θ−32π​)McD​=MDc​=MaD0​cos(θ+32π​)\n式中MaD0M_{aD0}MaD0​为定子绕组a轴与直轴阻尼绕组D轴重合时所具有的最大互感系数。\n 定子绕组与交轴阻尼绕组间的互感系数\n显然交轴提前直轴90°电角度，以θ+π2\\theta + \\frac{\\pi}{2}θ+2π​代换上小节公式中的θ\\thetaθ角，并考虑直轴和交轴的磁导不同，推导得（仅考虑基波分量）：\nMaQ=MQa=MaQ0cosθMbQ=MQb=MaQ0cos(θ−2π3)McQ=MQc=MaQ0cos(θ+2π3)M_{aQ} = M_{Qa} = M_{aQ0}cos\\theta \\\\\nM_{bQ} = M_{Qb} = M_{aQ0}cos(\\theta-\\frac{2\\pi}{3})\\\\\nM_{cQ} = M_{Qc} = M_{aQ0}cos(\\theta+\\frac{2\\pi}{3}) \nMaQ​=MQa​=MaQ0​cosθMbQ​=MQb​=MaQ0​cos(θ−32π​)McQ​=MQc​=MaQ0​cos(θ+32π​)\n式中MaQ0M_{aQ0}MaQ0​为定子绕组a轴与交轴阻尼绕组Q轴重合时所具有的最大互感系数。\n 转子绕组的自感系数\n转子绕组通过单位电流时产生的自感磁链即为转子绕组的自感系数。由于定子铁心为圆环形，转子上各绕组产生的自感磁链大小与转子位置无关，均为恒值。\n励磁绕组自感系数由两部分组成，即\nLf=Lfl+LfmL_f = L_{fl} + L_{fm}\nLf​=Lfl​+Lfm​\n式中 LflL_{fl}Lfl​对应励磁绕组漏磁通的漏电感系数，LfmL_{fm}Lfm​对应励磁绕组气隙磁通的主电感系数。\n直轴阻尼绕组和交轴阻尼绕组的自感系数分别为：\nLD=LDl+LDmLQ=LQl+LQmL_D = L_{Dl} + L_{Dm} \\\\\n\nL_Q = L_{Ql} + L_{Qm}\nLD​=LDl​+LDm​LQ​=LQl​+LQm​\n式中 LDlL_{Dl}LDl​和LQlL_{Ql}LQl​对应于D、Q绕组漏磁通的漏电感系数，LDmL_{Dm}LDm​和LQmL_{Qm}LQm​对应于D、Q绕组气隙磁通的主电感系数。\n 转子绕组间的互感系数\n因转子分别对直轴和交轴对称，且两轴正交，故交轴阻尼绕组Q与直轴阻尼绕组D、励磁绕组fff间的互感系数为0.绕组D与绕组fff同在直轴上且式中相对静止，有\nMfD=MDf=MfDl+MfDmM_{fD}=M_{Df}=M_{fDl}+M_{fDm}\nMfD​=MDf​=MfDl​+MfDm​\n 小结\n以上讨论的凸极同步电机电感系数，从变化规律上看，可分为三种类型：\n\n\n定子绕组的自感系数和互感系数。其变化周期为π\\piπ。引起这类电感系数变化的原因是转子直轴和交轴的磁导不同,当电机转子为圆柱形时,如隐极同步电机及感应电机，转子直轴和交轴的磁导相同，则电感系数Laad=LaaqL_{aad}=L_{aaq}Laad​=Laaq​，定子绕组的自感系数和互感系数均为常数，与转子位置角θ\\thetaθ无关。\n\n\n定子与转子绕组间的互感系数。其变化周期为2π\\piπ。引起这类电感系数变化的原因是定子绕组轴线与转子绕组轴线间有相对运动，导致互感磁链周期性变化。因此，即使在隐极同步电机和感应电机中，这类互感系数仍是转子位置角θ\\thetaθ的函数。\n\n\n转子绕组的自感系数与互感系数。由于定子铁心为圆环形，对转子直轴或交轴而言，磁导是不变的，且转子绕组轴线间无相对运动。上述引起电感系数变化的两个原因均不存在，故转子绕组的自感系数与互感系数均为常数。\n\n\n","categories":["电气工程"]},{"title":"【电机瞬态分析】交流电机的运算电抗、等效电路、电磁转矩","url":"/2024/07/27/%E3%80%90%E7%94%B5%E6%9C%BA%E7%9E%AC%E6%80%81%E5%88%86%E6%9E%90%E3%80%91%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E7%94%B5%E6%8A%97%E3%80%81%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF%E3%80%81%E7%94%B5%E7%A3%81%E8%BD%AC%E7%9F%A9/","content":" 同步电机等效运算电路\n在进行瞬态分析时，亦可根据导出的方程式画出相应的等效电路，这样比较直观也便于记忆。一般情况下，最关心的是电枢绕组各量的变化，即从电枢绕组的端点看，能反映瞬态方程式的等效电路和等效阻抗。通过从a、b、c坐标系统到d、q、0坐标系统的变换，将电感系数从变系数变为了常系数，并通过各基值的选取，使互感系数的标么值可逆，且Lad=Maf=MaD=xadL_{ad}=M_{af}=M_{aD}=x_{ad}Lad​=Maf​=MaD​=xad​，这样就在电路上无联系的几个绕组具备了等效为一个电路的基本条件。当转子转速ω\\omegaω=恒值时，电压方程式为常系数线性微分方程组，可采用拉氏变换将时域的微分方程转换为复频域的代数方程求解。\n下面就转子上只有励磁绕组和同时存在励磁和阻尼绕组两种情况，分别对电枢直轴链和交轴磁链的等效运算电路进行讨论。\n 转子上只有励磁绕组时的等效运算电路\n该情况下，根据上篇文章的内容，由标幺值下交流电机方程式推导可得（磁链关系代入电压方程式），直轴电枢磁链方程和励磁绕组电压方程为\nψd=xdid+xadif\\psi_d=x_di_d+x_{ad}i_f\nψd​=xd​id​+xad​if​\nuf=pxadid+(rf+pxf)ifu_f=px_{ad}i_d+(r_f+px_f)i_f\nuf​=pxad​id​+(rf​+pxf​)if​\n式中ppp为时间微分算子。可见各变量为时间的函数，相应的方程为微分方程。当电流id、ifi_d、i_fid​、if​的初值为零时，拉氏变换后方程的形式不变，但ppp为一代数复变量，各变量是以ppp为变量的变换函数，如变量ψ、i、u\\psi、i、uψ、i、u经拉氏变换后分别用ψ(p)、I(p)、U(p)\\psi(p)、I(p)、U(p)ψ(p)、I(p)、U(p)表示，以示区别。如此改写后的磁链和电压方程式的变换函数为\nud(p)=xdId(p)+xadIf(p)u_d(p)=x_dI_d(p)+x_{ad}I_f(p)\nud​(p)=xd​Id​(p)+xad​If​(p)\nUf(p)=pxadId(p)+(rf+pxf)If(p)U_f(p)=px_{ad}I_d(p)+(r_f+px_f)I_f(p)\nUf​(p)=pxad​Id​(p)+(rf​+pxf​)If​(p)\n注意：此处的ppp在代数学意义上可视为拉普拉斯变换算子sss。U(p)U(p)U(p)即等同于U(s)U(s)U(s)，从U(t)U(t)U(t)经LaplaceLaplaceLaplace变换而来。\n用ppp除等式Uf(p)U_f(p)Uf​(p)两端，并考虑到xd=xl+xadx_d=x_l+x_{ad}xd​=xl​+xad​，xf=xfl+xadx_f=x_{fl}+x_{ad}xf​=xfl​+xad​，整理后可得\nψd(p)=xlId(p)+xad[Id(p)+If(p)]\\psi_d(p)=x_lI_d(p)+x_{ad}[I_d(p)+I_f(p)]\nψd​(p)=xl​Id​(p)+xad​[Id​(p)+If​(p)]\nUf(p)p=xad[Id(p)+If(p)]+(xfl+rfp)If(p)\\frac{U_f(p)}{p}=x_{ad}[I_d(p)+I_f(p)]+(x_{fl}+\\frac{r_f}{p})I_f(p)\npUf​(p)​=xad​[Id​(p)+If​(p)]+(xfl​+prf​​)If​(p)\n根据上式即可画出相应的直轴等效运算电路，如下图所示。\n\n在多数情况下只需研究定子上的各变量，因而可以将等式中的转子电流项If(p)I_f(p)If​(p)消去，以获得更加简明的关系式。应用戴维南定理，根据图(a)，得到开路电压G(p)Uf(p)G(p)U_f(p)G(p)Uf​(p)及短路阻抗xd(p)x_d(p)xd​(p)，即\nψd(p)=G(p)Uf(p)+xd(p)Id(p)\\psi_d(p)=G(p)U_f(p)+x_d(p)I_d(p)\nψd​(p)=G(p)Uf​(p)+xd​(p)Id​(p)\n式中\nG(p)=xadrf+xfpG_(p)=\\frac{x_{ad}}{r_f+x_fp}\nG(​p)=rf​+xf​pxad​​\nxd(p)=xl+11xad+1xfl+rfpx_d(p)=x_l+\\frac{1}{\\frac{1}{x_{ad}+\\frac{1}{x_{fl}+\\frac{r_f}{p}}}}\nxd​(p)=xl​+xad​+xfl​+prf​​1​1​1​\n式中G(p)G_(p)G(​p)称为励磁电压对直轴磁链的传递函数，xd(p)x_d(p)xd​(p)称为直轴运算电抗。二者都是具有恒系数的运算式，和电机瞬时转速无关，因而可以用来研究任意转速下电机的各种运行工况。\n 转子上有励磁绕组、D轴阻尼绕组和Q轴阻尼绕组\n 直轴等效运算电路\n当转子直轴上除励磁绕组外还装有短路的阻尼绕组，且当各绕组电流初值为零时，可得到直轴电枢绕组磁链方程和励磁绕组、直轴阻尼绕组电压方程式的变换函数方程为\nψd(p)=xdId(p)+xadIf(p)+xadID(p)\\psi_d(p)=x_dI_d(p)+x_{ad}I_f(p)+x_{ad}I_D(p)\nψd​(p)=xd​Id​(p)+xad​If​(p)+xad​ID​(p)\nUf(p)=pxadId(p)+(rf+pxf)If(p)+pxadID(p)U_f(p)=px_{ad}I_d(p)+(r_f+px_f)I_f(p)+px_{ad}I_D(p)\nUf​(p)=pxad​Id​(p)+(rf​+pxf​)If​(p)+pxad​ID​(p)\n0=pxadId(p)+pxadIf(p)+(rD+pxD)ID(p)0=px_{ad}I_d(p)+px_{ad}I_f(p)+(r_D+px_D)I_D(p)\n0=pxad​Id​(p)+pxad​If​(p)+(rD​+pxD​)ID​(p)\n用ppp除以等式两侧，考虑xd=xl+xadx_d=x_l+x_{ad}xd​=xl​+xad​，xf=xfl+xadx_f=x_{fl}+x_{ad}xf​=xfl​+xad​，xD=xDl+xadx_D=x_{Dl}+x_{ad}xD​=xDl​+xad​，整理后有\nψd(p)=xlId(p)+xad[Id(p)+If(p)+ID(p)]\\psi_d(p)=x_lI_d(p)+x_{ad}[I_d(p)+I_f(p)+I_D(p)]\nψd​(p)=xl​Id​(p)+xad​[Id​(p)+If​(p)+ID​(p)]\nUf(p)p=xad[Id(p)+If(p)+ID(p)]+(xfl+rfp)If(p)\\frac{U_f(p)}{p}=x_{ad}[I_d(p)+I_f(p)+I_D(p)]+(x_{fl}+\\frac{r_f}{p})I_f(p)\npUf​(p)​=xad​[Id​(p)+If​(p)+ID​(p)]+(xfl​+prf​​)If​(p)\n0=xad[Id(p)+If(p)+ID(p)]+(xDl+rDp)ID(p)0=x_{ad}[I_d(p)+I_f(p)+I_D(p)]+(x_{Dl}+\\frac{r_D}{p})I_D(p)\n0=xad​[Id​(p)+If​(p)+ID​(p)]+(xDl​+prD​​)ID​(p)\n根据上式，导出得有阻尼绕组时得直轴等效运算电路\n\n根据戴维南定理，可得开路电压G(p)Uf(p)G(p)U_f(p)G(p)Uf​(p)及短路阻抗xd(p)x_d(p)xd​(p)，则ψd(p)\\psi_d(p)ψd​(p)为\nψd(p)=G(p)Uf(p)+xd(p)Id(p)\\psi_d(p)=G(p)U_f(p)+x_d(p)I_d(p)\nψd​(p)=G(p)Uf​(p)+xd​(p)Id​(p)\n其中\nG(p)=(xDxad−xad2)p+xadrD(xfxD−xad2)p2+(xfrD+xDrf)p+rfrDG(p)=\\frac{(x_Dx_{ad}-x_{ad}^2)p+x_{ad}r_D}{(x_fx_D-x_{ad}^2)p^2+(x_fr_D+x_Dr_f)p+r_fr_D}\nG(p)=(xf​xD​−xad2​)p2+(xf​rD​+xD​rf​)p+rf​rD​(xD​xad​−xad2​)p+xad​rD​​\nxd(p)=xl+11xad+1xfl+rfp+1xDl+rDpx_d(p)=x_l+\\frac{1}{\\frac{1}{x_{ad}}+\\frac{1}{x_{fl}+\\frac{r_f}{p}}+\\frac{1}{x_{Dl}+\\frac{r_D}{p}}}\nxd​(p)=xl​+xad​1​+xfl​+prf​​1​+xDl​+prD​​1​1​\n 交轴等效运算电路\n转子交轴上有短路的阻尼绕组，且各绕组电流初值为零时，可得到交轴电枢绕组磁链方程和交轴阻尼绕组电压方程式的变换函数为\nψq(p)=xqIq(p)+xaqIQ(p)\\psi_q(p)=x_qI_q(p)+x_{aq}I_Q(p)\nψq​(p)=xq​Iq​(p)+xaq​IQ​(p)\n0=xaqIq(p)+(xQ+rQp)IQ(p)0=x_{aq}I_q(p)+(x_Q+\\frac{r_Q}{p})I_Q(p)\n0=xaq​Iq​(p)+(xQ​+prQ​​)IQ​(p)\n类似于直轴情况，考虑xq=xl+xaqx_q=x_l+x_{aq}xq​=xl​+xaq​，xQ=xQl+xaqx_Q=x_{Ql}+x_{aq}xQ​=xQl​+xaq​，消去交轴阻尼绕组电流后，有\nψq(p)=xq(p)Iq(p)\\psi_q(p)=x_q(p)I_q(p)\nψq​(p)=xq​(p)Iq​(p)\n其中\nxq(p)=xl+11xaq+1xQl+rQpx_q(p)=x_l+\\frac{1}{\\frac{1}{x_{aq}}+\\frac{1}{x_{Ql}+\\frac{r_Q}{p}}}\nxq​(p)=xl​+xaq​1​+xQl​+prQ​​1​1​\n式中xq(p)x_q(p)xq​(p)为交轴运算电抗。交轴等效运算电路如下图所示。\n\n 运算电抗特性\n 同步电抗、瞬变（暂态）电抗和超瞬变（次暂态）电抗\n根据上节内容，直轴、交轴运算电抗的等效电路可导出为下图（未消去转子电流）。\n\n根据拉氏变换终值定理，ppp趋于零时，ttt趋于无穷大，即同步电机稳态运行所呈现的同步电抗。图中ppp趋于零时，其值相当于转子各绕组均断开时的电抗值，即\nlim⁡p→0xd(p)=xl+xad=xd\\lim_{p \\to 0}x_d(p)=x_l+x_{ad}=x_d\np→0lim​xd​(p)=xl​+xad​=xd​\nlim⁡p→0xq(p)=xl+xaq=xq\\lim_{p \\to 0}x_q(p)=x_l+x_{aq}=x_q\np→0lim​xq​(p)=xl​+xaq​=xq​\n根据拉氏变换初值定理，若转子上无阻尼绕组，根据等效电路，可得\nlim⁡p→∞xd(p)=xl+11xad+1xfl=xd′\\lim_{p \\to \\infin}x_d(p)=x_l+\\frac{1}{\\frac{1}{x_{ad}}+\\frac{1}{x_{fl}}}=x&#x27;_{d}\np→∞lim​xd​(p)=xl​+xad​1​+xfl​1​1​=xd′​\nxd′x&#x27;_{d}xd′​即为同步电机的直轴暂态电抗，等效电路如图2-6(a)所示。\n若转子上有阻尼绕组，根据等效电路，有\nlim⁡p→∞xd(p)=xl+11xad+1xfl+1xDl=xd′′\\lim_{p \\to \\infin}x_d(p)=x_l+\\frac{1}{\\frac{1}{x_{ad}}+\\frac{1}{x_{fl}}+\\frac{1}{x_{Dl}}}=x&#x27;&#x27;_{d}\np→∞lim​xd​(p)=xl​+xad​1​+xfl​1​+xDl​1​1​=xd′′​\nxd′′x&#x27;&#x27;_{d}xd′′​即为同步电机的直轴次暂态电抗，等效电路如图2-6(b)所示。\n同理，在交轴方向，根据等效电路，有\nlim⁡p→∞xq(p)=xl+11xaq+1xQl=xq′′\\lim_{p \\to \\infin}x_q(p)=x_l+\\frac{1}{\\frac{1}{x_{aq}}+\\frac{1}{x_{Ql}}}=x&#x27;&#x27;_{q}\np→∞lim​xq​(p)=xl​+xaq​1​+xQl​1​1​=xq′′​\nxq′′x&#x27;&#x27;_{q}xq′′​即为同步电机的交轴次暂态电抗，等效电路如图2-6©所示。\n\n可见，暂态电抗和次暂态电抗分别是无阻尼绕组和有阻尼绕组同步电机在瞬态的初瞬间，从电枢绕组端看进去的电抗。该数值在研究同步电机运行时非常有用。\n 以时间常数形式来表示的运算电抗\n实际应用中，运算电抗xd(p)x_d(p)xd​(p)和xq(p)x_q(p)xq​(p)常用励磁绕组和阻尼绕组的时间常数来表示。\n当转子仅有励磁绕组而无阻尼绕组时，有\nxd(p)=xd−xad2prf+xfp=xd[rf+(xf−xad2/xd)rf+xfp]=xd(rf+xf′prf+xfp)=xd(1+Tf′p1+Tfp)x_d(p)=x_d-\\frac{x_{ad}^2p}{r_f+x_fp}=x_d[\\frac{r_f+(x_f-x_{ad}^2/x_d)}{r_f+x_fp}]=x_d(\\frac{r_f+x_f&#x27;p}{r_f+x_fp})=x_d(\\frac{1+T_f&#x27;p}{1+T_fp})\nxd​(p)=xd​−rf​+xf​pxad2​p​=xd​[rf​+xf​prf​+(xf​−xad2​/xd​)​]=xd​(rf​+xf​prf​+xf′​p​)=xd​(1+Tf​p1+Tf′​p​)\n式中，xf′x_f&#x27;xf′​为电枢绕组短路时从励磁绕组端口看进去的瞬态电抗，Tf′=xf′/rfT_f&#x27;=x_f&#x27;/r_fTf′​=xf′​/rf​为励磁绕组瞬态时间常数。Tf=xf/rfT_f=x_f/r_fTf​=xf​/rf​为励磁绕组时间常数。\n电枢绕组短路时，从励磁绕组端口看进去的瞬态电抗xf′x_f&#x27;xf′​的等效电路如图2-7所示。\n\n当转子仅有励磁绕组时，其时间常数Tf′T_f&#x27;Tf′​就是电枢直轴瞬变电流衰减的时间常数Td′T_d&#x27;Td′​，即Tf′=Td′T_f&#x27;=T_d&#x27;Tf′​=Td′​，且Tf=Td0T_f=T_{d0}Tf​=Td0​。注意：此处时间常数单位均用时间的标幺值表示。\n求解瞬变电流时常使用运算电抗的倒数形式，有\n1xd(p)=1xd×1+Td01+Td′p\\frac{1}{x_d(p)}=\\frac{1}{x_d} \\times \\frac{1+T_{d0}}{1+T_d&#x27;p}\nxd​(p)1​=xd​1​×1+Td′​p1+Td0​​\n将该式展开为部分分式，并考虑到xd′=Td′Td0xdx_d&#x27;=\\frac{T_d&#x27;}{T_{d0}}x_dxd′​=Td0​Td′​​xd​，有\n1xd(p)=1xd+(1xd′−1xd)Td′p1+Td′p\\frac{1}{x_d(p)}=\\frac{1}{x_d}+(\\frac{1}{x_d&#x27;}-\\frac{1}{x_d})\\frac{T_d&#x27;p}{1+T_d&#x27;p}\nxd​(p)1​=xd​1​+(xd′​1​−xd​1​)1+Td′​pTd′​p​\n该形式在由复数域函数变换返回时域的原函数时非常方便。\n同理可推导，转子上除励磁绕组外，直轴上还装有阻尼绕组时的直轴运算电抗xd(p)x_d(p)xd​(p)的时间常数表达式为\nxd(p)=xd[σfD′Tf′TD′p2+(Tf′TD′)p+1σfDTfTDp2+(Tf+TD)p+1]x_d(p)=x_d[\\frac{\\sigma_{fD}&#x27; T_f&#x27; T_D&#x27; p^2+(T_f&#x27;T_D&#x27;)p+1}{\\sigma_{fD}T_f T_Dp^2+(T_f+T_D)p+1}]\nxd​(p)=xd​[σfD​Tf​TD​p2+(Tf​+TD​)p+1σfD′​Tf′​TD′​p2+(Tf′​TD′​)p+1​]\n式中，\n\nTDT_DTD​为直轴阻尼绕组本身的时间常数。TD=xD/rDT_D=x_D/r_DTD​=xD​/rD​\nTD′T_D&#x27;TD′​为励磁绕组开路、直轴电枢绕组短路时，直轴阻尼绕组的时间常数（瞬态时间常数），TD′=xD′/rDT_D&#x27;=x_D&#x27;/r_DTD′​=xD′​/rD​。\nTD′T_D&#x27;TD′​计算式中xD′=xDl+11xl+1xad=xDl+xad′x_D&#x27;=x_{Dl}+\\frac{1}{\\frac{1}{x_l}+\\frac{1}{x_{ad}}}=x_{Dl}+x_{ad}&#x27;xD′​=xDl​+xl​1​+xad​1​1​=xDl​+xad′​，为该情况下直轴绕组的等效电抗，xD′x_D&#x27;xD′​等效电路如图2-8所示。\n\n\n\n\nσfD\\sigma_{fD}σfD​为电枢绕组开路时，励磁绕组和直轴阻尼绕组间的漏磁系数，σfD=1−xad2/xfxD\\sigma_{fD}=1-{x_{ad}^2}/{x_fx_D}σfD​=1−xad2​/xf​xD​\n\n\nσfD′\\sigma_{fD}&#x27;σfD′​为电枢绕组短路时，励磁绕组和直轴阻尼绕组间的漏磁系数，σfD′=1−xad′2/xf′xD′\\sigma_{fD}&#x27;=1-{x_{ad}&#x27;^2}/{x_f&#x27;x_D&#x27;}σfD′​=1−xad′2​/xf′​xD′​\n\n\n漏磁系数反映绕组间电磁耦合的漏磁情况。当完全耦合无漏磁时，上述漏磁系数为零。实际上每个绕组总存在着只与各自绕组交链的漏磁链和相应的漏电感，因此，漏磁系数不会为零，其大小反映了漏磁的大小。\n转子上除励磁绕组外，直轴上还装有阻尼绕组时的直轴运算电抗xd(p)x_d(p)xd​(p)的时间常数表达式可继续分解为ppp的因式形式：\nxd(p)=(Td′p+1)(Td′′p+1)(Td0′p+1)(Td0′′p+1)xdx_d(p)=\\frac{(T_d&#x27;p+1)(T_d&#x27;&#x27;p+1)}{(T_{d0}&#x27;p+1)(T_{d0}&#x27;&#x27;p+1)}x_d\nxd​(p)=(Td0′​p+1)(Td0′′​p+1)(Td′​p+1)(Td′′​p+1)​xd​\n联立，时间常数由下列ppp的二次方程式确定：\n(Td0′p+1)(Td0′′p+1)=σfDTfTDp2+(Tf+TD)p+1(T_{d0}&#x27;p+1)(T_{d0}&#x27;&#x27;p+1)=\\sigma_{fD}T_fT_Dp^2+(T_f+T_D)p+1\n(Td0′​p+1)(Td0′′​p+1)=σfD​Tf​TD​p2+(Tf​+TD​)p+1\n(Td′p+1)(Td′′p+1)=σfD′Tf′TD′p2+(Tf′+TD′)p+1(T_d&#x27;p+1)(T_d&#x27;&#x27;p+1)=\\sigma_{fD}&#x27;T_f&#x27;T_D&#x27;p^2+(T_f&#x27;+T_D&#x27;)p+1\n(Td′​p+1)(Td′′​p+1)=σfD′​Tf′​TD′​p2+(Tf′​+TD′​)p+1\n式中\nTd0′=2σfDTfTD(1−q)(Tf+TD)=12(1+q)(Tf+TD)≈Tf+TDT_{d0}&#x27;=\\frac{2\\sigma_{fD}T_fT_D}{(1-q)(T_f+T_D)}=\\frac{1}{2}(1+q)(T_f+T_D)\\approx T_f+T_D\nTd0′​=(1−q)(Tf​+TD​)2σfD​Tf​TD​​=21​(1+q)(Tf​+TD​)≈Tf​+TD​\nTd0′′=2σfDTfTD(1+q)(Tf+TD)≈σfDTfTD(Tf+TD)T_{d0}&#x27;&#x27;=\\frac{2\\sigma_{fD}T_fT_D}{(1+q)(T_f+T_D)} \\approx  \\frac{\\sigma_{fD}T_fT_D}{(T_f+T_D)}\nTd0′′​=(1+q)(Tf​+TD​)2σfD​Tf​TD​​≈(Tf​+TD​)σfD​Tf​TD​​\nTd′=2σfD′Tf′TD′(1−q′)(Tf′+TD′)=12(1+q′)(Tf′+TD′)≈Tf′+TD′T_d&#x27;=\\frac{2\\sigma_{fD}&#x27;T_f&#x27;T_D&#x27;}{(1-q&#x27;)(T_f&#x27;+T_D&#x27;)}=\\frac{1}{2}(1+q&#x27;)(T_f&#x27;+T_D&#x27;)\\approx T_f&#x27;+T_D&#x27;\nTd′​=(1−q′)(Tf′​+TD′​)2σfD′​Tf′​TD′​​=21​(1+q′)(Tf′​+TD′​)≈Tf′​+TD′​\nTd′′=2σfD′Tf′TD′(1+q′)(Tf′+TD′)≈σfD′Tf′TD′(Tf′+TD′)T_d&#x27;&#x27;=\\frac{2\\sigma_{fD}&#x27;T_f&#x27;T_D&#x27;}{(1+q&#x27;)(T_f&#x27;+T_D&#x27;)} \\approx  \\frac{\\sigma_{fD}&#x27;T_f&#x27;T_D&#x27;}{(T_f&#x27;+T_D&#x27;)}\nTd′′​=(1+q′)(Tf′​+TD′​)2σfD′​Tf′​TD′​​≈(Tf′​+TD′​)σfD′​Tf′​TD′​​\n式中q≈1q\\approx1q≈1，q′≈1q&#x27;\\approx1q′≈1。\n上式中的Td0′T_{d0}&#x27;Td0′​、Td0′′T_{d0}&#x27;&#x27;Td0′′​、Td′T_d&#x27;Td′​、Td′′T_d&#x27;&#x27;Td′′​是同步电机主要的四个时间常数，其准确值计算由上式给出。但以上计算非常繁琐，工程计算角度可进一步简化。考虑阻尼绕组电阻rDr_DrD​标幺值远大于励磁绕组电阻rfr_frf​的标幺值，而相应的电抗xDx_DxD​、xfx_fxf​的标幺值相近，xD′x_D&#x27;xD′​、xf′x_f&#x27;xf′​的标幺值亦相近，因此在直轴阻尼绕组和励磁绕组的时间常数中，TDT_DTD​远小于TfT_fTf​，且TD′T_D&#x27;TD′​远小于Tf′T_f&#x27;Tf′​。因而之前的计算式可进一步简化为\nTd0′=Tf+TD≈Tf=Td0T_{d0}&#x27;=T_f+T_D \\approx T_f = T_{d0}\nTd0′​=Tf​+TD​≈Tf​=Td0​\nTd0′′≈σfDTfTD(Tf+TD)≈σfDTDT_{d0}&#x27;&#x27; \\approx \\frac{\\sigma_{fD}T_fT_D}{(T_f+T_D)} \\approx \\sigma_{fD}T_D\nTd0′′​≈(Tf​+TD​)σfD​Tf​TD​​≈σfD​TD​\nTd′=Tf′+TD′≈Tf′T_d&#x27;=T_f&#x27;+T_D&#x27; \\approx T_f&#x27;\nTd′​=Tf′​+TD′​≈Tf′​\nTd′′≈σfD′Tf′TD′(Tf′+TD′)≈σfD′TD′T_d&#x27;&#x27; \\approx \\frac{\\sigma_{fD}&#x27;T_f&#x27;T_D&#x27;}{(T_f&#x27;+T_D&#x27;)} \\approx \\sigma_{fD}&#x27;T_D&#x27;\nTd′′​≈(Tf′​+TD′​)σfD′​Tf′​TD′​​≈σfD′​TD′​\n进一步可导出\nTd0′′≈σfDTD=(1−xad2xfxD)xDrD=(xDl+11xad+1xfl)1rDT_{d0}&#x27;&#x27; \\approx \\sigma_{fD}T_D=(1-\\frac{x_{ad}^2}{x_fx_D})\\frac{x_D}{r_D}=(x_{Dl}+\\frac{1}{\\frac{1}{x_{ad}}+\\frac{1}{x_{fl}}})\\frac{1}{r_D}\nTd0′′​≈σfD​TD​=(1−xf​xD​xad2​​)rD​xD​​=(xDl​+xad​1​+xfl​1​1​)rD​1​\nTd′′≈σfD′TD′=(1−xad′2xf′xD′)xD′rD=(xD′−xad′2xf′)1rD=(xDl+11xad+1xl+1xfl)1rDT_d&#x27;&#x27; \\approx \\sigma_{fD}&#x27;T_D&#x27;=(1-\\frac{x_{ad}&#x27;^2}{x_f&#x27;x_D&#x27;})\\frac{x_D&#x27;}{r_D}=(x_D&#x27;-\\frac{x_{ad}&#x27;^2}{x_f&#x27;})\\frac{1}{r_D}=(x_{Dl}+\\frac{1}{\\frac{1}{x_{ad}}+\\frac{1}{x_l}+\\frac{1}{x_{fl}}})\\frac{1}{r_D}\nTd′′​≈σfD′​TD′​=(1−xf′​xD′​xad′2​​)rD​xD′​​=(xD′​−xf′​xad′2​​)rD​1​=(xDl​+xad​1​+xl​1​+xfl​1​1​)rD​1​\n当直轴设置有阻尼绕组时，从以上对直轴运算电抗xd(p)x_d(p)xd​(p)导出的时间常数的准确计算式可看出，Td0′T_{d0}&#x27;Td0′​、Td0′′T_{d0}&#x27;&#x27;Td0′′​、Td′T_d&#x27;Td′​、Td′′T_d&#x27;&#x27;Td′′​四个时间常数均与励磁绕组和阻尼绕组两个绕组的时间常数有关，因为这两个绕组均放置在转子直轴上，二者之间存在类似于变压器一、二次绕组间的电磁能量传递关系。与变压器不同，同步电机中时间常数TDT_DTD​远小于TfT_fTf​，且TD′T_D&#x27;TD′​远小于Tf′T_f&#x27;Tf′​，因而可简化，简化后的等效电路见图2-9.\n\n其中，Td0′T_{d0}&#x27;Td0′​、Td′T_d&#x27;Td′​是电枢绕组分别为开路、短路时励磁绕组的时间常数，二者与阻尼绕组无关；而Td0′′T_{d0}&#x27;&#x27;Td0′′​、Td′′T_d&#x27;&#x27;Td′′​是励磁绕组短路，电枢绕组分别为开路、短路时直轴阻尼绕组的时间常数。\n为方便逆变换，可导出xd(p)x_d(p)xd​(p)的倒数形式为\n1xd(p)=1xd+(1xd′−1xd)Td′pTd′p+1+(1xd′′−1xd′)Td′′pTd′′p+1\\frac{1}{x_d(p)}=\\frac{1}{x_d}+(\\frac{1}{x_d&#x27;}-\\frac{1}{x_d})\\frac{T_d&#x27;p}{T_d&#x27;p+1}+(\\frac{1}{x_d&#x27;&#x27;}-\\frac{1}{x_d&#x27;})\\frac{T_d&#x27;&#x27;p}{T_d&#x27;&#x27;p+1}\nxd​(p)1​=xd​1​+(xd′​1​−xd​1​)Td′​p+1Td′​p​+(xd′′​1​−xd′​1​)Td′′​p+1Td′′​p​\n交轴运算电抗xq(p)x_q(p)xq​(p)的表达式亦可用时间常数表示为\nxq(p)=xq−xaq2prQ+xQp=xq(Tq′′p+1Tq0′′p+1)x_q(p)=x_q-\\frac{x_{aq}^2p}{r_Q+x_Qp}=x_q(\\frac{T_q&#x27;&#x27;p+1}{T_{q0}&#x27;&#x27;p+1})\nxq​(p)=xq​−rQ​+xQ​pxaq2​p​=xq​(Tq0′′​p+1Tq′′​p+1​)\n式中\n\nTq0′′T_{q0}&#x27;&#x27;Tq0′′​为交轴阻尼绕组本身的时间常数，Tq0′′=xQ/rQT_{q0}&#x27;&#x27;=x_Q/r_QTq0′′​=xQ​/rQ​\nTq′′T_q&#x27;&#x27;Tq′′​为考虑到交轴电枢绕组短路时，交轴阻尼绕组的时间常数，Tq′′=1rQ(xQl+xaqxl/(xaq+xl))T_q&#x27;&#x27;=\\frac{1}{r_Q}(x_{Ql}+x_{aq}x_l/(x_{aq}+x_l))Tq′′​=rQ​1​(xQl​+xaq​xl​/(xaq​+xl​))\n\nTq0′′T_{q0}&#x27;&#x27;Tq0′′​和Tq′′T_q&#x27;&#x27;Tq′′​所对应的等效电路如图2-10所示。\n\n为方便逆变换，可导出xq(p)x_q(p)xq​(p)的倒数形式为\n1xq(p)=1xq+(1xq′′−1xq)Tq′′p1+Tq′′p\\frac{1}{x_q(p)}=\\frac{1}{x_q}+(\\frac{1}{x_q&#x27;&#x27;}-\\frac{1}{x_q})\\frac{T_q&#x27;&#x27;p}{1+T_q&#x27;&#x27;p}\nxq​(p)1​=xq​1​+(xq′′​1​−xq​1​)1+Tq′′​pTq′′​p​\n 同步电机的等效电路\n上文已经通过电枢磁链ψd(p)\\psi_d(p)ψd​(p)、ψq(p)\\psi_q(p)ψq​(p)的运算方程式，导出了等效运算电路及相应的运算电抗，在时域中也可画出类似于变压器和感应电机的同步电机等效电路。为获得直轴上各绕组的等效电路，将标幺值表示的直轴磁链方程式代入电压方程式，有\n[uduf0]=p[xdxadxadxadxfxadxadxadxD][idifiD]+[ra000rf000rD][idifiD]+[−ωψq00]\\begin{bmatrix}\nu_d\\\\u_f\\\\0\n\\end{bmatrix}=p\n\\begin{bmatrix}\nx_d &amp; x_{ad} &amp; x_{ad} \\\\\nx_{ad} &amp; x_f &amp; x_{ad} \\\\\nx_{ad} &amp; x_{ad} &amp; x_D\n\\end{bmatrix}\n\\begin{bmatrix}\ni_d \\\\ i_f \\\\ i_D \n\\end{bmatrix}+\n\\begin{bmatrix}\nr_a &amp; 0 &amp; 0 \\\\\n0 &amp; r_f &amp; 0 \\\\\n0 &amp; 0 &amp; r_D \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\ni_d \\\\ i_f \\\\ i_D \n\\end{bmatrix}+\n\\begin{bmatrix}\n-\\omega \\psi_q \\\\ 0 \\\\ 0\n\\end{bmatrix}\n⎣⎢⎡​ud​uf​0​⎦⎥⎤​=p⎣⎢⎡​xd​xad​xad​​xad​xf​xad​​xad​xad​xD​​⎦⎥⎤​⎣⎢⎡​id​if​iD​​⎦⎥⎤​+⎣⎢⎡​ra​00​0rf​0​00rD​​⎦⎥⎤​⎣⎢⎡​id​if​iD​​⎦⎥⎤​+⎣⎢⎡​−ωψq​00​⎦⎥⎤​\n相应的直轴等效电路如图2-11所示。\n\n同理可列出交轴电压方程式为\n[uq0]=p[xqxaqxaqxQ][iqiQ]+[ra00rQ][iqiQ]+[ωψd0]\\begin{bmatrix}\nu_q \\\\ 0\n\\end{bmatrix}=p\n\\begin{bmatrix}\nx_q &amp; x_{aq} \\\\\nx_{aq} &amp; x_Q\n\\end{bmatrix}\n\\begin{bmatrix}\ni_q \\\\ i_Q\n\\end{bmatrix}+\n\\begin{bmatrix}\nr_a &amp; 0 \\\\\n0 &amp; r_Q \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\ni_q \\\\ i_Q\n\\end{bmatrix}+\n\\begin{bmatrix}\n\\omega \\psi_d \\\\ 0\n\\end{bmatrix}\n[uq​0​]=p[xq​xaq​​xaq​xQ​​][iq​iQ​​]+[ra​0​0rQ​​][iq​iQ​​]+[ωψd​0​]\n相应的交轴等效电路如图2-12所示。\n\n显然，方程式与等效电路图是对应的，从方程式可画出等效电路，反过来，根据等效电路图，利用基尔霍夫电压定律也可写出各绕组回路的电压方程式。\n根据前面分析的结果，分析隐极同步电机时，只要令上面等效电路中xad=xaqx_{ad}=x_{aq}xad​=xaq​，即可使用；分析感应电机时，再将励磁回路取消即可。\n下面就图2-11、2-12所示的同步电机等效电路图与通常电机学中感应电机等效电路图的异同比较如下：\n\n\n同步电机等效电路是根据各变量瞬时值写出的电压方程式画出的，可以研究瞬态和稳态问题。通常电机学中感应电机等效电路是根据求解正弦稳态电路的相量方程式画出的，只能求解正弦稳态问题。\n\n\n在频率折算上，稳态感应电机的等效电路是将旋转的转子绕组通过频率折算,把实际转子绕组的频率由f2=sf1f_2=sf_1f2​=sf1​转换为定子绕组频率f1f_1f1​，而同步电机的等效电路是将静止的定子绕组轴线通过坐标变换变为与转子同步旋转的d、q两相绕组轴线，亦即将电枢绕组中频率为f1f_1f1​的交流量转换为频率为零的直流量。\n\n\n 同步电机的功率及电磁转矩\n有名值表示三相同步电机电枢端的瞬时输入功率为\nP=uaia+ubib+ucicP=u_ai_a+u_bi_b+u_ci_c\nP=ua​ia​+ub​ib​+uc​ic​\n标幺值系统中功率基值为\nPb=3UNIN=32UbIbP_b=3U_NI_N=\\frac{3}{2}U_bI_b\nPb​=3UN​IN​=23​Ub​Ib​\n因此标幺值表示时电机电枢端瞬时三相输入功率为\nP∗=23(ua∗ia∗+ub∗ib∗+uc∗ic∗)P^*=\\frac{2}{3}(u_a^*i_a^*+u_b^*i_b^*+u_c^*i_c^*)\nP∗=32​(ua∗​ia∗​+ub∗​ib∗​+uc∗​ic∗​)\n对上式中变量进行Park变换后，dq0坐标系中三相输入功率的标幺值为\nP∗=ud∗id∗+uq∗iq∗+2u0∗i0∗P^*=u_d^*i_d^*+u_q^*i_q^*+2u_0^*i_0^*\nP∗=ud∗​id∗​+uq∗​iq∗​+2u0∗​i0∗​\ndq0坐标系下因定子绕组由原先的“静止绕组”转化为“伪静止绕组”，绕组电感系数由时变系数转为常系数，因而先前在相坐标系统中导出的电磁转矩公式已经不再适用。下面以能量守恒原理为基础重新推导适用于这种绕组的电磁转矩表达式。\n由于零轴电流所产生的气隙合成磁场为零，仅产生与电枢绕组交链的漏磁场，因而不参与电磁功率的转换，故在推导电磁转矩时可以不考虑零轴分量。\n由dq0坐标系中三相输入功率的标幺值可知，零轴对应的输入功率为2u0i02u_0i_02u0​i0​，当不考虑电枢零轴分量时，从各端点输入的电功率瞬时值的总和为\nI′TU′=udid+uqiq+ufifI&#x27;^TU&#x27;=u_di_d+u_qi_q+u_fi_f\nI′TU′=ud​id​+uq​iq​+uf​if​\n式中\nI′T=[idiqifiDiQ]I&#x27;^T=\n\\begin{bmatrix}\ni_d &amp; i_q &amp; i_f &amp; i_D &amp; i_Q\n\\end{bmatrix}\nI′T=[id​​iq​​if​​iD​​iQ​​]\nU′=[uduquf00]TU&#x27;= \\begin{bmatrix}\nu_d &amp; u_q &amp; u_f &amp; 0 &amp; 0\n\\end{bmatrix}^T\nU′=[ud​​uq​​uf​​0​0​]T\n根据标幺值系统下电压方程式，可导出不考虑电枢零轴分量的电压方程式为\nU′=L′pI′+ωG′I′+R′I′U&#x27;=L&#x27;pI&#x27;+\\omega G&#x27;I&#x27;+R&#x27;I&#x27;\nU′=L′pI′+ωG′I′+R′I′\n式中’上标表示该矩阵未考虑零轴分量，其可以分别从相应的原始矩阵中除去零轴分量的第三行以及第三列得到。如该矩阵方程左乘以电流的转置矩阵I′TI&#x27;^TI′T，则功率方程为\nI′TU′=I′TL′pI′+I′TωG′I′+I′TR′I′I&#x27;^TU&#x27;=I&#x27;^TL&#x27;pI&#x27;+I&#x27;^T\\omega G&#x27;I&#x27;+I&#x27;^TR&#x27;I&#x27;\nI′TU′=I′TL′pI′+I′TωG′I′+I′TR′I′\n方程的左边是从各端点输入的总电功率，右边由二项组成：第一项为电流和磁链变化率的乘积，即I′TL′pI′=I′TpΨ′I&#x27;^TL&#x27;pI&#x27;=I&#x27;^Tp\\Psi&#x27;I′TL′pI′=I′TpΨ′，其代表了定、转子绕组储存磁场能量的变化率；第三项I′TR′I′I&#x27;^TR&#x27;I&#x27;I′TR′I′代表了定、转子绕组的电阻损耗。根据功平衡关系可知，第二项I′TωG′I′I&#x27;^T\\omega G&#x27;I&#x27;I′TωG′I′是跨过气隙由电功率转为机械功率的电磁功率。用转速ω\\omegaω除它，即得到用标么值表示的电磁转矩，即\nTem=I′TωG′I′ω=I′TG′I′T_{em}=\\frac{I&#x27;^T\\omega G&#x27;I&#x27;}{\\omega}=I&#x27;^T G&#x27;I&#x27;\nTem​=ωI′TωG′I′​=I′TG′I′\n矩阵GGG中第三行和第三列元素均为0，所以有\nI′TG′I′=ITGII&#x27;^T G&#x27;I&#x27;=I^TGI\nI′TG′I′=ITGI\n即\nTem=ITGIT_{em}=I^TGI\nTem​=ITGI\n该式适用于“伪静止绕组”电机。将电流矩阵III和矩阵GGG代入上式，可得三相同步电机的电磁转矩为\nTem=iqψd−idψqT_{em}=i_q\\psi_d-i_d\\psi_q\nTem​=iq​ψd​−id​ψq​\n","categories":["电气工程"]},{"title":"【电机瞬态分析】交流电机综合动态方程式","url":"/2024/08/02/%E3%80%90%E7%94%B5%E6%9C%BA%E7%9E%AC%E6%80%81%E5%88%86%E6%9E%90%E3%80%91%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E7%BB%BC%E5%90%88%E5%8A%A8%E6%80%81%E6%96%B9%E7%A8%8B%E5%BC%8F/","content":" 简介\n在实际运行中，不论电机受到电磁方面或是机械方面的扰动，都可以使电机的转矩失去平衡，导致发生机电过渡过程。在这种情况下，既有电机的电流、磁链、电磁转矩等电磁量的变化，又有电机的转速、机械转矩等机械量的变化，两者是相互影响的。之前几个小节所导出的电压方程式和转子运动方程式，正确地反映了电机的电磁、机械等量的内在联系和相互制约的关系。因此，一般情况下应该联立求解电压方程式和转子运动方程式。\n当转速不是恒值而是变量时，电压方程式中的ωψ\\omega \\psiωψ为两个变量的乘积，转矩方程式中电磁转矩Tem=iqψd−idψqT_{em}=i_q\\psi_d-i_d\\psi_qTem​=iq​ψd​−id​ψq​，亦是两个变量的乘积，因此，转换为d、q、0坐标系统的同步电机电压方程式和转矩方程式，均为非线性微分方程式。一般来说，无法采用解析法而需采用数值法求解。\n将凸极同步电机的电压方程式和转子运动方程式合并，可得凸极同步电机的动态方程式。以该方程式为基础，根据隐极同步电机和感应电机的实际情况做适当简化，可分别得到他们各自的动态方程式。\n 凸级同步电机动态方程式\n令机械阻尼转矩为\nTD=kpdθdt=kDωT_D=k_p\\frac{d\\theta}{dt}=k_D \\omegaTD​=kp​dtdθ​=kD​ω\n式中kDk_DkD​为机械阻尼系数。\n则转子运动方程式为\nHdωdt=Tem−TL−TD=iqψd−idψq−TL−kDω=xdiqid+xadiqif+xadiqiD−xqidiq−xaqidiQ−TL−kDωH\\frac{d\\omega}{dt}=T_{em}-T_L-T_D=i_q\\psi_d-i_d\\psi_q-T_L-k_D\\omega\\\\\n=x_di_qi_d+x_{ad}i_qi_f+x_{ad}i_qi_D-x_qi_di_q-x_{aq}i_di_Q-T_L-k_D\\omega\nHdtdω​=Tem​−TL​−TD​=iq​ψd​−id​ψq​−TL​−kD​ω=xd​iq​id​+xad​iq​if​+xad​iq​iD​−xq​id​iq​−xaq​id​iQ​−TL​−kD​ω\n合并电压方程式和上式（转矩方程式），可得凸级同步电机的动态方程为\n[uduqu0uf00TL0]=[xd00xadxad0000xq000xaq0000x000000xad00xfxad000xad00xadxD0000xaq000xQ00000000−H000000001]p[idiqi0ifiDiQωθ]+[rs−ωxq000−ωxaq00ωxdrs0ωxadωxad00000rs00000000rf00000000rD00000000rQ00xdiq−xqid0xadiqxadiq−xaqid−kD0000000−10][idiqi0ifiDiQωθ]\\begin{bmatrix}\nu_d \\\\ u_q \\\\ u_0 \\\\ u_f \\\\ 0 \\\\ 0 \\\\T_L \\\\ 0\n\\end{bmatrix}=\n\\begin{bmatrix}\nx_d &amp; 0 &amp; 0 &amp; x_{ad} &amp; x_{ad} &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; x_q &amp; 0 &amp; 0 &amp; 0 &amp; x_{aq} &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; x_0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\nx_{ad} &amp; 0 &amp; 0 &amp; x_f &amp; x_{ad} &amp; 0 &amp; 0 &amp; 0\\\\\nx_{ad} &amp; 0 &amp; 0 &amp; x_{ad} &amp; x_D &amp; 0 &amp; 0 &amp; 0\\\\\n0 &amp; x_{aq} &amp; 0 &amp; 0 &amp; 0 &amp; x_Q &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -H &amp; 0\\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\\\\n\\end{bmatrix}p\n\\begin{bmatrix}\ni_d \\\\ i_q \\\\ i_0 \\\\ i_f \\\\ i_D\\\\ i_Q\\\\ \\omega\\\\\\theta\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nr_s &amp; -\\omega x_q &amp; 0 &amp; 0 &amp; 0 &amp; -\\omega x_{aq} &amp; 0 &amp; 0 \\\\\n\\omega x_d &amp; r_s &amp; 0 &amp; \\omega x_{ad} &amp; \\omega x_{ad} &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; r_s &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\\n0 &amp; 0 &amp; 0 &amp; r_f &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; r_D &amp; 0 &amp; 0 &amp; 0\\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; r_Q &amp; 0 &amp; 0\\\\\nx_di_q &amp; -x_qi_d &amp; 0 &amp; x_{ad}i_q &amp; x_{ad}i_q &amp; -x_{aq}i_d &amp; -k_D &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\ni_d \\\\ i_q \\\\ i_0 \\\\ i_f \\\\ i_D\\\\ i_Q\\\\ \\omega\\\\\\theta\n\\end{bmatrix}\n⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​ud​uq​u0​uf​00TL​0​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​xd​00xad​xad​000​0xq​000xaq​00​00x0​00000​xad​00xf​xad​000​xad​00xad​xD​000​0xaq​000xQ​00​000000−H0​00000001​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​p⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​id​iq​i0​if​iD​iQ​ωθ​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​+⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​rs​ωxd​0000xd​iq​0​−ωxq​rs​0000−xq​id​0​00rs​00000​0ωxad​0rf​00xad​iq​0​0ωxad​00rD​0xad​iq​0​−ωxaq​0000rQ​−xaq​id​0​000000−kD​−1​00000000​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​id​iq​i0​if​iD​iQ​ωθ​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​\n显然这是一组非线性微分方程，直接求解较为困难,求解实际问题时，可根据求解问题的条件，从工程角度出发，做一些适当的简化。\n当转子转速ω\\omegaω为恒值，且己知时，对这类问题的求解就无需求解转子运动方程式，只需单独求解电压方程式，这时方程式是一组线性常系数微分方程式，可用解析法求解。对于变速问题，由于ω\\omegaω是变量，必须联立求解电压方程式和转子运动方程式，这时方程式是一组非线性微分方程式。一般情况下，只能将上式改写为状态方程式，采用数值法求近似解。\n 隐级同步电机动态方程式\n隐级同步电机为柱形转子，直轴与交轴磁导相同，所以有\nxad=xaq,xd=xqx_{ad}=x_{aq},x_d=x_q\nxad​=xaq​,xd​=xq​\n按照此关系对凸级同步电机动态方程中的参数作修改后即可得到隐级同步电机的动态方程式。\n 感应电机动态方程式\n感应电机中定子三相绕组为对称，转子为圆柱形，且无励磁绕组，而转子不论是绕线型还是鼠笼型都为对称绕组，所以感应电机中定子、转子的磁路和电路均为对称，因而直轴和交轴电枢反应电抗相等，即xad=xaq=xmx_{ad}=x_{aq}=x_mxad​=xaq​=xm​。电枢绕组中xd=xq=xss=xsl+xmx_d=x_q=x_{ss}=x_{sl}+x_mxd​=xq​=xss​=xsl​+xm​，原转子绕组中直轴和交轴阻尼绕组参数应该为现转子绕组的相应电抗xrrx_{rr}xrr​和电阻rrr_rrr​，即\nxD=xQ=xrr=xrl+xm,rD=rQ=rrx_D=x_Q=x_{rr}=x_{rl}+x_m,r_D=r_Q=r_r\nxD​=xQ​=xrr​=xrl​+xm​,rD​=rQ​=rr​\n将参数代入原凸级同步电机的动态方程式，并将式中的第四行、第四列去掉，转子直轴阻尼绕组电流iDi_DiD​改为转子直轴绕组电流idri_{dr}idr​，交轴阻尼绕组电流iQi_QiQ​改为转子交轴绕组电流iqri_{qr}iqr​，即可得到感应电机动态方程式。\n由于感应电机定子、转子磁路、电路均对称，转子位置改变时磁路的磁导不变，故坐标变换时，只要绕组轴线相对静止，就可以使电感系数变为常系数，这样绕组轴线既可选在定子方面也可选在转子方面。\n","categories":["电气工程"]},{"title":"【电机瞬态分析】凸级同步电机对称稳态运行分析","url":"/2024/08/05/%E3%80%90%E7%94%B5%E6%9C%BA%E7%9E%AC%E6%80%81%E5%88%86%E6%9E%90%E3%80%91%E5%87%B8%E7%BA%A7%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA%E5%AF%B9%E7%A7%B0%E7%A8%B3%E6%80%81%E8%BF%90%E8%A1%8C%E5%88%86%E6%9E%90/","content":"电机学中已经详细讨论了同步电机对称稳态运行问题，这里用之前导出的d、q、0坐标系统的电压方程式，对这一运行方式进行分析，很容易求得稳态运行时的有功功率、无功功率及电磁转矩。\n 空载运行\n空载稳态运行时，显然同步电机的转速只能为同步转速，即角速度（标幺值）ω=1\\omega=1ω=1；励磁绕组端外加直流电压为ufu_fuf​，电枢绕组开路，三相电枢绕组电流iai_aia​、ibi_bib​、ici_cic​均为零，转换为d、q、0坐标系统后，idi_did​、iqi_qiq​、i0i_0i0​亦都为零。由于转速恒定，不存在转矩过渡过程，故该情况下无需求解转矩方程式，只需求解电压方程式，即可求得发电机空载运行时由励磁电流、磁链在发电机电枢绕组中产生的空载电压。\n首先，求出励磁电流ifi_fif​。根据标幺值形式下的同步电机电压方程式\nU∗=L∗pI∗+ω∗G∗I∗+R∗I∗U^*=L^*pI^*+\\omega^*G^*I^*+R^*I^*\nU∗=L∗pI∗+ω∗G∗I∗+R∗I∗\n式中\nU∗=[Udq0∗UfDQ∗]TU^*=[U_{dq0}^* \\quad U_{fDQ}^*]^T\\\\\nU∗=[Udq0∗​UfDQ∗​]T\nI∗=[Idq0∗IfDQ∗]TI^*=[I_{dq0}^* \\quad I_{fDQ}^*]^T\nI∗=[Idq0∗​IfDQ∗​]T\nR∗=[Rabc∗00RfDQ∗]R^*=\n\\begin{bmatrix}\nR_{abc}^* &amp; 0\\\\\n0 &amp; R_{fDQ}^*\n\\end{bmatrix}\nR∗=[Rabc∗​0​0RfDQ∗​​]\nL∗=[xd∗00xad∗xad∗00xq∗000xaq∗00x0∗000xad∗00xf∗xad∗0xad∗00xad∗xD∗00xaq∗000xQ∗]G∗=[0−xq∗000−xaq∗xd∗00xad∗xad∗0000000000000000000000000]\\begin{array}{c}\nL^{*}=\\left[\\begin{array}{cccccc}\nx_{\\mathrm{d}}^* &amp; 0 &amp; 0 &amp; x_{\\mathrm{ad}}^{*} &amp; x_{\\mathrm{ad}}^{*} &amp; 0 \\\\\n0 &amp; x_{\\mathrm{q}}^{*} &amp; 0 &amp; 0 &amp; 0 &amp; x_{a q}^{*} \\\\\n0 &amp; 0 &amp; x_{0}^{*} &amp; 0 &amp; 0 &amp; 0 \\\\\nx_{\\mathrm{ad}}^{*} &amp; 0 &amp; 0 &amp; x_{\\mathrm{f}}^{*} &amp; x_{a d}^{*} &amp; 0 \\\\\nx_{a d}^{*} &amp; 0 &amp; 0 &amp; x_{ad}^{*} &amp; x_{\\mathrm{D}}^{*} &amp; 0 \\\\\n0 &amp; x_{\\mathrm{aq}}^{*} &amp; 0 &amp; 0 &amp; 0 &amp; x_{\\mathrm{Q}}^{*}\n\\end{array}\\right] \n\n\\\\\n\nG^{*}=\\left[\\begin{array}{cccccc}\n0 &amp; -x_{\\mathrm{q}}^{*} &amp; 0 &amp; 0 &amp; 0 &amp; -x_{a q}^{*} \\\\\nx_{d}^{*} &amp; 0 &amp; 0 &amp; x_{\\mathrm{ad}}^{*} &amp; x_{\\mathrm{ad}}^{*} &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\n\\end{array}\\right]\n\\end{array}\nL∗=⎣⎢⎢⎢⎢⎢⎢⎢⎡​xd∗​00xad∗​xad∗​0​0xq∗​000xaq∗​​00x0∗​000​xad∗​00xf∗​xad∗​0​xad∗​00xad∗​xD∗​0​0xaq∗​000xQ∗​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​G∗=⎣⎢⎢⎢⎢⎢⎢⎢⎡​0xd∗​0000​−xq∗​00000​000000​0xad∗​0000​0xad∗​0000​−xaq∗​00000​⎦⎥⎥⎥⎥⎥⎥⎥⎤​​\n考虑idi_did​、iqi_qiq​为零，可得\nuf=p(xfif+xadiD)+rfif0=p(xadif+xDiD)+rDiD0=pxQiQ+rQiQu_f=p(x_fi_f+x_{ad}i_D) + r_fi_f \\\\\n0=p(x_{ad}i_f+x_Di_D)+r_Di_D \\\\\n0=px_Qi_Q+r_Qi_Q\nuf​=p(xf​if​+xad​iD​)+rf​if​0=p(xad​if​+xD​iD​)+rD​iD​0=pxQ​iQ​+rQ​iQ​\n励磁绕组外加电源为直流电压，且现讨论的是稳态运行问题，所以励磁绕组电流为恒定直流，转子各绕组交链的磁链也为恒指，变压器电动势pψp\\psipψ为零，这时励磁绕组的电压方程式为\nuf=rfifu_f=r_fi_f\nuf​=rf​if​\n励磁绕组的电流为\nif=ufrfi_f = \\frac{u_f}{r_f}\nif​=rf​uf​​\n阻尼绕组为短路回路，无端口电压，此时与阻尼绕组交链的磁链为恒值，无变压器电动势，显然阻尼绕组内电流为零，即\niD=iQ=0i_D=i_Q=0\niD​=iQ​=0\n其次，解出空载时电枢绕组的端电压udu_dud​、uqu_quq​，根据同步电机电压方程式中电枢绕组部分，有\nud=pψd−ωψq+raiduq=pψq+ωψd+raiqu_d=p\\psi_d-\\omega\\psi_q+r_ai_d\\\\\nu_q=p\\psi_q+\\omega\\psi_d+r_ai_q\nud​=pψd​−ωψq​+ra​id​uq​=pψq​+ωψd​+ra​iq​\n上式右边第一项pψdp\\psi_dpψd​、pψqp\\psi_qpψq​为零，由于电枢绕组电流idi_did​、iqi_qiq​和阻尼绕组电流都为零，故ψd=xadif=\\psi_d=x_{ad}i_f=ψd​=xad​if​=恒值，ψq=0\\psi_q=0ψq​=0，故其变化率pψp\\psipψ也为零，第三项电枢电流引起的电阻压降亦为零。考虑转子角速度ω=1\\omega=1ω=1，可将上式改写为\nud=0uq=ψd=xadif=xadufif=Emu_d = 0 \\\\\nu_q = \\psi_d = x_{ad}i_f = x_{ad}\\frac{u_f}{i_f}=E_m\nud​=0uq​=ψd​=xad​if​=xad​if​uf​​=Em​\n式中，EmE_mEm​为空载电动势幅值。uq=Emu_q =E_muq​=Em​是一个重要的关系。\n最后，将电枢绕组在dq0坐标系统下得到的空载电压udu_dud​、uqu_quq​返回到abc坐标系统，稳态运行时，可任意选择时间的起始点，一般取d轴和a轴重合的瞬间作为时间起点，即θ0=0\\theta_0=0θ0​=0，这样就有θ=ωt+θ0=t\\theta=\\omega t + \\theta_0 = tθ=ωt+θ0​=t，将udu_dud​、uqu_quq​逆变换后可得三相空载电压为\nua=udcos⁡θ−uqsin⁡θ=−Emsin⁡tub=udcos⁡(θ−120°)−uqsin⁡(θ−120°)=−Emsin⁡(t−120°)uc=udcos⁡(θ+120°)−uqsin⁡(θ+120°)=−Emsin⁡(t+120°)u_a = u_d \\cos\\theta - u_q\\sin\\theta = -E_m\\sin t \\\\\nu_b = u_d \\cos (\\theta - 120 \\degree) - u_q \\sin (\\theta - 120 \\degree) = -E_m\\sin (t-120 \\degree)\\\\\nu_c = u_d \\cos (\\theta + 120 \\degree) - u_q \\sin (\\theta + 120 \\degree)=-E_m\\sin (t+120 \\degree)\nua​=ud​cosθ−uq​sinθ=−Em​sintub​=ud​cos(θ−120°)−uq​sin(θ−120°)=−Em​sin(t−120°)uc​=ud​cos(θ+120°)−uq​sin(θ+120°)=−Em​sin(t+120°)\n综合上式可以看出，稳态运行时，在abc坐标系统中，电枢绕组的空载电压为按额定频率变换的正弦量，而在dq0坐标系统中则变为恒定的直流量。由于绕组轴线的变换，使绕组电动势的频率也发生了变换，这也可以从电机变换前后的物理模型中清楚的看到。\n 负载运行\n同步电机带负载运行时，端电压与空载电动势之间会形成一定的相位差。假定端电压滞后于空载电动势的相角为δ\\deltaδ，即为功角。则电机端电压的瞬时值可导出为\n[uaubuc]=−Um[sin⁡(t−δ)sin⁡(t−δ−120°)sin⁡(t−δ+120°)]\\begin{bmatrix}\nu_a \\\\ u_b \\\\ u_c\n\\end{bmatrix}=\n-U_m\n\\begin{bmatrix}\n\\sin (t - \\delta) \\\\\n\\sin (t - \\delta - 120 \\degree) \\\\\n\\sin (t - \\delta + 120 \\degree) \n\\end{bmatrix}\n⎣⎢⎡​ua​ub​uc​​⎦⎥⎤​=−Um​⎣⎢⎡​sin(t−δ)sin(t−δ−120°)sin(t−δ+120°)​⎦⎥⎤​\n式中，UmU_mUm​为同步电机端电压幅值。\n将abc坐标系统的电枢绕组电压变换至dq0坐标系统，则udu_dud​、uqu_quq​、u0u_0u0​为\n[uduqu0]=C[uaubuc]=[Umsin⁡δUmcos⁡δ0]\\begin{bmatrix}\nu_d \\\\ u_q \\\\ u_0\n\\end{bmatrix}=C\n\\begin{bmatrix}\nu_a \\\\ u_b \\\\ u_c\n\\end{bmatrix}=\n\\begin{bmatrix}\nU_m \\sin \\delta \\\\\nU_m \\cos \\delta \\\\\n0 \\\\\n\\end{bmatrix}\n⎣⎢⎡​ud​uq​u0​​⎦⎥⎤​=C⎣⎢⎡​ua​ub​uc​​⎦⎥⎤​=⎣⎢⎡​Um​sinδUm​cosδ0​⎦⎥⎤​\n稳态运行时，端电压幅值UmU_mUm​及功角δ\\deltaδ皆为恒值，所以udu_dud​和uqu_quq​亦为恒值。同样地，对称稳态运行时，三相电流iai_aia​、ibi_bib​、ici_cic​以及电枢绕组电流idi_did​、iqi_qiq​都为恒定直流且零序电流i0i_0i0​为零。根据同步电机磁链方程式，可求得d、q绕组的磁链为\nψd=xdid+xadif=xdid+xadufrf=xdid+Emψq=xqiq\\psi_d = x_di_d + x_{ad}i_f = x_di_d + x_{ad}\\frac{u_f}{r_f} = x_di_d + E_m \\\\\n\\psi_q = x_q i_q\nψd​=xd​id​+xad​if​=xd​id​+xad​rf​uf​​=xd​id​+Em​ψq​=xq​iq​\n根据上式，当电流idi_did​、iqi_qiq​为恒值时，磁链亦为恒值。将上式代入电压方程式，并考虑同步转速下ω=1\\omega = 1ω=1，有\nud=−ψq+raid=−xqiq+rsiduq=ψd+raiq=Em+xdid+rsiqu_d = -\\psi_q + r_ai_d = -x_qi_q + r_si_d \\\\\nu_q = \\psi_d + r_ai_q = E_m + x_di_d + r_si_q \\\\\nud​=−ψq​+ra​id​=−xq​iq​+rs​id​uq​=ψd​+ra​iq​=Em​+xd​id​+rs​iq​\n此处有rs=rar_s=r_ars​=ra​。三相对称绕组中每一相的电阻都是一致的，为表示方便，下面将用rsr_srs​代替定子电阻。\n当已知电压udu_dud​、uqu_quq​、ufu_fuf​及阻抗参数时，可解出电枢绕组电流idi_did​、iqi_qiq​如下\nid=rsud−xq(Em−uq)rs2+xdxq=rsUmsin⁡δ−xq(Em−Umcos⁡δ)rs2+xdxqiq=−xdud−rs(Em−uq)rs2+xdxq=−xdumsin⁡δ−rs(Em−Umcos⁡δ)rs2+xdxqi_d = \\frac{r_su_d-x_q(E_m-u_q)}{r_s^2+x_dx_q}=\\frac{r_sU_m\\sin\\delta-x_q(E_m-U_m\\cos\\delta)}{r_s^2+x_dx_q} \\\\\ni_q = \\frac{-x_du_d-r_s(E_m-u_q)}{r_s^2+x_dx_q}=\\frac{-x_du_m\\sin\\delta-r_s(E_m-U_m\\cos\\delta)}{r_s^2+x_dx_q}\nid​=rs2​+xd​xq​rs​ud​−xq​(Em​−uq​)​=rs2​+xd​xq​rs​Um​sinδ−xq​(Em​−Um​cosδ)​iq​=rs2​+xd​xq​−xd​ud​−rs​(Em​−uq​)​=rs2​+xd​xq​−xd​um​sinδ−rs​(Em​−Um​cosδ)​\n实际中，同步电机定子电阻rsr_srs​的值远小于电抗xdx_dxd​和xqx_qxq​的值。当略去定子电阻rsr_srs​时，上式可化简为\nid=−Em−uqxd=−Em−Umcos⁡δxdiq=−udxq=−Umsin⁡δxqi_d = -\\frac{E_m-u_q}{x_d}=-\\frac{E_m-U_m\\cos\\delta}{x_d} \\\\\ni_q = - \\frac{u_d}{x_q} = - \\frac{U_m\\sin\\delta}{x_q}\nid​=−xd​Em​−uq​​=−xd​Em​−Um​cosδ​iq​=−xq​ud​​=−xq​Um​sinδ​\n从上面求解过程也可看出，当三相对称稳态运行时，变换到d、q、0坐标系统下的电枢绕组电压、电流均为直流。因此，将原三相稳态交流电路的问题转变成了稳态直流电路的问题，即将求解复代数方程式转变为求解实代数方程式，使计算大为简化，显示了dq0坐标系统在解三相对称稳态运行问题时的优越性。\n同步电机对称稳态运行时的磁链、电流、电压求出后，就可进一步分析同步发电机的有功功率、无功功率与电磁转矩。\n 有功功率\n同步发电机电枢端的有功功率，只需将之前求出的电压和电流代入三相功率标幺值公式P=udid+uqiq+2u0i0P=u_di_d+u_qi_q+2u_0i_0P=ud​id​+uq​iq​+2u0​i0​中即可得到，此时考虑定子电阻rsr_srs​，为\nP=udid+uqiq=Umsin⁡δrsUmsin⁡δ−xq(Em−Umcos⁡δ)rs2+xdxq+Umcos⁡δ−xdUmsin⁡δ−rs(Em−Umcos⁡δ)rs2+xdxq=−1rs2+xdxq[−rsUm2+EmUm(xqsin⁡δ+rscos⁡δ)+Um22(xd−xq)sin⁡2δ]P=u_di_d+u_qi_q \\\\\n= U_m\\sin\\delta\\frac{r_sU_m\\sin\\delta-x_q(E_m-U_m\\cos\\delta)}{r_s^2+x_dx_q}+U_m\\cos\\delta\\frac{-x_dU_m\\sin\\delta-r_s(E_m-U_m\\cos\\delta)}{r_s^2+x_dx_q}\\\\\n= \\frac{-1}{r_s^2+x_dx_q}[-r_sU_m^2+E_mU_m(x_q\\sin\\delta+r_s\\cos\\delta)+\\frac{U_m^2}{2}(x_d-x_q)\\sin2\\delta]\nP=ud​id​+uq​iq​=Um​sinδrs2​+xd​xq​rs​Um​sinδ−xq​(Em​−Um​cosδ)​+Um​cosδrs2​+xd​xq​−xd​Um​sinδ−rs​(Em​−Um​cosδ)​=rs2​+xd​xq​−1​[−rs​Um2​+Em​Um​(xq​sinδ+rs​cosδ)+2Um2​​(xd​−xq​)sin2δ]\n若略去rsr_srs​，则\nP=−[EmUmxdsin⁡δ+Um22(1xq−1xd)sin⁡2δ]P=-[\\frac{E_mU_m}{x_d}\\sin\\delta+\\frac{U_m^2}{2}(\\frac{1}{x_q}-\\frac{1}{x_d})\\sin2\\delta]\nP=−[xd​Em​Um​​sinδ+2Um2​​(xq​1​−xd​1​)sin2δ]\n对于隐级同步电机，因其xd=xqx_d=x_qxd​=xq​，则有\nP=−EmUmxdsin⁡δP=-\\frac{E_mU_m}{x_d}\\sin\\delta\nP=−xd​Em​Um​​sinδ\n从上面公式可看出，有功功率前面均有负号，这是由于按电动机惯例选取的正方向。因此，负功率意味着电枢端不是输入而是输出电功率，即运行在发电机状态。这也说明正方向的假设是可以人为选定的。按电动机惯例选取正方向，同样可以分析发电机的运行状态。本文中功率基值为三相电机的额定容量，即Pb=3UNINP_b=3U_NI_NPb​=3UN​IN​，因此，用标么值表示的功率在形式上与电机学中不一致，但返回到有名值后就无差别了。\n 无功功率\n电机的视在功率SSS与有功功率PPP和无功功率QQQ的关系为\nQ=S2−P2Q= \\sqrt {S^2-P^2}\nQ=S2−P2​\n式中SSS为标幺值。\n三相视在功率的有名值为3UI3UI3UI，则有\nS=3UIPb=32UmIm32UbIb=UmImS=\\frac{3UI}{P_b}=\\frac{\\frac{3}{2}U_mI_m}{\\frac{3}{2}U_bI_b}=U_mI_m\nS=Pb​3UI​=23​Ub​Ib​23​Um​Im​​=Um​Im​\n式中UmU_mUm​和ImI_mIm​分别为用标幺值表示的电枢绕组端电压和电流的幅值，它们与d、q轴电枢绕组的端电压和电流的关系分别为\nUm=ud2+uq2,Im=id2+iq2U_m=\\sqrt{u_d^2+u_q^2},I_m=\\sqrt{i_d^2+i_q^2}\nUm​=ud2​+uq2​​,Im​=id2​+iq2​​\n将视在功率SSS与有功功率PPP代入上式，可得无功功率QQQ的标幺值为\nQ=(ud2+uq2)(id2+iq2)−(udid+uqiq)2=uqid−udiqQ=\\sqrt{(u_d^2+u_q^2)(i_d^2+i_q^2)-(u_di_d+u_qi_q)^2}=u_qi_d-u_di_q\nQ=(ud2​+uq2​)(id2​+iq2​)−(ud​id​+uq​iq​)2​=uq​id​−ud​iq​\n代入电压和电流，有\nQ=−1rs2+xdxq[EmUm(xqcos⁡δ−rssin⁡δ)−Um22(xd+xq)+Um22(xd−xq)sin⁡2δ]Q=\\frac{-1}{r_s^2+x_dx_q}[E_mU_m(x_q\\cos\\delta-r_s\\sin\\delta)-\\frac{U_m^2}{2}(x_d+x_q)+\\frac{U_m^2}{2}(x_d-x_q)\\sin2\\delta]\nQ=rs2​+xd​xq​−1​[Em​Um​(xq​cosδ−rs​sinδ)−2Um2​​(xd​+xq​)+2Um2​​(xd​−xq​)sin2δ]\n略去rsr_srs​时，有\nQ=−[EmUmxdcos⁡δ−Um22(1xq+1xd)+Um22(1xq−1xd)sin⁡2δ]Q=-[\\frac{E_mU_m}{x_d}\\cos\\delta-\\frac{U_m^2}{2}(\\frac{1}{x_q}+\\frac{1}{x_d})+\\frac{U_m^2}{2}(\\frac{1}{x_q}-\\frac{1}{x_d})\\sin2\\delta]\nQ=−[xd​Em​Um​​cosδ−2Um2​​(xq​1​+xd​1​)+2Um2​​(xq​1​−xd​1​)sin2δ]\n若为隐级同步电机，因xd=xqx_d=x_qxd​=xq​，则\nQ=−(EmUmxdcos⁡δ−Um2xd)Q=-(\\frac{E_mU_m}{x_d}\\cos\\delta-\\frac{U_m^2}{x_d})\nQ=−(xd​Em​Um​​cosδ−xd​Um2​​)\n 电磁转矩\n将磁链式和电流式代入电磁转矩公式，有\nTem=iqψd−idψq=−rs(rs2+xq2)Em2(rs2+xdxq)2−EmUm(rs2+xdxq)2×[(rsxdsin⁡δ−xq2cos⁡δ)2rs+(xdxq−rs2)(rscos⁡δ+xqsin⁡δ)]−(xd−xq)Um2(rs2+xdxq)2[(xdsin⁡2δ−xqcos⁡2δ)rs+12(xdxq−rs2)sin⁡2δ]T_{em}=i_q\\psi_d-i_d\\psi_q=-\\frac{r_s(r_s^2+x_q^2)E_m^2}{(r_s^2+x_dx_q)^2}-\\frac{E_mU_m}{(r_s^2+x_dx_q)^2} \\\\\n\\times [(r_sx_d\\sin\\delta-x_q^2\\cos\\delta)2r_s+(x_dx_q-r_s^2)(r_s\\cos\\delta+x_q\\sin\\delta)] \\\\\n- \\frac{(x_d-x_q)U_m^2}{(r_s^2+x_dx_q)^2}[(x_d\\sin^2\\delta-x_q\\cos^2\\delta)r_s+\\frac{1}{2}(x_dx_q-r_s^2)\\sin2\\delta]\nTem​=iq​ψd​−id​ψq​=−(rs2​+xd​xq​)2rs​(rs2​+xq2​)Em2​​−(rs2​+xd​xq​)2Em​Um​​×[(rs​xd​sinδ−xq2​cosδ)2rs​+(xd​xq​−rs2​)(rs​cosδ+xq​sinδ)]−(rs2​+xd​xq​)2(xd​−xq​)Um2​​[(xd​sin2δ−xq​cos2δ)rs​+21​(xd​xq​−rs2​)sin2δ]\n上式中，等号左侧电磁转矩符号为负，说明该转矩方向与假定正方向相反，为制动转矩。\n上式中等号右侧的第一项称为短路转矩，为电机稳态短路(Um=0)(U_m=0)(Um​=0)时的转矩。短路时电枢电流idki_{dk}idk​、iqki_{qk}iqk​为\nidk=−xqEmrs2+xdxq,iqk=−rsEmrs2+xdxqi_{dk}=-\\frac{x_qE_m}{r_s^2+x_dx_q},i_{qk}=-\\frac{r_sE_m}{r_s^2+x_dx_q}\nidk​=−rs2​+xd​xq​xq​Em​​,iqk​=−rs2​+xd​xq​rs​Em​​\n因此，电枢短路电流所引起的电枢电阻损耗为\nidk2rs+iqk2rs=Ikm2rs=(rs2+xq2)Em2(rs2+xdxq)rsi_{dk}^2r_s+i_{qk}^2r_s=I_{km}^2r_s=\\frac{(r_s^2+x_q^2)E_m^2}{(r_s^2+x_dx_q)}r_s\nidk2​rs​+iqk2​rs​=Ikm2​rs​=(rs2​+xd​xq​)(rs2​+xq2​)Em2​​rs​\n因rs2&lt;&lt;xq2r_s^2 &lt;&lt; x_q^2rs2​&lt;&lt;xq2​，且rs2&lt;&lt;xdxqr_s^2 &lt;&lt; x_dx_qrs2​&lt;&lt;xd​xq​，可略去rsr_srs​的二次项，改写上式为\nTk=−(rs2+xq2)Em2(rs2+xdxq)2rs≈−(Emxd)2rs=−Ikm2rsT_k=-\\frac{(r_s^2+x_q^2)E_m^2}{(r_s^2+x_dx_q)^2}r_s \\approx -(\\frac{E_m}{x_d})^2r_s=-I_{km}^2r_s\nTk​=−(rs2​+xd​xq​)2(rs2​+xq2​)Em2​​rs​≈−(xd​Em​​)2rs​=−Ikm2​rs​\n因此，短路转矩TkT_kTk​仅与励磁绕组电流产生的空载电动势EmE_mEm​有关，而与端电压UmU_mUm​无关。当略去电枢绕组电阻rsr_srs​时，该转矩为零。\n转矩公式中等号右侧的第二项为同步转矩TsT_sTs​，它不仅与励磁电流产生的空载电动势EmE_mEm​有关，还和电枢绕组的端电压UmU_mUm​有关，其对应基本电磁功率部分。当略去rsr_srs​时，TsT_sTs​变为\nTs=EmUmxdsin⁡δT_s = \\frac{E_mU_m}{x_d}\\sin\\delta\nTs​=xd​Em​Um​​sinδ\n转矩公式中等号右侧的第三项为磁阻转矩TrT_rTr​，只有当直轴和交轴磁阻不等(xd≠xq)(x_d \\neq x_q)(xd​=xq​)时，该转矩才存在，且只与UmU_mUm​有关。其对应电磁功率中的磁阻功率部分。当略去rsr_srs​时，TrT_rTr​变为\nTr=−Um22(1xq−1xd)sin⁡2δT_r = - \\frac{U_m^2}{2}(\\frac{1}{x_q}-\\frac{1}{x_d})\\sin2\\delta\nTr​=−2Um2​​(xq​1​−xd​1​)sin2δ\n当略去电枢电阻时，稳态对称情况下总的电磁转矩为\nTem=−EmUmxdsin⁡δ−Um22(1xq−1xd)sin⁡2δT_{em}=-\\frac{E_mU_m}{x_d}\\sin\\delta-\\frac{U_m^2}{2}(\\frac{1}{x_q}-\\frac{1}{x_d})\\sin2\\delta\nTem​=−xd​Em​Um​​sinδ−2Um2​​(xq​1​−xd​1​)sin2δ\n可以看出，略去电枢电阻后，且直轴和交轴磁阻相等时，用标幺值表示的电磁转矩式（上式）与电枢端有功功率式完全一致。与电磁转矩相对应的电磁功率在不考虑电枢电阻损耗时，就是电枢端的有功功率。\n","categories":["电气工程"]},{"title":"【电机瞬态分析】同步电机标幺值系统","url":"/2024/07/21/%E3%80%90%E7%94%B5%E6%9C%BA%E7%9E%AC%E6%80%81%E5%88%86%E6%9E%90%E3%80%91%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA%E6%A0%87%E5%B9%BA%E5%80%BC%E7%B3%BB%E7%BB%9F/","content":" 标幺值系统\n电气工程领域中，因采用有名值时不同容量电机参数之间不便于比较，故通常的工程计算中多采用标幺值系统。\n标幺值的定义为：标幺值=有名值/基值。其中基值与有名值的单位应当相同。\n要采用标幺值系统，则必须首先解决基值的选取问题。电机分析最常用的一套基值系统选取原则为：\n\n使采用标幺值后电机各方程式的形式与采用有名值时的相同\n用标幺值表示的电枢与转子绕组间的互感系数是可逆的\n\n显然电机中各物理量的量纲都可以表示为电压、电流和时间三个量纲的组合，因此只要确定这三个变量的基值，就可推广确定电机运行中所有变量的标幺值基值。\n 定子各变量基值的选取\n瞬态分析时各变量均采用瞬时值形式，故电压、电流基值常采用其额定值的幅值，而不使用其有效值。\n\n定子电流基值IbI_bIb​选取定子相电流额定值的幅值\n定子电压基值UbU_bUb​选取定子相电压额定值的幅值\n时间基值τb=1/ωN=1/2(πfN)(s)\\tau_b=1/\\omega_N=1/2{(\\pi f_N)}(s)τb​=1/ωN​=1/2(πfN​)(s)，即在额定频率fNf_NfN​下经过一个电弧度所需的时间。\n\n以上三个变量均为独立地选取其基值，为保证方程式形式在使用标幺值系统时保持不变，以下变量的基值需要根据量纲关系，基于上述三个基本变量的基值进行导出。\n\n阻抗基值：Zb=UbIbZ_b=\\frac{U_b}{I_b}Zb​=Ib​Ub​​  (Ω=V/A)(\\Omega=V/A)(Ω=V/A)\n角频率基值 ωb=1τb\\omega_b=\\frac{1}{\\tau_b}ωb​=τb​1​ (rad/s)(rad/s)(rad/s)\n电感基值 Lb=Zbωb=UbIbτbL_b=\\frac{Z_b}{\\omega_b}=\\frac{U_b}{I_b}\\tau_bLb​=ωb​Zb​​=Ib​Ub​​τb​ (H=Vs/A)(H=Vs/A)(H=Vs/A)\n磁链基值 ψb=LbIb=Ubτb\\psi_b=L_bI_b=U_b\\tau_bψb​=Lb​Ib​=Ub​τb​ (Wb=Vs)(Wb=Vs)(Wb=Vs)\n\n此处电感基值的推导基于ZL=jωLZ_L=j\\omega LZL​=jωL。\n以下基值按惯用方法选取：功率基值取三相额定视在功率，即\n\n功率基值 Pb=3UNIN=32UNmINm=32UbIbP_b=3U_NI_N=\\frac{3}{2}U_{Nm}I_{Nm}=\\frac{3}{2}U_bI_bPb​=3UN​IN​=23​UNm​INm​=23​Ub​Ib​ (VA)(VA)(VA) （注意UbU_bUb​和IbI_bIb​均为幅值而非有效值，所以等式第三项要除以两次根号2）\n转矩基值 Tb=PbΩN=PbωbpT_b = \\frac{P_b}{\\Omega_N}=\\frac{P_b}{\\omega_b}pTb​=ΩN​Pb​​=ωb​Pb​​p (Nm)(Nm)(Nm) 式中ΩN\\Omega_NΩN​为额定机械角速度，单位rad/srad/srad/s；ppp为磁极对数。\n（注意此处有ωb=pΩN\\omega_b=p\\Omega_Nωb​=pΩN​，即同步电机电气角频率基值等于电机额定机械角速度乘以极对数。对于单极电机，额定机械角速度等于电气角频率；对于多极电机，电气角频率一般数倍于额定机械角速度。）\n\n 转子各量基值的选取\n转子的时间基值τb\\tau_bτb​与定子一致，关键是要确定转子各绕组电压、电流基值。下面讨论常用的可逆的互感系数和xadx_{ad}xad​基值系统的转子基值选取方法。\n假定：\n\n\nIfbI_{fb}Ifb​、UfbU_{fb}Ufb​、ψfb\\psi_{fb}ψfb​为励磁绕组的电流基值、电压基值和磁链基值；\n\n\nIDbI_{Db}IDb​、UDbU_{Db}UDb​、ψDb\\psi_{Db}ψDb​为直轴阻尼绕组的电流基值、电压基值和磁链基值；\n\n\nIQbI_{Qb}IQb​、UQbU_{Qb}UQb​、ψQb\\psi_{Qb}ψQb​为交轴阻尼绕组的电流基值、电压基值和磁链基值。\n\n\n令定子电流基值及电压基值与转子绕组相应量的基值的比值为\nkif=IbIfb,kiD=IbIDb.kiQ=IbIQbkuf=UbUfb,kuD=UbUDb.kuQ=UbUQbk_{if}=\\frac{I_b}{I_{fb}},k_{iD}=\\frac{I_b}{I_{Db}}.k_{iQ}=\\frac{I_b}{I_{Qb}}\\\\\nk_{uf}=\\frac{U_b}{U_{fb}},k_{uD}=\\frac{U_b}{U_{Db}}.k_{uQ}=\\frac{U_b}{U_{Qb}}\nkif​=Ifb​Ib​​,kiD​=IDb​Ib​​.kiQ​=IQb​Ib​​kuf​=Ufb​Ub​​,kuD​=UDb​Ub​​.kuQ​=UQb​Ub​​\n由ψ=LI\\psi=LIψ=LI和Lb=Zbωb=UbIbτbL_b=\\frac{Z_b}{\\omega_b}=\\frac{U_b}{I_b}\\tau_bLb​=ωb​Zb​​=Ib​Ub​​τb​，可推导得ψb=Ubτb\\psi_b=U_b\\tau_bψb​=Ub​τb​。所以定子、转子磁链基值比与电压基值比相同，即：\nkuf=ψbψfb,kuD=ψbψDb,kuQ=ψbψQbk_{uf}=\\frac{\\psi_b}{\\psi_{fb}},k_{uD}=\\frac{\\psi_b}{\\psi_{Db}},k_{uQ}=\\frac{\\psi_b}{\\psi_{Qb}}\nkuf​=ψfb​ψb​​,kuD​=ψDb​ψb​​,kuQ​=ψQb​ψb​​\n用标幺值表示的磁链方程式可推导为：\n[ψd∗ψf∗ψD∗]=[Ld∗Maf∗MaD∗Mfa∗Lf∗MfD∗MDa∗MDf∗LD∗][id∗if∗iD∗]\\left[\\begin{array}{l}\n\\psi_{d}^* \\\\\n\\psi_{f}^* \\\\\n\\psi_{D}^* \n\\end{array}\\right]=\\left[\\begin{array}{ccc}\nL_d^* &amp; M_{af}^* &amp; M_{aD}^*\\\\\nM_{fa}^* &amp; L_f^* &amp; M_{fD}^*\\\\\nM_{Da}^* &amp; M_{Df}^* &amp; L_D^*\n\\end{array}\\right]\\left[\\begin{array}{l}\ni_{d}^* \\\\\ni_{f}^* \\\\\ni_{D}^* \n\\end{array}\\right]\n⎣⎢⎡​ψd∗​ψf∗​ψD∗​​⎦⎥⎤​=⎣⎢⎡​Ld∗​Mfa∗​MDa∗​​Maf∗​Lf∗​MDf∗​​MaD∗​MfD∗​LD∗​​⎦⎥⎤​⎣⎢⎡​id∗​if∗​iD∗​​⎦⎥⎤​\n上式中各自感系数和互感系数的标幺值可推导如下：\nMaf∗=Maf0Lb1kifMfa∗=32Maf0LbkufLd∗=LdLbMaD∗=MaD0Lb1kiDMDa∗=32MaD0LbkuDLf∗=LfLbkufkifLD∗=LDLbkuDkiDMfD∗=MfDLbkufkiDMDf∗=MDfLbkuDkifM_{af}^*=\\frac{M_{af0}}{L_b}\\frac{1}{k_{if}}\\\\\nM_{fa}^*=\\frac{\\frac{3}{2}M_{af0}}{L_b}k_{uf}\\\\\nL_{d}^*=\\frac{L_d}{L_b}\\\\\nM_{aD}^*=\\frac{M_{aD0}}{L_b}\\frac{1}{k_{iD}}\\\\\nM_{Da}^*=\\frac{\\frac{3}{2}M_{aD0}}{L_b}k_{uD}\\\\\nL_f^*=\\frac{L_f}{L_b}\\frac{k_{uf}}{k_{if}}\\\\\nL_D^*=\\frac{L_D}{L_b}\\frac{k_{uD}}{k_{iD}}\\\\\nM_{fD}^*=\\frac{M_{fD}}{L_b}\\frac{k_{uf}}{k_{iD}}\\\\\nM_{Df}^*=\\frac{M_{Df}}{L_b}\\frac{k_{uD}}{k_{if}}\nMaf∗​=Lb​Maf0​​kif​1​Mfa∗​=Lb​23​Maf0​​kuf​Ld∗​=Lb​Ld​​MaD∗​=Lb​MaD0​​kiD​1​MDa∗​=Lb​23​MaD0​​kuD​Lf∗​=Lb​Lf​​kif​kuf​​LD∗​=Lb​LD​​kiD​kuD​​MfD∗​=Lb​MfD​​kiD​kuf​​MDf∗​=Lb​MDf​​kif​kuD​​\n要使以上各式中的互感系数可逆，即要求\nMaf∗=Mfa∗,MaD∗=MDa∗,MfD∗=MDf∗M_{af}^*=M_{fa}^*,M_{aD}^*=M_{Da}^*,M_{fD}^*=M_{Df}^*\nMaf∗​=Mfa∗​,MaD∗​=MDa∗​,MfD∗​=MDf∗​\n显然要令上式成立，则必须在标幺值系统中选取合适的转子电流基值和电压基值，即：\nkufkif=23,kuDkiD=23,kuQkiQ=23k_{uf}k_{if}=\\frac{2}{3},\nk_{uD}k_{iD}=\\frac{2}{3},\nk_{uQ}k_{iQ}=\\frac{2}{3}\nkuf​kif​=32​,kuD​kiD​=32​,kuQ​kiQ​=32​\n因此，要获得可逆的互感系数，定、转子各绕组的电压基值比与电流基值比的乘积需等于2/3。\n显然这个条件很容满足，这说明在定子各量基值已经选定并要求互感系数可逆的条件下，转子方面的电流基值和电压基值的选取方式仍然很多，但kik_iki​和kuk_uku​中则只能自由选定其中一个，另一个则由2/3法则确定。\n工程上常用xadx_{ad}xad​基值系统来确定转子方面的变量基值。该系统中，电枢d轴绕组自感中对应主磁场部分（LadL_{ad}Lad​）的标幺值、电枢d轴绕组与励磁绕组互感系数MafM_{af}Maf​的标幺值以及电枢d轴绕组与直轴阻尼绕组互感系数MaDM_{aD}MaD​的标幺值相等，即\nLad∗=Maf∗=MaD∗L_{ad}^*=M_{af}^*=M_{aD}^*\nLad∗​=Maf∗​=MaD∗​\n将等式代入，很容易得到：\nLadIb=Maf0IfbL_{ad}I_b=M_{af0}I_{fb}\nLad​Ib​=Maf0​Ifb​\n可见xadx_{ad}xad​基值系统中励磁电流基值选取的规则是：励磁电流基值所产生的通过气隙的主磁场与电枢d绕组的互感磁链应与电枢d绕组通过基值定子电流所产生的通过气隙的自感磁链相等。\n励磁电流基值IfbI_{fb}Ifb​也可通过实验求得。将上式两边同乘以额定角频率ωN\\omega_NωN​，得\nωNMaf0Ifb=ωNLadIb=xadINm\\omega_N M_{af0} I_{fb}=\\omega_N L_{ad}I_b=x_{ad}I_{Nm}\nωN​Maf0​Ifb​=ωN​Lad​Ib​=xad​INm​\n该式表明基值励磁电流在定子各相绕组中将感生出有名值幅值为xadINmx_{ad}I_{Nm}xad​INm​的空载电动势。因此以下实验可确定励磁电流基值：同步电机以额定同步转速旋转，定子各绕组开路，励磁绕组通以电流，各项绕组中产生的基波空载（不计饱和）电压幅值为xadIb=xadINmx_{ad}I_b=x_{ad}I_{Nm}xad​Ib​=xad​INm​,此时的励磁电流值即为励磁电流基值。\n按照该种方法选定转子电流基值后，可确定转子电压基值。原来不相等的一些电感系数还可以变为相等：\nLad∗=Maf∗=Mfa∗=MaD∗=MDa∗Laq∗=MaQ∗=MQa∗MfD∗=MDf∗=MfDLb×23(IfbIDbIb2)Lf∗=LfLb×23(IfbIb)2LD∗=LDLb×23(IDbIb)2LQ∗=LQLb×23(IQbIb)2L_{ad}^*=M_{af}^*=M_{fa}^*=M_{aD}^*=M_{Da}^*\\\\\nL_{aq}^*=M_{aQ}^*=M_{Qa}^*\\\\\nM_{fD}^*=M_{Df}^*=\\frac{M_{fD}}{L_b} \\times \\frac{2}{3}(\\frac{I_{fb}I_{Db}}{I_b^2})\\\\\nL_f^*=\\frac{L_f}{L_b} \\times \\frac{2}{3}(\\frac{I_{fb}}{I_b})^2\\\\\nL_D^*=\\frac{L_D}{L_b} \\times \\frac{2}{3}(\\frac{I_{Db}}{I_b})^2\\\\\nL_Q^*=\\frac{L_Q}{L_b} \\times \\frac{2}{3}(\\frac{I_{Qb}}{I_b})^2\nLad∗​=Maf∗​=Mfa∗​=MaD∗​=MDa∗​Laq∗​=MaQ∗​=MQa∗​MfD∗​=MDf∗​=Lb​MfD​​×32​(Ib2​Ifb​IDb​​)Lf∗​=Lb​Lf​​×32​(Ib​Ifb​​)2LD∗​=Lb​LD​​×32​(Ib​IDb​​)2LQ∗​=Lb​LQ​​×32​(Ib​IQb​​)2\n转子变量标幺值的折算也可以作以下理解，即先将转子方面的参数折合到定子方面，然后再采用定子方面的基值求其标幺值，非常类似于变压器中高低压两侧的标幺值折算方法。如：\nLf∗=LfkufLbkifL_f^*=\\frac{L_fk_{uf}}{L_bk_{if}}\nLf∗​=Lb​kif​Lf​kuf​​\n可以看作是励磁绕组自感LfL_fLf​乘以kuf/kifk_{uf}/k_{if}kuf​/kif​折合到定子方面，再除以定子电感基值LbL_bLb​。\n励磁绕组与直轴阻尼绕组间的互感系数标幺值MDf∗=MfD∗M_{Df}^*=M_{fD}^*MDf∗​=MfD∗​，在不考虑只与它们两个绕组共同交链的不通过气隙的漏磁链时，则有MDf∗=MfD∗=Lad∗M_{Df}^*=M_{fD}^*=L_{ad}^*MDf∗​=MfD∗​=Lad∗​。一般情况下工程计算中都会作该简化，此时对电枢电流计算带来的误差可忽略，对转子电流计算会带来一定的误差。\n将MDf∗=MfD∗=Lad∗M_{Df}^*=M_{fD}^*=L_{ad}^*MDf∗​=MfD∗​=Lad∗​代入磁链方程式中，并考虑电感标幺值与额定频率下相应电抗的标幺值在数值上相等，即x∗=ωNLωbLb=L∗x^*=\\frac{\\omega_N L}{\\omega_b L_b}=L^*x∗=ωb​Lb​ωN​L​=L∗，因此磁链方程式可以改写为：\n[ψd∗ψf∗ψD∗]=[xd∗xad∗xad∗xad∗xf∗xad∗xad∗xad∗xD∗][id∗if∗iD∗]\\begin{bmatrix}\n\\psi_d^* \\\\\n\\psi_f^* \\\\\n\\psi_D^*\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nx_d^* &amp; x_{ad}^* &amp; x_{ad}^* \\\\\nx_{ad}^* &amp; x_f^* &amp; x_{ad}^* \\\\\nx_{ad}^* &amp; x_{ad}^* &amp; x_D^*\n\\end{bmatrix}\n\\begin{bmatrix}\ni_d^* \\\\\ni_f^* \\\\\ni_D^*\n\\end{bmatrix}\n⎣⎢⎡​ψd∗​ψf∗​ψD∗​​⎦⎥⎤​=⎣⎢⎡​xd∗​xad∗​xad∗​​xad∗​xf∗​xad∗​​xad∗​xad∗​xD∗​​⎦⎥⎤​⎣⎢⎡​id∗​if∗​iD∗​​⎦⎥⎤​\n同理有\n[ψq∗ψQ∗]=[xq∗xaq∗xaq∗xQ∗][iq∗iQ∗]\\begin{bmatrix}\n\\psi_q^* \\\\\n\\psi_Q^* \n\\end{bmatrix}\n=\n\\begin{bmatrix}\nx_q^* &amp; x_{aq}^*  \\\\\nx_{aq}^* &amp; x_Q^*  \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\ni_q^* \\\\\ni_Q^*\n\\end{bmatrix}\n[ψq∗​ψQ∗​​]=[xq∗​xaq∗​​xaq∗​xQ∗​​][iq∗​iQ∗​​]\n其中\nxd∗=xl∗+xad∗xq∗=xl∗+xaq∗xf∗=xfl∗+xad∗xD∗=xDl∗+xad∗xQ∗=xQl∗+xaq∗\\begin{aligned}\nx_d^* &amp;= x_l^* + x_{ad}^* \\\\\nx_q^* &amp;= x_l^* + x_{aq}^* \\\\\nx_f^* &amp;= x_{fl}^* + x_{ad}^* \\\\\nx_D^* &amp;= x_{Dl}^* + x_{ad}^* \\\\\nx_Q^* &amp;= x_{Ql}^* + x_{aq}^*\n\\end{aligned}\nxd∗​xq∗​xf∗​xD∗​xQ∗​​=xl∗​+xad∗​=xl∗​+xaq∗​=xfl∗​+xad∗​=xDl∗​+xad∗​=xQl∗​+xaq∗​​\n励磁绕组电压基值可由以下方式确定。\n因为\nkufkif=UbUfb×IbIfb=23k_{uf}k_{if}=\\frac{U_b}{U_{fb}}\\times \\frac{I_b}{I_{fb}}=\\frac{2}{3}\nkuf​kif​=Ufb​Ub​​×Ifb​Ib​​=32​\n故\nUfb=32×IbIfbUbU_{fb}=\\frac{3}{2}\\times\\frac{I_b}{I_{fb}}U_b\nUfb​=23​×Ifb​Ib​​Ub​\n励磁绕组阻抗基值的取法与电枢阻抗相似，为励磁绕组电压、电流基值的比，即\nZfb=UfbIfb=32(IbIfb)2ZbZ_{fb}=\\frac{U_{fb}}{I_{fb}}=\\frac{3}{2}(\\frac{I_b}{I_{fb}})^2Z_b\nZfb​=Ifb​Ufb​​=23​(Ifb​Ib​​)2Zb​\n同样方法可求出直轴、交轴阻尼绕组的电压基值和阻抗基值。\n 交流电机基本方程式的标幺值形式\n现在，就可以把原有的dq坐标系下的交流电机基本方程式改写为基于xadx_{ad}xad​基值系统的标幺值形式。\n定、转子电压方程标幺值的形式与有名值形式下的相同，即\n[ud∗uq∗u0∗uf∗uD∗uQ∗]=p[ψd∗ψq∗ψ0∗ψf∗ψD∗ψQ∗]+[ra∗000000ra∗000000ra∗000000rf∗000000rD∗000000rQ∗][id∗iq∗i0∗if∗iD∗iQ∗]+[−ω∗ψq∗ω∗ψd∗0000]\\begin{bmatrix}\nu_d^* \\\\\nu_q^* \\\\\nu_0^* \\\\\nu_f^* \\\\\nu_D^* \\\\\nu_Q^*\n\\end{bmatrix}\n=p\n\\begin{bmatrix}\n\\psi_d^* \\\\\n\\psi_q^* \\\\\n\\psi_0^* \\\\\n\\psi_f^* \\\\\n\\psi_D^* \\\\\n\\psi_Q^*\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nr_a^* &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; r_a^* &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; r_a^* &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; r_f^* &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; r_D^* &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; r_Q^*\n\\end{bmatrix}\n\\begin{bmatrix}\ni_d^* \\\\\ni_q^* \\\\\ni_0^* \\\\\ni_f^* \\\\\ni_D^* \\\\\ni_Q^*\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n-\\omega^* \\psi_q^* \\\\\n\\omega^* \\psi_d^* \\\\\n0 \\\\\n0 \\\\\n0 \\\\\n0\n\\end{bmatrix}\n⎣⎢⎢⎢⎢⎢⎢⎢⎡​ud∗​uq∗​u0∗​uf∗​uD∗​uQ∗​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=p⎣⎢⎢⎢⎢⎢⎢⎢⎡​ψd∗​ψq∗​ψ0∗​ψf∗​ψD∗​ψQ∗​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​+⎣⎢⎢⎢⎢⎢⎢⎢⎡​ra∗​00000​0ra∗​0000​00ra∗​000​000rf∗​00​0000rD∗​0​00000rQ∗​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎢⎡​id∗​iq∗​i0∗​if∗​iD∗​iQ∗​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​+⎣⎢⎢⎢⎢⎢⎢⎢⎡​−ω∗ψq∗​ω∗ψd∗​0000​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n将磁链方程式代入，整理可得\nU∗=L∗pI∗+ω∗G∗I∗+R∗I∗U^*=L^*pI^*+\\omega^*G^*I^*+R^*I^*\nU∗=L∗pI∗+ω∗G∗I∗+R∗I∗\n式中\nU∗=[Udq0∗UfDQ∗]TU^*=[U_{dq0}^* \\quad U_{fDQ}^*]^T\\\\\nU∗=[Udq0∗​UfDQ∗​]T\nI∗=[Idq0∗IfDQ∗]TI^*=[I_{dq0}^* \\quad I_{fDQ}^*]^T\nI∗=[Idq0∗​IfDQ∗​]T\nR∗=[Rabc∗00RfDQ∗]R^*=\n\\begin{bmatrix}\nR_{abc}^* &amp; 0\\\\\n0 &amp; R_{fDQ}^*\n\\end{bmatrix}\nR∗=[Rabc∗​0​0RfDQ∗​​]\nL∗=[xd∗00xad∗xad∗00xq∗000xaq∗00x0∗000xad∗00xf∗xad∗0xad∗00xad∗xD∗00xaq∗000xQ∗]G∗=[0−xq∗000−xaq∗xd∗00xad∗xad∗0000000000000000000000000]\\begin{array}{c}\nL^{*}=\\left[\\begin{array}{cccccc}\nx_{\\mathrm{d}}^* &amp; 0 &amp; 0 &amp; x_{\\mathrm{ad}}^{*} &amp; x_{\\mathrm{ad}}^{*} &amp; 0 \\\\\n0 &amp; x_{\\mathrm{q}}^{*} &amp; 0 &amp; 0 &amp; 0 &amp; x_{a q}^{*} \\\\\n0 &amp; 0 &amp; x_{0}^{*} &amp; 0 &amp; 0 &amp; 0 \\\\\nx_{\\mathrm{ad}}^{*} &amp; 0 &amp; 0 &amp; x_{\\mathrm{f}}^{*} &amp; x_{a d}^{*} &amp; 0 \\\\\nx_{a d}^{*} &amp; 0 &amp; 0 &amp; x_{ad}^{*} &amp; x_{\\mathrm{D}}^{*} &amp; 0 \\\\\n0 &amp; x_{\\mathrm{aq}}^{*} &amp; 0 &amp; 0 &amp; 0 &amp; x_{\\mathrm{Q}}^{*}\n\\end{array}\\right] \n\n\\\\\n\nG^{*}=\\left[\\begin{array}{cccccc}\n0 &amp; -x_{\\mathrm{q}}^{*} &amp; 0 &amp; 0 &amp; 0 &amp; -x_{a q}^{*} \\\\\nx_{d}^{*} &amp; 0 &amp; 0 &amp; x_{\\mathrm{ad}}^{*} &amp; x_{\\mathrm{ad}}^{*} &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\n\\end{array}\\right]\n\\end{array}\nL∗=⎣⎢⎢⎢⎢⎢⎢⎢⎡​xd∗​00xad∗​xad∗​0​0xq∗​000xaq∗​​00x0∗​000​xad∗​00xf∗​xad∗​0​xad∗​00xad∗​xD∗​0​0xaq∗​000xQ∗​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​G∗=⎣⎢⎢⎢⎢⎢⎢⎢⎡​0xd∗​0000​−xq∗​00000​000000​0xad∗​0000​0xad∗​0000​−xaq∗​00000​⎦⎥⎥⎥⎥⎥⎥⎥⎤​​\n以上G∗G^*G∗为电压方程中角速度ω∗\\omega^*ω∗项的系数矩阵，反映了旋转电动势的项的系数大小，仅在电枢电压、ud∗u_d^*ud∗​、uq∗u_q^*uq∗​对应的行里有元素。\n可以看出，通过线性变换后，原来定子绕组a、b、c三相的各变量已被新的d、q、0坐标系统中各变量所取代。a、b、c三相绕组是实际存在的三个回路，其绕组轴线为静止的，且在空间上互差2π/32\\pi/32π/3电弧度。变换后的d、q、0坐标系统中各变量是d、q、0三个绕组回路的变量，其中d、q绕组的轴线与转子一道旋转，且d轴与转子直轴轴线(励磁绕组轴线)相重合，d、q轴在空间上相差π/2\\pi/2π/2电弧度。零轴绕组在电方面是独立的，与其他绕组无电磁耦合关系。\n从这以后，在一般不加说明的情况下，电机各量均采用标么值，并将表示标么值的“ * ”符号省去。\n","categories":["电气工程"]},{"title":"【电机瞬态分析】同步电机突然三相短路分析","url":"/2024/08/08/%E3%80%90%E7%94%B5%E6%9C%BA%E7%9E%AC%E6%80%81%E5%88%86%E6%9E%90%E3%80%91%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA%E7%AA%81%E7%84%B6%E4%B8%89%E7%9B%B8%E7%9F%AD%E8%B7%AF%E5%88%86%E6%9E%90/","content":" 简介\n在电力系统实际发生的故障中，不对称短路占的比例较大，对称短路的故障所占比例虽较小，但其后果比较严重。根据国家标准规定，同步发电机必须能承受空载电压等于105%额定电压下的突然三相对称短路。本节直接利用之前导出的同步电机动态方程式，求解空载时突然三相对称短路后的短路电流和电磁转矩。\n假定在突然短路过程中转速为同步转速，即ω=1\\omega=1ω=1。这个假定在分析最大突然短路电流和最大短路转矩时是可以满足工程要求的。由于转速恒定而且已知，因此，只需求解动态方程式中的电压方程式，无需考虑转矩过渡时的转子运动方程式。此时电压方程式是一组线性常系数的微分方程式，为了求解方便，可以应用叠加原理和拉氏变换的方法。\n根据叠加原理，实际突然短路可以看成是下面两种工况的叠加：\n\n电机突然短路前的稳定运行工况\n在零初始状态下电枢端突然加上与电机短路前大小相等、方向相反的电压时的运行工况\n\n实际突然短路问题的求解就转化成了短路前的稳态运行工况和零初始值时电枢端突加反向电压的瞬态问题的求解，这样，将使计算大为简化。下面分别就电枢突然短路后的电枢电流、转子电流及电磁转矩进行讨论。\n 空载突然短路后的电枢电流\n假设同步电机在三项短路前空载运行，其稳定运行工况之前已经有分析过，其端电压为\nud=ud0=0uq=uq0=Emu_d=u_{d0}=0 \\\\\nu_q=u_{q0}=E_m\nud​=ud0​=0uq​=uq0​=Em​\n根据叠加原理，突然三相短路后的电枢电流idi_did​、iqi_qiq​，将由原来的稳态电流id0i_{d0}id0​、iq0i_{q0}iq0​和突然加电压−ud0-u_{d0}−ud0​和−uq0-u_{q0}−uq0​引起的瞬态电流id′i_d&#x27;id′​、iq′i_q&#x27;iq′​相加而成，即\nid=id0+id′iq=iq0+iq′i_d=i_{d0}+i_d&#x27; \\\\\ni_q=i_{q0}+i_q&#x27; \nid​=id0​+id′​iq​=iq0​+iq′​\n下面将分别求解电流id0i_{d0}id0​、iq0i_{q0}iq0​、id′i_d&#x27;id′​、iq′i_q&#x27;iq′​和idi_did​、iqi_qiq​，并将其返回至abc坐标系统。\n 短路前的稳态电流id0i_{d0}id0​、iq0i_{q0}iq0​\n同步电机运行在空载状态，电枢绕组开路，三相电枢绕组电流均为零，因而\nid0=iq0=0i_{d0}=i_{q0}=0\nid0​=iq0​=0\n 突然加上−ud0-u_{d0}−ud0​、−uq0-u_{q0}−uq0​时所产生的电流idi_did​、iqi_qiq​\n电枢d、q绕组端分别突然加上−ud0-u_{d0}−ud0​、−uq0-u_{q0}−uq0​时，电压方程式为\n−ud0=0=pψd′−ψq′+rsid′−uq0=−Em=pψq′+ψd′+rsiq′-u_{d0}=0=p\\psi_d&#x27;-\\psi_q&#x27;+r_si_d&#x27; \\\\\n-u_{q0}=-E_m=p\\psi_q&#x27;+\\psi_d&#x27;+r_si_q&#x27;\n−ud0​=0=pψd′​−ψq′​+rs​id′​−uq0​=−Em​=pψq′​+ψd′​+rs​iq′​\n不计励磁调节作用，在突然短路时ufu_fuf​为恒定值，而该恒定励磁电压的作用已经在稳态运行分析时考虑过。当电枢端突加电压−ud0-u_{d0}−ud0​、−uq0-u_{q0}−uq0​时，励磁绕组相当于短路回路，即uf=0u_f=0uf​=0，因而相应的电枢磁链为\nψd′=xd(p)id′ψq′=xq(p)iq′\\psi_d&#x27;=x_d(p)i_d&#x27; \\\\\n\\psi_q&#x27;=x_q(p)i_q&#x27;\nψd′​=xd​(p)id′​ψq′​=xq​(p)iq′​\n将电枢磁链式代入电压方程式，得到电压与阻抗、电流的关系式。当电枢端突加电压时，各绕组的电流、磁链初值为零，故经由LaplaceLaplaceLaplace变换后，其运算方程为\n0=[rs+pxd(p)]Id(p)−xq(p)Iq(p)−Emp=[rs+pxq(p)]Iq(p)+xd(p)Id(p)0=[r_s+px_d(p)]I_d(p)-x_q(p)I_q(p) \\\\\n-\\frac{E_m}{p}=[r_s+px_q(p)]I_q(p)+x_d(p)I_d(p)\n0=[rs​+pxd​(p)]Id​(p)−xq​(p)Iq​(p)−pEm​​=[rs​+pxq​(p)]Iq​(p)+xd​(p)Id​(p)\n解出电流Id(p)I_d(p)Id​(p)如下\nId(p)=−Emp×xq(p)rs2+rs[xd(p)+xq(p)]p+xd(p)xq(p)p2+xd(p)xq(p)I_d(p)=-\\frac{E_m}{p}\\times\\frac{x_q(p)}{r_s^2+r_s[x_d(p)+x_q(p)]p+x_d(p)x_q(p)p^2+x_d(p)x_q(p)}\nId​(p)=−pEm​​×rs2​+rs​[xd​(p)+xq​(p)]p+xd​(p)xq​(p)p2+xd​(p)xq​(p)xq​(p)​\n或\nId(p)=−Emp×1p2+rs[1xd(p)+1xq(p)]p+1+rs2xd(p)xq(p)×1xd(p)I_d(p)=-\\frac{E_m}{p}\\times\\frac{1}{p^2+r_s[\\frac{1}{x_d(p)}+\\frac{1}{x_q(p)}]p+1+\\frac{r_s^2}{x_d(p)x_q(p)}}\\times\\frac{1}{x_d(p)}\nId​(p)=−pEm​​×p2+rs​[xd​(p)1​+xq​(p)1​]p+1+xd​(p)xq​(p)rs2​​1​×xd​(p)1​\n略去rs2r_s^2rs2​项，中括号内有xd(p)x_d(p)xd​(p)和xq(p)x_q(p)xq​(p)的项中，将转子电阻rfr_frf​、rDr_DrD​、rQr_QrQ​略去，这样xd(p)x_d(p)xd​(p)、xq(p)x_q(p)xq​(p)可分别简化为直轴、交轴次暂态（超瞬变）电抗xd′′x_d&#x27;&#x27;xd′′​、xq′′x_q&#x27;&#x27;xq′′​，于是有\nId(p)=−Emp(p2+2αp+1)xd(p)I_d(p)=-\\frac{E_m}{p(p^2+2\\alpha p+1)x_d(p)}\nId​(p)=−p(p2+2αp+1)xd​(p)Em​​\n式中\nα=rs2(1xd′′+1xq′′)=1Ta\\alpha = \\frac{r_s}{2}(\\frac{1}{x_d&#x27;&#x27;}+\\frac{1}{x_q&#x27;&#x27;})=\\frac{1}{T_a}\nα=2rs​​(xd′′​1​+xq′′​1​)=Ta​1​\n根据运算电抗章节中导出的xd(p)x_d(p)xd​(p)的倒数形式\n1xd(p)=1xd+(1xd′−1xd)Td′pTd′p+1+(1xd′′−1xd′)Td′′pTd′′p+1\\frac{1}{x_d(p)}=\\frac{1}{x_d}+(\\frac{1}{x_d&#x27;}-\\frac{1}{x_d})\\frac{T_d&#x27;p}{T_d&#x27;p+1}+(\\frac{1}{x_d&#x27;&#x27;}-\\frac{1}{x_d&#x27;})\\frac{T_d&#x27;&#x27;p}{T_d&#x27;&#x27;p+1}\nxd​(p)1​=xd​1​+(xd′​1​−xd​1​)Td′​p+1Td′​p​+(xd′′​1​−xd′​1​)Td′′​p+1Td′′​p​\n代入原式，有\nId(p)=−Emp(p2+2αp+1)[1xd+(1xd′−1xd)Td′pTd′p+1+(1xd′′−1xd′)Td′′pTd′′p+1]I_d(p)=-\\frac{E_m}{p(p^2+2\\alpha p +1)}[\\frac{1}{x_d}+(\\frac{1}{x_d&#x27;}-\\frac{1}{x_d})\\frac{T_d&#x27;p}{T_d&#x27;p+1}+(\\frac{1}{x_d&#x27;&#x27;}-\\frac{1}{x_d&#x27;})\\frac{T_d&#x27;&#x27;p}{T_d&#x27;&#x27;p+1}]\nId​(p)=−p(p2+2αp+1)Em​​[xd​1​+(xd′​1​−xd​1​)Td′​p+1Td′​p​+(xd′′​1​−xd′​1​)Td′′​p+1Td′′​p​]\n同理可解出象函数Iq(p)I_q(p)Iq​(p)为\nIq(p)=−Emp×rs+pxd(p)rs2+rs[xd(p)+xq(p)]p+xd(p)xq(p)p2+xd(p)xq(p)=−Emp×rs+pxd(p)p2+rs[1xd(p)+1xq(p)]p+1+rs2xd(p)xq(p)×1xd(p)xq(p)\\begin{aligned}I_{q}(p)&amp;=- \\frac{E_{m}}{p}\\times\\frac{r_{s}+px_{d}(p)}{r_{s}^{2}+r_{s}[x_{d}(p)+x_{q}(p)]p+x_{d}(p)x_{q}(p)p^{2}+x_{d}(p)x_{q}(p)}\\\\&amp;=- \\frac{E_{m}}{p}\\times\\frac{r_{s}+px_{d}(p)}{p^{2}+r_{s}\\Big[\\frac{1}{x_{d}(p)}+\\frac{1}{x_{q}(p)}\\Big]p+1+\\frac{r_{s}^{2}}{x_{d}(p)x_{q}(p)}}\\times\\frac{1}{x_{d}(p)x_{q}(p)}\\end{aligned}\nIq​(p)​=−pEm​​×rs2​+rs​[xd​(p)+xq​(p)]p+xd​(p)xq​(p)p2+xd​(p)xq​(p)rs​+pxd​(p)​=−pEm​​×p2+rs​[xd​(p)1​+xq​(p)1​]p+1+xd​(p)xq​(p)rs2​​rs​+pxd​(p)​×xd​(p)xq​(p)1​​\n分母中采用与导出Id(p)I_d(p)Id​(p)时同样的简化方法，并根据运算电抗章节中导出的xq(p)x_q(p)xq​(p)的倒数形式\n1xq(p)=1xq+(1xq′′−1xq)Tq′′p1+Tq′′p\\frac{1}{x_q(p)}=\\frac{1}{x_q}+(\\frac{1}{x_q&#x27;&#x27;}-\\frac{1}{x_q})\\frac{T_q&#x27;&#x27;p}{1+T_q&#x27;&#x27;p}\nxq​(p)1​=xq​1​+(xq′′​1​−xq​1​)1+Tq′′​pTq′′​p​\n代入，得\nIq(p)=−Em(p2+2αp+1)[1xq+(1xq′′−1xq)Tq′′p1+Tq′′p]I_q(p)=-\\frac{E_m}{(p^2+2\\alpha p +1)}[\\frac{1}{x_q}+(\\frac{1}{x_q&#x27;&#x27;}-\\frac{1}{x_q})\\frac{T_q&#x27;&#x27;p}{1+T_q&#x27;&#x27;p}]\nIq​(p)=−(p2+2αp+1)Em​​[xq​1​+(xq′′​1​−xq​1​)1+Tq′′​pTq′′​p​]\n将象函数Id(p)I_d(p)Id​(p)和Iq(p)I_q(p)Iq​(p)使用LaplaceLaplaceLaplace反变换至原函数id′i_d&#x27;id′​和iq′i_q&#x27;iq′​。由于同步电机中1Td\\frac{1}{T_d}Td​1​、1Td′\\frac{1}{T_d&#x27;}Td′​1​、1Td′′\\frac{1}{T_d&#x27;&#x27;}Td′′​1​、1Tq′′\\frac{1}{T_q&#x27;&#x27;}Tq′′​1​均远小于1，反变换后的结果为\nid′=−Em[(1xd′′−1xd′)e−t/Td′′+(1xd′−1xd)e−t/Td′+1xd]+Emxd′′e−tcos⁡t/Tai_d&#x27;=-E_m[(\\frac{1}{x_d&#x27;&#x27;}-\\frac{1}{x_d&#x27;})e^{-t/T_d&#x27;&#x27;}+(\\frac{1}{x_d&#x27;}-\\frac{1}{x_d})e^{-t/T_d&#x27;}+\\frac{1}{x_d}]+\\frac{E_m}{x_d&#x27;&#x27;}e^{-t\\cos t/T_a}\\\\\nid′​=−Em​[(xd′′​1​−xd′​1​)e−t/Td′′​+(xd′​1​−xd​1​)e−t/Td′​+xd​1​]+xd′′​Em​​e−tcost/Ta​\niq′=−Emxq′′e−tsin⁡t/Tai_q&#x27;=-\\frac{E_m}{x_q&#x27;&#x27;}e^{-t \\sin t/T_a}\niq′​=−xq′′​Em​​e−tsint/Ta​\n 空载突然短路后的实际电流idi_did​、iqi_qiq​\n根据上面分析，实际的空载突然三相短路电流可应用叠加原理，将空载稳态运行时的电流与突加−ud0-u_{d0}−ud0​、−uq0-u_{q0}−uq0​时的电流相加，由于空载时电枢电流为零，所以突然短路后的电流用dq0坐标系统表示为\nid=id0+id′=id′iq=iq0+iq′=iq′i_d=i_{d0}+i_d&#x27;=i_d&#x27; \\\\\ni_q=i_{q0}+i_q&#x27;=i_q&#x27;\nid​=id0​+id′​=id′​iq​=iq0​+iq′​=iq′​\n 空载突然短路后的电流iai_aia​、ibi_bib​、ici_cic​\n假定t=0t=0t=0时，d轴和q轴得夹角为θ0\\theta_0θ0​，则θ=t+θ0\\theta=t+\\theta_0θ=t+θ0​。将id′i_d&#x27;id′​和iq′i_q&#x27;iq′​二式返回至abc坐标系统，有\nia=−[(1xd′′−1xd′)e−t/Td′′+(1xd′−1xd)e−t/Td′+1xd]Emcos⁡(t+θ0)+Em2e−1/Ta[(1xd′′+1xq′′)cos⁡θ0+(1xd′′−1xq′′)cos⁡(2t+θ0)]i_a=-[(\\frac{1}{x_d&#x27;&#x27;}-\\frac{1}{x_d&#x27;})e^{-t/T_d&#x27;&#x27;}+(\\frac{1}{x_d&#x27;}-\\frac{1}{x_d})e^{-t/T_d&#x27;}+\\frac{1}{x_d}]E_m\\cos(t+\\theta_0)+\\frac{E_m}{2}e^{-1/T_a}[(\\frac{1}{x_d&#x27;&#x27;}+\\frac{1}{x_q&#x27;&#x27;})\\cos \\theta_0+(\\frac{1}{x_d&#x27;&#x27;}-\\frac{1}{x_q&#x27;&#x27;})\\cos (2t+\\theta_0)]\nia​=−[(xd′′​1​−xd′​1​)e−t/Td′′​+(xd′​1​−xd​1​)e−t/Td′​+xd​1​]Em​cos(t+θ0​)+2Em​​e−1/Ta​[(xd′′​1​+xq′′​1​)cosθ0​+(xd′′​1​−xq′′​1​)cos(2t+θ0​)]\n把上式中的θ0\\theta_0θ0​分别用(θ0−120°)(\\theta_0-120\\degree)(θ0​−120°)、(θ0+120°)(\\theta_0+120\\degree)(θ0​+120°)替换，即可得到ibi_bib​、ici_cic​的表达式。\n 小结\n以上是从解方程式得到的突然三相短路后的实际定子绕组电流。由iai_aia​的表达式可知，突然三相短路后，定子各相短路电流由两大部分构成，即基频的周期分量、非周期及2倍频分量，从物理意义上来理解，当定子绕组突然三相短路后，由于转子磁场的旋转及定子绕组中产生相应的三相稳态基频电流，将引起定子及转子各组中的磁链的突变。为了保持各闭合回路中的磁链不发生突变,定子绕组和转子阻尼和励磁绕组中就产生了非周期电流。由于转子以同步速度旋转，转子阻尼和励磁绕组中的非周期电流会在定子绕组中产生相应的基频周期电流分量，即超瞬变（次暂态）分量和瞬变（暂态）分量。由于转子绕组中存在电阻，突然短路在转子绕组中引起的非周期电流将逐步衰减至零，其阻尼绕组和励磁绕组的衰减时间常数分别为Td′′T_d&#x27;&#x27;Td′′​和Td′T_d&#x27;Td′​。由转子绕组中的非周期电流在定子绕组中感生的超瞬变分量和瞬变分量电流亦按同样的时间常数衰减。同样地，定子绕组中的非周期电流会在转子绕组中产生相应的基频周期分量电流，但由于转子不对称，这个转子绕组中的基频电流所产生的磁场相对转子而言可分为两个转向相反，转速均为同步转速ω1\\omega_1ω1​的分量，其中与转子转向相同的旋转磁场对定子的转速为2ω12\\omega_12ω1​，它将在定子绕组中引起倍频的周期分量。从iai_aia​的表达式中也可看出，当转子的磁路和电路完全对称，即xd′′=xq′x_d&#x27;&#x27;=x_q&#x27;xd′′​=xq′​时，这个倍频的周期分量将不存在。与转子转向相反的旋转磁场对定子的转速为零，对定子非周期电流产生的磁场是一个去磁作用。\n由于定子绕组存在电阻，定子绕组中的非周期电流和倍频电流将以定子绕组的时间常数TaT_aTa​衰减至零。\n从上面分析也可以看出，由于绕组轴线选取的不同，在d、q、0坐标系统中，电流idi_did​、iqi_qiq​的非周期分量相当于a、b、c坐标系统中电流iai_aia​、ibi_bib​、ici_cic​的基频周期分量，而电流idi_did​及iqi_qiq​的基频周期分量，则相当于电流iai_aia​、ibi_bib​、ici_cic​的非周期分量和倍频的周期分量。\n 空载突然短路后的转子绕组电流\n突然三相短路后，电机转子绕组中电流的计算方法与计算电枢绕组电流一致，采用叠加原理将实际的突然短路电流看成是以下两种工况的叠加：\n\n电机突然短路前稳定运行工况的电流\n在零初始状态下，电枢端突然加上与短路前大小相等、方向相反的电压时运行工况的电流\n\n即：\n\n求原来稳态三相对称运行时的转子电流if0i_{f0}if0​、iD0i_{D0}iD0​、iQ0i_{Q0}iQ0​\n求突然在电枢端加上电压−ud0-u_{d0}−ud0​、−uq0-u_{q0}−uq0​引起的转子电流if′i_f&#x27;if′​、iD′i_D&#x27;iD′​、iQ′i_Q&#x27;iQ′​\n突然三相短路后转子的实际电流为（1）、（2）所求电流的叠加，即\n\nif=if0+if′iD=iD0+iD′iQ=iQ0+iQ′i_f=i_{f0}+i_f&#x27;\\\\\ni_D=i_{D0}+i_D&#x27;\\\\\ni_Q=i_{Q0}+i_Q&#x27;\\\\\nif​=if0​+if′​iD​=iD0​+iD′​iQ​=iQ0​+iQ′​\n下面分三步求解转子电流：\n 求稳态三相对称运行时转子电流\n根据第二节空载运行的分析可知，稳态运行时励磁绕组电流，等于外加励磁电压在励磁绕组中产生的稳态直流电流，即\nif0=ufrfi_{f0}=\\frac{u_f}{r_f}\nif0​=rf​uf​​\n且稳态三相对称运行时阻尼绕组内电流为零，即\niD0=iQ0=0i_{D0}=i_{Q0}=0\niD0​=iQ0​=0\n 求突然加上电压−ud0-u_{d0}−ud0​、−uq0-u_{q0}−uq0​引起的转子电流\n","categories":["电气工程"]},{"title":"【矩阵论】矩阵分解","url":"/2024/10/20/%E3%80%90%E7%9F%A9%E9%98%B5%E8%AE%BA%E3%80%91%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/","content":" 满秩分解(Full Rank Factorization)\n将一个矩阵分解为两个较小矩阵的乘积，并且这两个矩阵的秩与原矩阵相同。满秩分解的目的是把矩阵表示为两个更简单矩阵的乘积，同时保持原矩阵的秩。\n 前置定理\n\n任何非零矩阵都存在满秩分解\n满秩分解可分为行满秩分解和列满秩分解\n满秩分解不唯一\n\n 行满秩分解步骤\n\n对矩阵AAA进行行变换，化为行最简形A^\\hat AA^，即每一行的第一个非零元素为1，并且是其所在的列的唯一一个非零元素\n标记每一个非零行的第一个非零元素所在的列，此处假设为1，2，3\nBBB为AAA的第1，2，3列，CCC为A^\\hat AA^的第1，2，3行\nA=BCA=BCA=BC即为行满秩分解\n\n 列满秩分解步骤\n\n对矩阵AAA进行列变换，化为列最简形A^\\hat AA^，即每一列的第一个非零元素为1，并且是其所在的行的唯一一个非零元素\n标记每一个非零列的第一个非零元素所在的行，此处假设为1，2，3\nCCC为AAA的第1，2，3行，BBB为A^\\hat AA^的第1，2，3列\nA=BCA=BCA=BC即为列满秩分解\n\n UR分解\n也被称为QR分解或正交三角分解。\n 前置定理\n\n若AAA为列满秩矩阵，则AAA可以唯一地被分解为A=URA=URA=UR，其中UUU为列满秩矩阵，RRR为正线上三角阵。\nUR分解是一种特殊的满秩分解。\n\n 步骤\n\n令A=[α1,α2,α3]A=[\\alpha_1,\\alpha_2,\\alpha_3]A=[α1​,α2​,α3​]\n将[α1,α2,α3][\\alpha_1,\\alpha_2,\\alpha_3][α1​,α2​,α3​]正交化、单位化，重新组合，即得到UUU\n根据A=URA=URA=UR，有R=UHAR=U^H AR=UHA，求出RRR\nUR分解即为A=URA=URA=UR\n\n 奇异值分解\n奇异值分解的形式为：\nA=U\n\\begin{bmatrix}\n\\Delta &amp; 0 \\\\\n0 &amp; 0\\\n\\end{bmatrix}\nV^H\n\n 前置定理\n\nAHAA^H AAHA和AAHAA^HAAH均为半正定，特征值均为非负实数\nAHAA^H AAHA和AAHAA^HAAH的非零特征值相同\n奇异值分解通常不唯一\n\n 步骤（方法一）\n该方法由AAHAA^HAAH求U1U_1U1​。\n\n求出AAHAA^HAAH的全部非零特征值，由大到小排列，并以此为序写出奇异值矩阵Δ\\DeltaΔ\n求出AAHAA^HAAH的所有特征值对应的特征向量，正交化加单位化后组合，得到矩阵UUU\n设AAHAA^HAAH有nnn个非零奇异值，则取出UUU的前nnn列，组合得到U1U_1U1​\n由V1=AHU1Δ−HV_1=A^HU_1\\Delta^{-H}V1​=AHU1​Δ−H，求得V1V_1V1​\n扩展V1V_1V1​至VVV，其中新添加的列向量V2V_2V2​应与V1V_1V1​正交化、单位化\n解毕\n\n 步骤（方法二）\n该方法由AHAA^HAAHA求V1V_1V1​。\n\n求出AHAA^HAAHA的全部非零特征值，由大到小排列，并以此为序写出奇异值矩阵Δ\\DeltaΔ\n求出AHAA^HAAHA的所有特征值对应的特征向量，正交化加单位化后组合，得到矩阵VVV\n设AHAA^HAAHA有nnn个非零奇异值，则取出VVV的前nnn列，组合得到V1V_1V1​\n由U1=AV1Δ−1U_1 = AV_1\\Delta^{-1}U1​=AV1​Δ−1，求得U1U_1U1​\n扩展U1U_1U1​至UUU，其中新添加的列向量U2U_2U2​应与U1U_1U1​正交化、单位化\n解毕\n\n 谱分解\n谱分解不唯一。\n 步骤\n\n求特征值及其所对应的特征向量\n无需进行正交化或单位化，组合特征向量，得到矩阵PPP\n求P−1P^{-1}P−1\n\n若特征值无重根：\n\n按照特征值次序iii，依次取PPP的第iii列和P−1P^{-1}P−1的第iii列，二者相乘，得到HiH_iHi​\n\n若特征值有重根：\n\n\n按照特征值次序iii，若某特征值有nnn重根，则在取列和行时一次性取nnn次，然后二者相乘，得到HiH_iHi​\n\n\n组合，证毕\n\n\n"},{"title":"以TPS5430为例进行DC-DC选型与设计","url":"/2024/08/19/%E4%BB%A5TPS5430%E4%B8%BA%E4%BE%8B%E8%BF%9B%E8%A1%8CDC-DC%E9%80%89%E5%9E%8B%E4%B8%8E%E8%AE%BE%E8%AE%A1/","content":"原文来自德州仪器（TI）：TPS5430 Datasheet\n本文将以德州仪器（TI）TPS5430 降压DC-DC转换器为例，剖析手册中的参数与技术指标，并进行选型方面的介绍，同时简要介绍高频DC-DC设计相关内容。\n 特性\n\n\n宽输入电压范围：\n\nTPS5430：5.5V 至 36V\nTPS5431：5.5V 至 23V\n\n\n\n高达 3A 的连续（4A 峰值）输出电流\n\n\n通过 100mΩ 集成式 MOSFET 开关实现高达 95%的高效率\n\n\n宽输出电压范围：可调节为低至 1.22V，初始精度为 1.5%\n\n\n内部补偿可最大限度减少外部器件数量\n\n\n适用于小型滤波器尺寸的固定 500kHz 开关频率\n\n\n通过输入电压前馈改进线路调整和瞬态响应\n\n\n系统受过流限制、过压保护和热关断的保护\n\n\n–40°C 至 125°C 的工作结温范围\n\n\n采用小型热增强型 8 引脚 SO PowerPAD™ 集成电路封装\n\n\n使用 TPS5430 并借助 WEBENCH® Power Designer 创建定制设计\n\n\n 应用\n\n消费类：机顶盒、DVD 显示屏、LCD 显示屏\n工业用和车载音频电源\n电池充电器、大功率 LED 电源\n12V 和 24V 分布式电源系统\n\n 说明\nTPS543x 是一款高输出电流 PWM 转换器，集成了低电阻、高侧 N 沟道 MOSFET。具有所列的特性的基板上还包括高性能电压误差放大器（可在瞬态条件下提供高稳压精度）、欠压锁定电路（用于防止在输入电压达到 5.5V 前启动）、内部设置的慢启动电路（用于限制浪涌电流）以及电压前馈电路（用于改进瞬态响应）。通过使用 ENA 引脚，关断电源电流通常可减少到15μA。其他特性包括高电平有效使能端、过流限制、过压保护和热关断。为降低设计复杂性并减少外部元件数量，对 TPS543x 反馈环路进行内部补偿。TPS5431可采用高达 23V 的电源轨运行。TPS5430 可调节多种电源，包括 24V 总线。\nTPS543x 器件采用热增强型且易于使用的 8 引脚 SOIC PowerPAD 集成电路封装。TI 提供评估模块和Designer 软件工具，协助快速实现高性能电源设计，满足迫切的设备开发周期要求。\n\n\n有关效率：DC-DC转换器的效率（Efficiency）表示输入功率中有多少被成功转换为输出功率，而非被损耗。它通常以百分比表示。效率高意味着大部分能量都被有效转换，只有少量能量因开关损耗、导通损耗、磁损耗等形式而被消耗为热量。DC-DC 转换器的效率通常会随着输入电压、输出电流、负载条件等变化而有所不同。一般来说，DC-DC 转换器的效率可以达到 85% 至 95% 甚至更高。较高的效率在电源设计中至关重要，因为它直接影响系统的功耗和热管理设计。\n\n 引脚配置和功能\n\n\n应当注意：\n\nVSENSE：反馈回路对噪声敏感，应当在PCB设计时进行特殊处理。\nENA：与其他型号的IC不同，TPS5430的使能在悬空（Float）时开启，低于0.5V即外部拉低时关闭。不过经验表明ENA被外部上拉时也能够开启使能。\nPH：即输出端。IC内部集成有N-MOSFET，其源极（S）即连接至PH引脚。\n\n\n 规格\n 绝对最大额定值\n\n\n应当注意：\n\n所有输入引脚禁止反接，即使设计有外部反接保护电路。\nENA引脚上拉后输入不得超过7V。\n接近 VIN 引脚的绝对最大额定值可能会导致 PH 引脚上的电压超过绝对最大额定值。\nIC输出端可能会在瞬态出现负电压脉冲，其一般由高di/dt与寄生电感共同作用引起。参见：如何解决负压脉冲\n表中的“拉电流”原文为“Source Current”，通常指的是FET向负载提供电流的能力。在开关模式中，FET在导通时从电源“拉”电流并传输到负载。当MOSFET处于关闭状态时，PH 引脚会呈现高阻抗状态。表中 PH 漏电流指的是在这种高阻抗状态下，PH 引脚仍然有少量的电流从引脚流出或流入（一般是流出）。手册中标注的 10 μA\\mu AμA 漏电流，表示在开关管关闭时，PH 引脚由于漏电效应产生的微小电流。这种电流通常很小，不会对系统性能造成显著影响，但在某些对精度要求较高的应用中，这些小电流可能需要考虑。\n\n\n ESD Ratings\n静电放电测试项，此处略。\n","categories":["电子与电路设计"]},{"title":"十二相同步整流发电机的数学模型","url":"/2024/09/13/%E5%8D%81%E4%BA%8C%E7%9B%B8%E6%95%B4%E6%B5%81%E5%8F%91%E7%94%B5%E6%9C%BA%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/","content":" 假设条件与正方向\n与常规同步发电机相比，多相整流发电机除了定子结构有差异，其转子也会有一定的区别。为了改善其运行稳定性,在常规同步发电机转子设置的励磁绕组(fdfdfd)、d轴阻尼绕组(kdkdkd)和q轴阳阻尼绕组(kqkqkq)三套绕组基础上，还会布置q轴稳定绕组(fqfqfq)。为了简化分析过程，并确保一定的分析精度，对十二相发电机的物理状态作如下基本假设:\n\n忽略铁心材料的饱和、磁滞及涡流影响，不计导线的集肤效应；\n忽略空间谐波磁场的影响，气隙磁场按正弦分布；\n忽略定、转子齿槽影响，认为定子和转子表面光滑；\n将转子上的阻尼回路看作两组等效的阻尼绕组，即DDD轴阻尼绕组和QQQ轴阻尼绕组。\n\n正方向规定如下：\n\n定子绕组电路采用发电机惯例，转子绕组电路采用电动机惯例；\n正方向的定子电流产生负的磁链，正方向的转子电流产生正的磁链；\n转子旋转正方向为逆时针方向，qqq轴正方向领先ddd轴正方向90°\\degree°电角度。\n\n\n\n abc坐标系下的基本方程\n磁链参数矩阵为：\nΨabc=[Ψa1Ψb1Ψc1Ψa2Ψb2Ψc2Ψa3Ψb3Ψc3Ψa4Ψb4Ψc4ΨfdΨkdΨfqΨkq]T\\Psi_{abc}=\n\\begin{bmatrix}\n\\Psi_{a1} &amp; \\Psi_{b1} &amp; \\Psi_{c1} &amp; \\Psi_{a2} &amp; \\Psi_{b2} &amp; \\Psi_{c2} &amp; \\Psi_{a3} &amp; \\Psi_{b3} &amp; \\Psi_{c3} &amp; \\Psi_{a4} &amp; \\Psi_{b4} &amp; \\Psi_{c4} &amp; \\Psi_{fd} &amp; \\Psi_{kd} &amp; \\Psi_{fq} &amp; \\Psi_{kq}\n\\end{bmatrix}^T\nΨabc​=[Ψa1​​Ψb1​​Ψc1​​Ψa2​​Ψb2​​Ψc2​​Ψa3​​Ψb3​​Ψc3​​Ψa4​​Ψb4​​Ψc4​​Ψfd​​Ψkd​​Ψfq​​Ψkq​​]T\n式中前12项下标为12个相位的标号，后四项中\n\nΨfd\\Psi_{fd}Ψfd​：励磁绕组磁链\nΨkd\\Psi_{kd}Ψkd​：直轴阻尼绕组磁链\nΨfq\\Psi_{fq}Ψfq​：交轴稳定绕组磁链\nΨkq\\Psi_{kq}Ψkq​：交轴阻尼绕组磁链\n\n电压参数矩阵为\nuabc=[ua1ub1uc1ua2ub2uc2ua3ub3uc3ua4ub4uc4ufdukdufqukq]Tu_{abc}=\n\\begin{bmatrix}\nu_{a1} &amp; u_{b1} &amp; u_{c1} &amp; u_{a2} &amp; u_{b2} &amp; u_{c2} &amp; u_{a3} &amp; u_{b3} &amp; u_{c3} &amp; u_{a4} &amp; u_{b4} &amp; u_{c4} &amp; u_{fd} &amp; u_{kd} &amp; u_{fq} &amp; u_{kq}\n\\end{bmatrix}^T\nuabc​=[ua1​​ub1​​uc1​​ua2​​ub2​​uc2​​ua3​​ub3​​uc3​​ua4​​ub4​​uc4​​ufd​​ukd​​ufq​​ukq​​]T\n电流参数矩阵为\niabc=[ia1ib1ic1ia2ib2ic2ia3ib3ic3ia4ib4ic4ifdikdifqikq]Ti_{abc}=\n\\begin{bmatrix}\ni_{a1} &amp; i_{b1} &amp; i_{c1} &amp; i_{a2} &amp; i_{b2} &amp; i_{c2} &amp; i_{a3} &amp; i_{b3} &amp; i_{c3} &amp; i_{a4} &amp; i_{b4} &amp; i_{c4} &amp; i_{fd} &amp; i_{kd} &amp; i_{fq} &amp; i_{kq}\n\\end{bmatrix}^T\niabc​=[ia1​​ib1​​ic1​​ia2​​ib2​​ic2​​ia3​​ib3​​ic3​​ia4​​ib4​​ic4​​ifd​​ikd​​ifq​​ikq​​]T\n因直轴阻尼绕组、交轴阻尼绕组和交轴稳定绕组均短接，有ukd=ukq=ufq=0u_{kd}=u_{kq}=u_{fq}=0ukd​=ukq​=ufq​=0。\n相应的磁链方程和电压方程为\nΨabc=Labciiabcuabc=pΨabc−Rabciabc\\Psi_{abc}=L_{abci}i_{abc} \\\\ \nu_{abc}=p\\Psi_{abc}-R_{abc}i_{abc}\nΨabc​=Labci​iabc​uabc​=pΨabc​−Rabc​iabc​\n式中\nLabc=[L11L12L13L14L1rL21L22L23L24L2rL31L32L33L34L3rL41L42L43L44L4r−L1rT−L2rT−L3rT−L4rTLrr]L_{abc}=\n\\begin{bmatrix}\nL_{11} &amp; L_{12} &amp; L_{13} &amp; L_{14} &amp; L_{1r} \\\\\nL_{21} &amp; L_{22} &amp; L_{23} &amp; L_{24} &amp; L_{2r} \\\\\nL_{31} &amp; L_{32} &amp; L_{33} &amp; L_{34} &amp; L_{3r} \\\\\nL_{41} &amp; L_{42} &amp; L_{43} &amp; L_{44} &amp; L_{4r} \\\\\n-L_{1r}^T &amp; -L_{2r}^T &amp; -L_{3r}^T &amp; -L_{4r}^T &amp; L_{rr} \\\\\n\\end{bmatrix}\nLabc​=⎣⎢⎢⎢⎢⎢⎡​L11​L21​L31​L41​−L1rT​​L12​L22​L32​L42​−L2rT​​L13​L23​L33​L43​−L3rT​​L14​L24​L34​L44​−L4rT​​L1r​L2r​L3r​L4r​Lrr​​⎦⎥⎥⎥⎥⎥⎤​\n式中Lij,i=1,2,3,4;i=1,2,3,4L_{ij},i=1,2,3,4;i=1,2,3,4Lij​,i=1,2,3,4;i=1,2,3,4为分块矩阵，具体为\nLij=[−Laiaj−Laibj−Laicj−Lbiaj−Lbibj−Lbicj−Lciaj−Lcibj−Lcicj]L_{ij}=\n\\begin{bmatrix}\n-L_{aiaj} &amp; -L_{aibj} &amp; -L_{aicj} \\\\\n-L_{biaj} &amp; -L_{bibj} &amp; -L_{bicj} \\\\\n-L_{ciaj} &amp; -L_{cibj} &amp; -L_{cicj} \\\\\n\\end{bmatrix}\nLij​=⎣⎢⎡​−Laiaj​−Lbiaj​−Lciaj​​−Laibj​−Lbibj​−Lcibj​​−Laicj​−Lbicj​−Lcicj​​⎦⎥⎤​\n矩阵中−Laiaj-L_{aiaj}−Laiaj​表示aiaiai相电枢绕组与ajajaj相电枢绕组之间的互感/自感。因正方向中规定正方向的定子电流产生负的磁链，所以所有电感均带负号。\n同理，式中Lir,i=1,2,3,4L_{ir},i=1,2,3,4Lir​,i=1,2,3,4也为分块矩阵，具体为\nLir=[LaifdLaikdLaifqLaikqLbifdLbikdLbifqLbikqLcifdLcikdLcifqLcikq]L_{ir}=\n\\begin{bmatrix}\nL_{aifd} &amp; L_{aikd} &amp; L_{aifq} &amp; L_{aikq} \\\\\nL_{bifd} &amp; L_{bikd} &amp; L_{bifq} &amp; L_{bikq} \\\\\nL_{cifd} &amp; L_{cikd} &amp; L_{cifq} &amp; L_{cikq} \\\\\n\\end{bmatrix}\nLir​=⎣⎢⎡​Laifd​Lbifd​Lcifd​​Laikd​Lbikd​Lcikd​​Laifq​Lbifq​Lcifq​​Laikq​Lbikq​Lcikq​​⎦⎥⎤​\n矩阵中LaifdL_{aifd}Laifd​表示电枢aiaiai相绕组与转子励磁绕组的互感，其余同理。因正方向中规定正方向的转子电流产生正的磁链，所以所有电感均为正。\n同理，式中LrrL_{rr}Lrr​表示转子各绕组之间的自感/互感，具体为\nLrr=[LfdLfdkd00LfdkdLkd0000LfqLfqkq00LfqkqLkq]L_{rr}=\n\\begin{bmatrix}\nL_{fd} &amp; L_{fdkd} &amp; 0 &amp; 0 \\\\\nL_{fdkd} &amp; L_{kd} &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; L_{fq} &amp; L_{fqkq} \\\\\n0 &amp; 0 &amp; L_{fqkq} &amp; L_{kq} \\\\\n\\end{bmatrix}\nLrr​=⎣⎢⎢⎢⎡​Lfd​Lfdkd​00​Lfdkd​Lkd​00​00Lfq​Lfqkq​​00Lfqkq​Lkq​​⎦⎥⎥⎥⎤​\n矩阵中LfdL_{fd}Lfd​为励磁绕组的自感，LfdkdL_{fdkd}Lfdkd​为励磁绕组与直轴阻尼绕组的互感，其余同理。因为励磁绕组与交轴阻尼绕组、励磁绕组与交轴稳定绕组、直轴阻尼绕组与交轴阻尼绕组、直轴阻尼绕组与交轴稳定绕组的电角度夹角均为90°\\degree°，所以有Lfdkq=Lfdfq=Lkdkq=Lkdfq=0L_{fdkq}=L_{fdfq}=L_{kdkq}=L_{kdfq}=0Lfdkq​=Lfdfq​=Lkdkq​=Lkdfq​=0。\n电感矩阵中各量的详细表达式略。\n dq0坐标系下的基本方程\n 变换矩阵\n应用推广的三相电机Park变换，取变换矩阵为\nCdq0abc(θ)=[C11C22C33C44I]C^{abc}_{dq0}(\\theta)=\n\\begin{bmatrix}\nC_{11} &amp; &amp; &amp; &amp; \\\\\n&amp; C_{22} &amp; &amp; &amp; \\\\\n&amp; &amp; C_{33} &amp; &amp; \\\\\n&amp; &amp; &amp; C_{44} &amp; \\\\\n&amp; &amp; &amp; &amp; I \\\\\n\\end{bmatrix}\nCdq0abc​(θ)=⎣⎢⎢⎢⎢⎢⎡​C11​​C22​​C33​​C44​​I​⎦⎥⎥⎥⎥⎥⎤​\n式中III为4×44\\times 44×4的单位矩阵，其对应的变换对象为转子部分参数，显然该部分无需进行Park变换。\n式中，\nCii=23[cos⁡[θ−(i−1)15°]cos⁡[θ−120°−(i−1)15°]cos⁡[θ+120°−(i−1)15°]−sin⁡[θ−(i−1)15°]−sin⁡[θ−120°−(i−1)15°]−sin⁡[θ+120°−(i−1)15°]121212]C_{ii}=\n\\frac{2}{3}\n\\begin{bmatrix}\n\\cos[\\theta-(i-1)15\\degree] &amp; \\cos[\\theta-120\\degree-(i-1)15\\degree] &amp; \\cos[\\theta+120\\degree-(i-1)15\\degree] \\\\\n-\\sin[\\theta-(i-1)15\\degree] &amp; -\\sin[\\theta-120\\degree-(i-1)15\\degree] &amp; -\\sin[\\theta+120\\degree-(i-1)15\\degree] \\\\\n\\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{1}{2}\\\\\n\\end{bmatrix}\nCii​=32​⎣⎢⎡​cos[θ−(i−1)15°]−sin[θ−(i−1)15°]21​​cos[θ−120°−(i−1)15°]−sin[θ−120°−(i−1)15°]21​​cos[θ+120°−(i−1)15°]−sin[θ+120°−(i−1)15°]21​​⎦⎥⎤​\n 磁链的电压的参数方程\n利用推广的Park变换得到dq0坐标系的磁链方程和电压方程为\nΨdq0=Ldq0idq0udq0=pΨdq0+AΨdq0ω−Rdq0idq0\\Psi_{dq0}=L_{dq0}i_{dq0} \\\\\nu_{dq0}=p\\Psi_{dq0}+A\\Psi_{dq0}\\omega-R_{dq0}i_{dq0}\nΨdq0​=Ldq0​idq0​udq0​=pΨdq0​+AΨdq0​ω−Rdq0​idq0​\nω\\omegaω为转子的瞬时转速，ω=pθ\\omega=p\\thetaω=pθ。第二项实际对应的就是Park变换后因线圈元件和磁链间相对运动产生的运动电动势。\n式中\nΨdq0=Cdq0abc(θ)Ψabc=[Ψd1Ψq1Ψ01Ψd2Ψq2Ψ02Ψd3Ψq3Ψ03Ψd4Ψq4Ψ04ΨfdΨkdΨfqΨkq]T\\Psi_{dq0}=C_{dq0}^{abc}(\\theta)\\Psi_{abc}=\n\\begin{bmatrix}\n\\Psi_{d1} &amp; \\Psi_{q1} &amp; \\Psi_{01} &amp; \\Psi_{d2} &amp; \\Psi_{q2} &amp; \\Psi_{02} &amp; \\Psi_{d3}  &amp; \\Psi_{q3}  &amp; \\Psi_{03} &amp; \\Psi_{d4} &amp; \\Psi_{q4} &amp; \\Psi_{04} &amp; \\Psi_{fd} &amp; \\Psi_{kd} &amp;  \\Psi_{fq} &amp; \\Psi_{kq}      \n\\end{bmatrix}^T\nΨdq0​=Cdq0abc​(θ)Ψabc​=[Ψd1​​Ψq1​​Ψ01​​Ψd2​​Ψq2​​Ψ02​​Ψd3​​Ψq3​​Ψ03​​Ψd4​​Ψq4​​Ψ04​​Ψfd​​Ψkd​​Ψfq​​Ψkq​​]T\nidq0=Cdq0abc(θ)iabc=[id1iq1i01id2iq2i02id3iq3i03id4iq4i04ifdikdifqikq]Ti_{dq0}=C_{dq0}^{abc}(\\theta)i_{abc}=\n\\begin{bmatrix}\ni_{d1} &amp; i_{q1} &amp; i_{01} &amp; i_{d2} &amp; i_{q2} &amp; i_{02} &amp; i_{d3}  &amp; i_{q3}  &amp; i_{03} &amp; i_{d4} &amp; i_{q4} &amp; i_{04} &amp; i_{fd} &amp; i_{kd} &amp;  i_{fq} &amp; i_{kq}      \n\\end{bmatrix}^T\nidq0​=Cdq0abc​(θ)iabc​=[id1​​iq1​​i01​​id2​​iq2​​i02​​id3​​iq3​​i03​​id4​​iq4​​i04​​ifd​​ikd​​ifq​​ikq​​]T\nudq0=Cdq0abc(θ)uabc=[ud1uq1u01ud2uq2u02ud3uq3u03ud4uq4u04ufd000]Tu_{dq0}=C_{dq0}^{abc}(\\theta)u_{abc}=\n\\begin{bmatrix}\nu_{d1} &amp; u_{q1} &amp; u_{01} &amp; u_{d2} &amp; u_{q2} &amp; u_{02} &amp; u_{d3}  &amp; u_{q3}  &amp; u_{03} &amp; u_{d4} &amp; u_{q4} &amp; u_{04} &amp; u_{fd} &amp; 0 &amp;  0 &amp; 0      \n\\end{bmatrix}^T\nudq0​=Cdq0abc​(θ)uabc​=[ud1​​uq1​​u01​​ud2​​uq2​​u02​​ud3​​uq3​​u03​​ud4​​uq4​​u04​​ufd​​0​0​0​]T\nA=[A11A22A33A440]A=\n\\begin{bmatrix}\nA_{11} &amp; &amp; &amp; &amp; \\\\\n&amp; A_{22} &amp; &amp; &amp; \\\\\n&amp; &amp; A_{33} &amp; &amp; \\\\\n&amp; &amp; &amp; A_{44} &amp; \\\\\n&amp; &amp; &amp; &amp; 0 \\\\\n\\end{bmatrix}\nA=⎣⎢⎢⎢⎢⎢⎡​A11​​A22​​A33​​A44​​0​⎦⎥⎥⎥⎥⎥⎤​\n该矩阵中的分块矩阵为\nAii=[0−10100000],i=1,2,3,4A_{ii}=\n\\begin{bmatrix}\n0 &amp; -1 &amp; 0 \\\\\n1 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 0\n\\end{bmatrix},\ni=1,2,3,4\nAii​=⎣⎢⎡​010​−100​000​⎦⎥⎤​,i=1,2,3,4\nRdq0=RabcR_{dq0} = R_{abc}\nRdq0​=Rabc​\nLdq0=[D11D12D13D14D1rD21D22D23D24D2rD31D32D33D34D3rD41D42D43D44D4r−Dr1−Dr2−Dr3−Dr4Lrr]L_{dq0}=\n\\begin{bmatrix}\nD_{11} &amp; D_{12} &amp;D_{13} &amp; D_{14} &amp; D_{1r} \\\\\nD_{21} &amp; D_{22} &amp;D_{23} &amp; D_{24} &amp; D_{2r} \\\\\nD_{31} &amp; D_{32} &amp;D_{33} &amp; D_{34} &amp; D_{3r} \\\\\nD_{41} &amp; D_{42} &amp;D_{43} &amp; D_{44} &amp; D_{4r} \\\\\n-D_{r1} &amp; -D_{r2} &amp; -D_{r3} &amp; -D_{r4} &amp; L_{rr} \\\\\n\\end{bmatrix}\nLdq0​=⎣⎢⎢⎢⎢⎢⎡​D11​D21​D31​D41​−Dr1​​D12​D22​D32​D42​−Dr2​​D13​D23​D33​D43​−Dr3​​D14​D24​D34​D44​−Dr4​​D1r​D2r​D3r​D4r​Lrr​​⎦⎥⎥⎥⎥⎥⎤​\n Dii（对角线元素）矩阵\nDii=[−Ldy−Lqy−L0y]D_{ii}=\n\\begin{bmatrix}\n-L_{dy} &amp; &amp; \\\\\n &amp; -L_{qy} &amp; \\\\\n &amp; &amp; -L_{0y} \\\\\n\\end{bmatrix}\nDii​=⎣⎢⎡​−Ldy​​−Lqy​​−L0y​​⎦⎥⎤​\n该矩阵中，有\nLdy=Lsy+LadyLqy=Lsy+LaqyL0y=Lss+2Ls8L_{dy}=L_{sy}+L_{ady} \\\\\nL_{qy}=L_{sy}+L_{aqy} \\\\\nL_{0y}=L_{ss}+2L_{s8} \\\\\nLdy​=Lsy​+Lady​Lqy​=Lsy​+Laqy​L0y​=Lss​+2Ls8​\n式中，下标yyy表示单Y绕组参数，下标sss表示漏电感，其中\n\nLdyL_{dy}Ldy​：单Y绕组直轴同步电感\nLsyL_{sy}Lsy​：单Y绕组漏电感，其是由相绕组的自漏感LssL_{ss}Lss​和互漏感Ls8L_{s8}Ls8​所组成的新电感\nLadyL_{ady}Lady​：单Y绕组直轴电枢反应电感\nLqyL_{qy}Lqy​：单Y绕组交轴同步电感\nLaqyL_{aqy}Laqy​：单Y绕组交轴电枢反应电感\nL0yL_{0y}L0y​：单Y绕组零轴同步电感\n\n D12、D23、D34矩阵\nD12=D23=D34=[−Ldm1Ldqm10−Ldqm1−Lqm1000−L0m1]D_{12}=D_{23}=D_{34}=\n\\begin{bmatrix}\n-L_{dm1} &amp; L_{dqm1} &amp; 0 \\\\\n-L_{dqm1} &amp; -L_{qm1} &amp; 0 \\\\\n0 &amp; 0 &amp; -L_{0m1} \\\\\n\\end{bmatrix}\nD12​=D23​=D34​=⎣⎢⎡​−Ldm1​−Ldqm1​0​Ldqm1​−Lqm1​0​00−L0m1​​⎦⎥⎤​\n该矩阵中，下标m1m_1m1​表示相差15°15\\degree15°电角度的两Y绕组的互感参数,下标sss表示漏电感，有：\nLdm1=Lsm1+LadyLdqm1=Ls1sin⁡15°−Ls7sin⁡105°+Ls9sin⁡135°Lqm1=Lsm1+LaqyL0m1=Ls1+Ls7+Ls9L_{dm1}=L_{sm1}+L_{ady} \\\\\nL_{dqm1}=L_{s1}\\sin15\\degree-L_{s7}\\sin105\\degree+L_{s9}\\sin135\\degree \\\\\nL_{qm1}=L_{sm1}+L_{aqy} \\\\\nL_{0m1}=L_{s1}+L_{s7}+L_{s9} \\\\\nLdm1​=Lsm1​+Lady​Ldqm1​=Ls1​sin15°−Ls7​sin105°+Ls9​sin135°Lqm1​=Lsm1​+Laqy​L0m1​=Ls1​+Ls7​+Ls9​\n其中\n","categories":["电气工程"]},{"title":"十九阶同步发电机组模型降阶研究","url":"/2024/09/14/%E5%8D%81%E4%B9%9D%E9%98%B6%E5%90%8C%E6%AD%A5%E5%8F%91%E7%94%B5%E6%9C%BA%E7%BB%84%E6%A8%A1%E5%9E%8B%E9%99%8D%E9%98%B6%E7%A0%94%E7%A9%B6/","content":" 摘要\n本文介绍了一个二阶同步电机模型库，可用于电力系统动态性能分析和控制设计任务。这些模型的结构与经典模型相似，因为它们由两个动态状态组成，即功率夹角和角速度。然而，与经典模型不同，这些模型的应用范围不仅限于第一次摆动稳定性分析；例如，它们还可用于暂态稳定性研究。这些模型是通过使用奇异摄动技术系统地简化十九阶同步发电机组模型而开发的，并通过将其电压、频率和相位曲线与高阶模型和经典模型的电压、频率和相位曲线进行比较来验证。\n 介绍\n同步电机的动态模型可用于电力系统分析、控制设计任务，每种应用都需要能够捕捉与预期用途相关的动态现象的模型。这导致文献中同步电机模型的激增，这些模型的复杂度、计算成本和状态空间维度各不相同。其中一种模型是之前研究提倡的所谓经典模型，这是一种二阶动态模型，可以捕捉电机相位和角速度的动态。\n从分析上看，经典模型是最简单的同步机动力学模型，但它具有某些局限性，限制了其应用于第一次摆动稳定性分析，即第一秒的稳定性分析。因此，如果我们考虑到电力系统在第一次摆动时可能稳定，但在后续摆动时不稳定，那么很明显，经典模型虽然简单，但对于超过一秒时间间隔的电力系统任务来说并不可靠。例如，发电机同步方案的设计需要一个模型来捕捉整个同步周期内发电机相位、频率和电压幅度的动态。二阶模型（如经典模型）应该能够满足要求，但如果同步周期超过一秒，第一次摆动稳定性约束可能会使其不适用。另一方面，虽然现有的高阶模型（如双轴模型和单轴模型）显然更准确，因此对电力系统仿真非常有用，但它们也更加复杂且计算成本高昂。因此，高阶模型通常难以分析此类控制设计任务。因此，需要开发既具有经典模型的简单性，又具有经典模型所缺乏的时间广度的模型。\n本文的主要贡献是开发了二阶同步发电机模型，与经典模型相比，该模型具有相同的状态空间维度，在长时间间隔内更精确，并且适​​用于更广泛的应用。使用奇异摄动分析作为主要工具，本文提出的二阶模型是通过以下方式推导出来的：(i) 识别高阶模型中最快的动态状态；(ii) 为它们开发近似流形方程（代数方程）；(iii) 用代数方程替换这些状态的微分方程。\n我们开发所提出的机器模型的方法是基于中的开发，其中使用快速动态状态的零阶和一阶流形近似来开发降阶模型。\n本文的其余部分安排如下。在第二部分中，我们介绍了一个同步机和一个高阶模型，该模型被用作开发降阶模型的起点；我们还讨论了经典模型。在第三部分中，我们使用奇异摄动分析从高阶模型开发了一个二阶模型库。最后，在第四部分中，我们使用数值示例验证了开发的二阶模型，在第五部分中，我们评论了所给出结果的含义。\n 准备工作\n本节首先介绍本文采用的同步电机高阶模型。此外，还讨论了该模型的时间尺度特性。之后，我们介绍所谓的经典模型，并描述如何从高阶模型开发出该模型。\n 高阶同步发电机模型\n本节中介绍的高阶同步机模型基于参考文献中的开发成果。模型中包含的组件包括：(i) 三个阻尼绕组，(ii) 绕线式转子结构同步发电机，(iii) IEEE DC1A 型励磁系统，以及 (iv) 伍德沃德柴油调速器 (DEGOV1)，与柴油发动机耦合，作为原动机。接下来，我们提供描述这些组件动态行为的数学表达式。（请注意，该模型采用 Park 变换后的dq0坐标系呈现，所有参数和变量均经过缩放，并使用单位系统进行归一化）。\n 阻尼绕组模型\n令 ψkq\\psi_{kq}ψkq​ 和 ψfq\\psi_{fq}ψfq​ 表示交轴阻尼绕组和交轴稳定绕组的磁链，令 ψkd\\psi_{kd}ψkd​ 和 ψfd\\psi_{fd}ψfd​ 分别表示直轴阻尼绕组和励磁绕组的磁链，令 A 和 B 分别表示定子输出电流的 q 轴和 d 轴分量。那么，阻尼绕组动力学可以描述如下：\nTq′′pψkq=−ψkq−(Xq′−Xk)Iq−Ed′Td′′pψkd=−ψkd−(Xd′−Xk)Id+Eq′(t)T_q&#x27;&#x27; p\\psi_{kq}=-\\psi_{kq}-(X_q&#x27;-X_k)I_q-E_d&#x27;\\\\\nT_d&#x27;&#x27;p\\psi_{kd}=-\\psi_{kd}-(X_d&#x27;-X_k)I_d+E_q&#x27;(t)\nTq′′​pψkq​=−ψkq​−(Xq′​−Xk​)Iq​−Ed′​Td′′​pψkd​=−ψkd​−(Xd′​−Xk​)Id​+Eq′​(t)\n以及\nTq′pψfq=−ψfq+(Xq−Xq′)(Iq−Xq′−Xq′′(Xq′−Xk)2(ψkq+(Xq′−Xk)Iq−ψfq))T_q&#x27;p\\psi_{fq}=-\\psi_{fq}+(X_q-X_q&#x27;)(I_q-\\frac{X_q&#x27;-X_q&#x27;&#x27;}{(X_q&#x27;-X_k)^2}(\\psi_{kq}+(X_q&#x27;-X_k)I_q-\\psi_{fq}))\nTq′​pψfq​=−ψfq​+(Xq​−Xq′​)(Iq​−(Xq′​−Xk​)2Xq′​−Xq′′​​(ψkq​+(Xq′​−Xk​)Iq​−ψfq​))\n式中\n\nXkX_kXk​：电机漏电抗\nXqX_qXq​：电机定子电抗\nXq′X_q&#x27;Xq′​，Xd′X_d&#x27;Xd′​：电机瞬态电抗\nXq′′X_q&#x27;&#x27;Xq′′​:电机超瞬态电抗\n\n","categories":["电气工程"]},{"title":"在Hexo中启用新Markdown解释器并配置Katex","url":"/2024/07/11/%E5%9C%A8Hexo%E4%B8%AD%E5%90%AF%E7%94%A8%E6%96%B0Markdown%E8%A7%A3%E9%87%8A%E5%99%A8%E5%B9%B6%E9%85%8D%E7%BD%AEKatex/","content":" Markdown编译器\n在 Hexo 中，如果默认的 Markdown 编译器无法正确渲染 LaTeX 公式，可以考虑使用支持 LaTeX 公式的 Markdown 编译器插件。常用的包括：\n\nhexo-renderer-pandoc\nhexo-renderer-markdown-it\nhexo-filter-mathjax\nhexo-renderer-markdown-it-plus\n\n推荐使用hexo-renderer-markdown-it-plus.\n hexo-renderer-markdown-it-plus 安装与配置\n\n卸载旧的渲染器：\n\nnpm uninstall hexo-renderer-marked --save\n\n安装hexo-renderer-markdown-it-plus：\n\n在Hexo根目录中打开Git Bash，然后：\nnpm install hexo-renderer-markdown-it-plus --save\n\n配置_config.yml：\n\n添加以下配置：\nmarkdown:  render:    engine: markdown-it-plus    options:      html: true      xhtmlOut: true      breaks: true      linkify: true      typographer: true      quotes: &#x27;“”‘’&#x27;      plugins:        - plugin:            name: markdown-it-katex            options:              throwOnError: false              errorColor: &#x27;#cc0000&#x27;\n 引入KaTeX的CSS\n为了避免公式错位问题，需要确保正确引入 KaTeX 的 CSS 文件。在主题布局文件（通常是 themes/your-theme/layout/_partial/head.ejs）中添加以下代码：\n&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css&quot;&gt;\n","categories":["建站相关"]},{"title":"将基于Hexo的个人网站提交至Google收录","url":"/2024/07/13/%E5%B0%86%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E6%8F%90%E4%BA%A4%E8%87%B3Google%E6%94%B6%E5%BD%95/","content":" 简介\nHexo博客生成并部署后，无论是部署至第三方平台（如Github Pages），还是部署至私有服务器然后定向至个人域名，都需要人工向搜索引擎提交收录。简单来说这一过程就是把该网站的内容和地址“告诉”搜索引擎，让搜索引擎“认识”你。这样当下次有人在搜索引擎中搜索与你博客有关联的内容时，搜索引擎就能够发现你了。\n我们以Google为例，要完成这个过程，通常需要以下步骤：\n\n确认博客是否被收录\n验证网站所有者\n生成并提交站点地图（sitemap）\n等待收录\n\n 一、确认博客是否被收录\n以本网站为例，打开Google，输入site:akichen891.github.io\n\n如果Google提示“找不到相符的内容”，则说明你的网站尚未被Google收录。如果网站已经被收录，Google会自动查询和网站有关的内容。\n 二、验证网站所有者\n只有向搜索引擎添加并认证网站，证明自己是该域名的拥有者和管理者后，搜索引擎可以快速批量添加该域名下的所有子站点，而无需一一验证。认证完成后还可以使用Google Console查看并管理网站的访问统计等、\n要进行验证，首先前往Google Console。\nGoogle Console会要求选择资源类型。\n\n选择“网址前缀”，在输入框中输入带http://或https://前缀的完整主域名，然后点击“继续”。\nGoogle提供五种验证方法：\n\nHTML文件\nHTML标记\nGoogle Analytics\nGoogle跟踪代码管理器\n域名提供商\n\n这几种方法依次为从简到难。这里只介绍头两种。\n HTML文件验证\n这是最简单的一种验证方法，具体步骤Google也写的很清楚。\n\n点击下载这个.html文件，对于Hexo，将该文件放在Hexo根目录下/source文件中。然后hexo g -d，等待部署。当你能够在浏览器中输入https://example.blog/googleXXXXXXX.html并成功跳转时，说明该文件已经添加成功。\n回到Google Console，点击验证，正常情况下Google Console很快就会提示验证成功。\n如果使用该方法却一直提示验证失败，可以用第二种方法。\n HTML标记验证\n这种方法和第一种方法非常类似，只不过将验证文件变成了一个html元标记。\n\n按照要求，复制元标记。对于Hexo博客，这个所谓的“首页”文件的位置可能有所不同。对于Fluid主题，该文件即为\\node_modules\\hexo-theme-fluid\\layout\\_partials目录下的head.ejs.\n按照Google的要求，在&lt;head&gt;中粘贴该元标记。\n\n之后，hexo clean，然后hexo g -d，等待部署。部署完成后在Google Console中点击验证。\n 三、站点地图(Sitemap)\n 什么是站点地图？\n\n站点地图是网站上的一个文件，可以让 Google 知道应该了解网站上的哪些网页。如果您使用了网站托管服务（比如 Squarespace 或 Wix），这些服务可能会为您管理站点地图，这样的话，您就无需创建自己的站点地图，也无需使用此报告。若想了解站点地图的相关信息，请搜索您的托管服务提供商。如果您的网站规模较小（少于 100 个网页），并且您可以通过追踪首页上的一个或多个链接到达网站上的任何网页，则可能无需使用站点地图或此报告。在这种情况下，只需请求将您的首页编入索引即可（除非您使用的是上述网站托管服务，在这种情况下您无需执行任何操作）。\n\n 为Hexo生成站点地图\n为启用站点地图，首先要在Hexo根目录中Git Bash来安装插件：\nnpm install hexo-generator-sitemap --save\n在站点配置文件（不是主题配置文件！）_config.yml中添加：\n# Auto Generate sitemapsitemap:path: sitemap.xml\n然后hexo g -d，若/public文件夹下生成了sitemap.xml，并且浏览器能够访问https://example.blog/sitemap.xml，说明创建成功。\n 向Google提交站点地图\n在Google Console中，左侧栏选择“站点地图”，在“添加新的站点地图”中，输入你的站点地图网址，比如sitemap.xml。\n\n提交成功后，Google会在“已提交的站点地图”中显示该sitemap。\n\n索引需要一段时间编制并生效。通常情况下，48小时内Google即可完成收录。\n","categories":["建站相关"]},{"title":"数据结构笔记【1】","url":"/2024/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%E3%80%901%E3%80%91/","content":" 数据的三种结构\n 逻辑结构\n包含：\n\n集合\n线性结构（一对一），如线性表、栈、队列\n树形结构 一个对多个\n图状结构 多个对多个\n\n 存储结构\n\n顺序存储：按照逻辑顺序存放于连续空间\n链式存储（重点）：放到存储区的不同位置，用地址（指针）方式建立逻辑上的联系\n索引存储：建立附加的索引表（电话簿）\n散列存储：依据数据元素的特殊字段（关键字key）计算元素的存放地址，然后按地址存放\n\n 线性表\n线性表是包含若干数据元素的一个线性序列，记为\nL=(a0,...,ai−1,ai,ai+1,...,an−1)L=(a_0,...,a_{i-1},a_i,a_{i+1},...,a_{n-1})\nL=(a0​,...,ai−1​,ai​,ai+1​,...,an−1​)\nLLL为表名，aia_iai​为数据元素，nnn为表长，n&gt;0n&gt;0n&gt;0时表为非空表，否则为空表\n线性表可以用二元组形式描述\nL=(D,R)L=(D,R)\nL=(D,R)\n即线性表LLL包含数据元素集合DDD和关系集合RRR\n\n关系符&lt;aia_iai​,ai+1a_{i+1}ai+1​&gt;为有序对\n表示任意两个相邻元素之间的先后次序\n\nE.g.E.g.E.g. 有顺序表L={1,2,3,4,5,6}，若使用L=(D,R)L=(D,R)L=(D,R)表示，则D=1,2,3,4,5,6D={1,2,3,4,5,6}D=1,2,3,4,5,6,R=&lt;1,2&gt;,&lt;2,3&gt;,...R=&lt;1,2&gt;,&lt;2,3&gt;,...R=&lt;1,2&gt;,&lt;2,3&gt;,...\n线性表的特征：\n\n表头无前驱\n表尾无后继\n其余元素仅有一个直接前驱和直接后继\n\n顺序存储结构的特点：\n\n逻辑上相邻，则存储位置也相邻\n对元素的存取为随机存取或按地址存储\n存储密度高\n对表的插入和删除等运算的时间复杂度高\n\nC语言中，可借助一维数组类型来表述线性表的顺序存储结构\n/*    * @brief:创建新线性表    * @param:无    * @return:线性表指针(sqlink类型)，申请失败返回NULL*/sqlink list_create()&#123;    sqlink L;   //声明sqlink类型的表L    L = (sqlink)malloc(sizeof(sqlist));  // 为空表申请内存，返回分配的内存地址        //判断内存是否申请成功    if (L == NULL)    &#123;        printf(&quot;memory allocation failed\\n&quot;);        return NULL;    &#125;    memset(L, 0, sizeof(sqlist));   //L指向的sqlist结构体的内存清零    L-&gt;last = -1;   //表示线性表为空    return L;&#125;/*    * @brief:清除线性表内的元素，全部置为零    * @param: L:指向表的指针    * @return:成功返回0，失败返回-1*/int list_clear(sqlink L)&#123;    //判断是否是空表    if (L == NULL)    &#123;        return -1;    &#125;    memset(L, 0, sizeof(sqlist));   //L指向的sqlist结构体的内存清零    L-&gt;last = -1;   //last置为-1，表示线性表为空     return 0;&#125;/*    * @brief:判断线性表是否为空表    * @param: L:指向线性表的指针    * @return:空表返回1，非空表返回0*/int list_empty(sqlink L)&#123;    //判断是否为空表    if (L-&gt;last == -1)    &#123;        return 1;    &#125;    else    &#123;        return 0;    &#125;&#125;/*    * @brief:求线性表的长度(有效元素个数)    * @param: L:指向线性表的指针    * @return:表不存在返回-1，否则返回长度*/int list_length(sqlink L)&#123;    if (L == NULL)    &#123;        return -1;    &#125;    return (L-&gt;last + 1);   //长度为表尾下标加1&#125;/*    * @brief:向线性表内插入数值，插入后原位置向后的所有元素后移一位    * @param: L:指向线性表的指针     * @param: value:待插入值     * @param: pos:插入位置    * @return:插入成功返回0，失败返回-1*/int list_insert(sqlink L, data_t value, int pos)&#123;    if (L == NULL) return -1;   //表不存在返回-1    //判断线性表是否满    if (L-&gt;last == N - 1)    &#123;        printf(&quot;table is full\\n&quot;);        return -1;    &#125;    //检查插入位置是否正确，应属于[0,last]，如果是空表则不检查    if (pos &lt; 0 || pos &gt;= L-&gt;last + 1)    &#123;        if (L-&gt;last != -1)         &#123;            printf(&quot;pos is illegal\\n&quot;);            return -1;        &#125;    &#125;    //向后移动原有元素，从最后一个元素开始    for (int i = L-&gt;last; i &gt;= pos; i--)    &#123;        L-&gt;data[i+1] = L-&gt;data[i];    &#125;    //更新插入值和last    L-&gt;data[pos] = value;    L-&gt;last++;    return 0;    &#125;/*    * @brief:遍历并打印线性表内元素    * @param: L:指向线性表的指针    * @return:成功返回0，失败返回-1*/int list_show(sqlink L)&#123;    if (L == NULL) return -1;   //判断是否为有效表    if (L-&gt;last == -1) printf(&quot;table is empty\\n&quot;);  //判断是否为空表    //遍历并打印    for (int i = 0; i &lt;= L-&gt;last; i++)  //注意是小于等于，不然不显示表尾    &#123;        printf(&quot;%d &quot;,L-&gt;data[i]);    &#125;    return 0;&#125;/*    * @brief:删除全表，包括创建表时所分配的内存    * @param: L:指向线性表的指针    * @return:表不存在返回-1，成功返回0*/int list_delete(sqlink L)&#123;    if (L == NULL) return -1;    free(L);    //释放为表L申请的内存    L = NULL;   //标记表L为无效表    return 0;&#125;/*    * @brief:删除表中某一位置的元素    * @param: L：指向线性表的指针    * @param: pos：待删除元素位置    * @return:删除成功返回0，失败返回-1*/int list_delete_single(sqlink L, int pos)&#123;    if (L == NULL) return -1;   //判断是否为无效表    //判断pos是否位于有效范围内 应为[0,last]    if (pos &lt; 0 || pos &gt; L-&gt;last)    &#123;        printf(&quot;pos is illegal\\n&quot;);        return -1;    &#125;    //[pos+1,last]区间内已有元素前移    for (int i = pos + 1; i &lt; L-&gt;last + 1; i++)    &#123;       L-&gt;data[i-1] = L-&gt;data[i];   //数据前移，自动覆盖    &#125;    //更新last    L-&gt;last--;       return 0;&#125;/*    * @brief:合并两个线性表，L2全表元素置于L1元素之后    * @param: L1：指向待合并线性表L1的指针    * @param: L1：指向待合并线性表L2的指针    * @return:合并成功返回0，失败返回-1*/int list_merge(sqlink L1, sqlink L2)&#123;    int count = 0;    if (L1 == NULL || L2 == NULL) return -1;    //判断合并后L1是否越界    if (L1-&gt;last + 1 + L2-&gt;last + 1 &gt; N) printf(&quot;table is too big\\n&quot;);    //L2的第i位加到L1的last+1+i位置，总共传递L2-&gt;last个数    for (int i = 0; i &lt;= L2-&gt;last; i++)    &#123;        L1-&gt;data[L1-&gt;last+1+i] = L2-&gt;data[i];        count++;    //计数    &#125;    //更新L1-&gt;last为原last值+传递完成的元素个数    L1-&gt;last = L1-&gt;last + count;    return 0;&#125;/*    * @brief:查询线性表中是否存在某一元素    * @param: L：指向待查询线性表L的指针    * @param: value：待查询值    * @return:值对应的元素存在返回1，不成功返回-1*/int list_locate(sqlink L, data_t value)&#123;    int i = 0;    //搜索L中是否有元素等于value    for (i = 0 ; i &lt;=L-&gt;last; i++)    &#123;        if (L-&gt;data[i] == value) return 1;    &#125;    return -1;&#125;/*    * @brief:查找L1和L2中是否有相同的元素，将不同的元素存于新表L3    * @param: L1：指向待合并线性表L1的指针    * @param: L2：指向待合并线性表L2的指针    * @return:合并成功返回0，失败返回-1*/sqlink list_mergetonewtable(sqlink L1, sqlink L2)&#123;    sqlink L3 = list_create();  //创建新表L3    int i = 0;    int ret;    if (L1 == NULL || L2 == NULL)     &#123;        printf(&quot;no such table&quot;);        return NULL;    &#125;    //遍历L2内元素    while (i &lt;= L2-&gt;last)    &#123;        ret = list_locate(L1, L2-&gt;data[i]);   //查找L1中是否有L2中的第i个元素，即判断是否重复        //某元素不重复则向L3插入        if (ret == -1)        &#123;            list_insert(L3, L2-&gt;data[i], L3-&gt;last+1);   //按顺序向L3插入非重复值        &#125;        i++;    //更新索引    &#125;    return L3;&#125;/*    * @brief:清除线性表内的重复元素，清除后所有元素前移补空    * @param: L：指向待合并线性表L1的指针    * @return:操作成功返回0，失败返回-1*/int list_purge(sqlink L)&#123;    if (L == NULL) return -1;    for (int i = 0; i &lt;= L-&gt;last; i++)  //遍历线性表    &#123;        for (int j = i + 1; j &lt;= L-&gt;last; j++)  //从索引i+1开始，如果i+1及之后的元素和data[i]相等，判断为重复        &#123;            if (L-&gt;data[i] == L-&gt;data[j])            &#123;                printf(&quot;The repeated elements are:%d\\n&quot;,L-&gt;data[i]);                list_delete_single(L, j);   //删除重复的第j个元素                j--;    //回退索引，防止跳过未检查的元素            &#125;        &#125;    &#125;    return 0;&#125; \n 线性表的顺序存储缺点\n\n要求系统提供一大片连续存储空间\n插入、删除等运算需要遍历整个内存，运算耗时，且元素可能在存储器中成片移动\n\n","categories":["数据结构"]},{"title":"数据结构笔记【2】","url":"/2024/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%E3%80%902%E3%80%91/","content":" 链式存储\n 线性表之单链表\n将线性表的个元素分布在存储器的不同存储块，称为结点，通过地址或指针建立元素之间的联系。\n结点分为data域和next域，next域是一个指针，指向aia_iai​的直接后继ai+1a_{i+1}ai+1​的所在结点。next为NULL时表明该元素为链表最后一个元素。\n头结点：data不重要，专门用来标记第一个元素的结点地址\n结点类型描述:\ntypedef struct node&#123;    data_t data;    //数据域    struct node *next;  //结点的后继指针域&#125;listnode, *linklist;   //linklist 是一个指向链表的指针类型，用于操作链表的头指针\n所以有\nlistnode A; // 定义一个结点linklist p = &amp;A;  // 定义一个链表头指针，并指向 A 结点\n\n\n获取aia_iai​:  p-&gt;data;\n\n\n获取ai+1a_{i+1}ai+1​:  p-&gt;next-&gt;data;\n\n\n若指针p的值为NULL，则其不指向任何结点，此时取p-&gt;data或p-&gt;next是错误的\n 单链表的遍历\n线性存储中，遍历基于表尾标识符last完成，索引iii从0循环到last视为遍历一次。\n链式存储中，节点之间由next进行后继连接，所以遍历应当从头节点开始，由head = head-&gt;next方式进行索引（指针）更新\n示例：\n/*    * @brief: 遍历链表并打印其中的元素    * @param: H: 指向链表的指针    * @return: 遍历成功返回0，失败返回-1*/int list_show(linklist H)&#123;    linklist p;    if (H == NULL) // 如果链表为空，直接返回 NULL    &#123;        printf(&quot;H is NULL\\n&quot;);        return -1;    &#125;    p = H-&gt;next; //p 指向头结点的下一个节点 注意：这里不是线性存储，节点之间通过指针连接，不能写成p=H+1    while (p != NULL)    &#123;        printf(&quot;%d &quot;,p-&gt;data);        p = p-&gt;next;  //p指向下一个节点    &#125;    return 0;&#125;\n 单链表获取指定位置的节点地址\n头节点只有Next域，没有data域；尾节点只有data域，Next域为NULL。\nlist_get()函数遍历到指定链表的pos位置，遍历到之后返回最后一个节点的指针。注意遍历可以有两种方式：\n\n从头节点开始，初始化p = head,i = -1，遍历到i &lt; pos时结束，此时的pos是包含头节点在内的位置，比如链表{1,2,6,3}，元素2的位置是2，不是1；\n从头节点之后的第一个结点开始，初始化p = head-&gt;next; i = 0，遍历到i &lt; pos时结束，此时的pos是不包含头节点在内的位置，比如链表{1,2,6,3}，元素2的位置是1；\n\n/*    * @brief: 获取链表中指定位置的节点地址    * @param: H: 指向链表的指针    * @param: pos: 指定的位置    * @return: 插入成功返回找到的结点，失败返回NULL*/linklist list_get(linklist H, int pos)&#123;    linklist p; // 声明一个指向链表节点的指针，用于遍历链表    int i = -1; // 用于记录遍历位置，初始化为-1以考虑头结点    if (H == NULL) // 如果链表为空，直接返回 NULL    &#123;        printf(&quot;H is NULL\\n&quot;);        return NULL;    &#125;    if (pos == -1) // 如果 pos == -1，返回头结点    &#123;        return H;    &#125;    p = H; // 从头结点的下一个节点开始遍历    while (i &lt; pos) // 当 i 小于 pos 时继续循环    &#123;        p = p-&gt;next; // 移动到下一个节点        if (p == NULL)  // 如果链表到达了末尾，且还没找到 pos，返回 NULL        &#123;            printf(&quot;pos is invalid\\n&quot;);            return NULL;        &#125;        i++; // 记录当前遍历到的节点编号    &#125;    return p; // 返回找到的节点&#125;\n 单链表的其他操作\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;linklist.h&quot;/*    * @brief: 创建一个空的链式线性表    * @param: 无    * @return: 返回链表的头指针*/linklist list_create()&#123;    linklist head = (linklist)malloc(sizeof(listnode));    if (head == NULL)    &#123;        printf(&quot;memory allocation failed\\n&quot;);        return NULL;    &#125;    head-&gt;next = NULL;  // 初始化头结点的指针域为空，表示链表为空    return head;&#125;/*    * @brief: 插入元素到链表中    * @param: head: 指向链表头结点的指针    * @param: value: 要插入的值    * @param: pos：插入位置，新的节点会放置在该位置之后    * @return: 插入成功返回0，失败返回-1*/int list_insert(linklist head, data_t value, int pos)&#123;    if (head == NULL) return -1;  // 检查链表是否存在    // 如果要在第 0 位插入节点（头结点之后）    if (pos == 0)    &#123;        linklist new_node = (linklist)malloc(sizeof(listnode));   //为新节点申请内存         if (new_node == NULL)        &#123;            printf(&quot;memory allocation failed\\n&quot;);            return -1;        &#125;        new_node-&gt;data = value;   // 新节点的数据域赋值        new_node-&gt;next = head-&gt;next;  // 新节点指向头结点后的第一个节点        head-&gt;next = new_node;  // 头结点的next指向新插入的节点        return 0;    &#125;    // 否则查找 pos-1 位置的前驱节点    linklist prev_node = list_get(head, pos-1);    if (prev_node == NULL)    &#123;        printf(&quot;Invalid position\\n&quot;);        return -1;    &#125;    // 为新节点申请内存    linklist new_node = (linklist)malloc(sizeof(listnode));       if (new_node == NULL)    &#123;        printf(&quot;memory allocation failed\\n&quot;);        return -1;    &#125;    new_node-&gt;data = value;  // 设置新节点的数据    new_node-&gt;next = prev_node-&gt;next;  // 新节点指向原链表在插入位置后的节点    prev_node-&gt;next = new_node;  // 前驱节点替换为新插入的节点    return 0;&#125;/*    * @brief: 获取链表中指定位置的节点地址    * @param: H: 指向链表的指针    * @param: pos: 指定的位置    * @return: 插入成功返回找到的结点，失败返回NULL*/linklist list_get(linklist H, int pos)&#123;    linklist p; // 声明一个指向链表节点的指针，用于遍历链表    int i = -1; // 用于记录遍历位置，初始化为-1以考虑头结点    if (H == NULL) // 如果链表为空，直接返回 NULL    &#123;        printf(&quot;H is NULL\\n&quot;);        return NULL;    &#125;    if (pos == -1) // 如果 pos == -1，返回头结点    &#123;        return H;    &#125;    p = H; // 从头结点开始遍历    while (i &lt; pos) // 当 i 小于 pos 时继续循环    &#123;        p = p-&gt;next; // 移动到下一个节点        if (p == NULL)  // 如果链表到达了末尾，且还没找到 pos，返回 NULL        &#123;            printf(&quot;pos is invalid\\n&quot;);            return NULL;        &#125;        i++; // 记录当前遍历到的节点编号    &#125;    return p; // 返回找到的节点&#125;/*    * @brief: 遍历链表并打印其中的元素    * @param: H: 指向链表的指针    * @return: 遍历成功返回0，失败返回-1*/int list_show(linklist H)&#123;    linklist p;    if (H == NULL) // 如果链表为空，直接返回 NULL    &#123;        printf(&quot;H is NULL\\n&quot;);        return -1;    &#125;    p = H-&gt;next; //p 指向头结点的下一个节点 注意：这里不是线性存储，节点之间通过指针连接，不能写成p=H+1    while (p != NULL)    &#123;        printf(&quot;%d &quot;,p-&gt;data);        p = p-&gt;next;  //p指向下一个节点    &#125;    return 0;&#125;/*    * @brief: 遍历链表并查找指定的值    * @param: H: 指向链表的指针    * @return: 查找成功返回0，失败返回-1*/int list_search(linklist H, data_t value)&#123;    if (H == NULL) // 如果链表为空，直接返回 NULL    &#123;        printf(&quot;H is NULL\\n&quot;);        return -1;    &#125;    linklist p = H-&gt;next;    int i = 0; //初始化节点索引为-1    while (p != NULL)    &#123;        if (p-&gt;data == value)        &#123;            printf(&quot;search ok, pos is %d\\n&quot;,i);        &#125;        i++;        p = p-&gt;next;   //更新指针，指向下一个节点    &#125;    return 0;&#125;/*    * @brief: 合并两个链表，然后存储到新链表中    * @param: H1: 指向链表1的指针    * @param: H2: 指向链表2的指针    * @return: 返回表3*/linklist list_merge(linklist H1, linklist H2)&#123;    if (H1 == NULL || H2 == NULL)     &#123;        printf(&quot;H1 or H2 is null\\n&quot;);        return NULL;    &#125;        linklist H3 = list_create();    //创建新表    //拷贝H1至H3    linklist TempPtr1 = H1-&gt;next;   //声明TempPtr指向H1的下一个节点，跳过头节点    int count1 = 0;    while (TempPtr1 != NULL)    &#123;        list_insert(H3, TempPtr1-&gt;data, count1);    //向H3插入H1的data        TempPtr1 = TempPtr1-&gt;next;  //更新指针        count1++;   //更新计数器    &#125;     linklist TempPtr2 = H2-&gt;next;    int count2 = 0;    while (TempPtr2 != NULL)    &#123;        list_insert(H3, TempPtr2-&gt;data, count1 + count2);        TempPtr2 = TempPtr2-&gt;next;        count2++;    &#125;    return H3;&#125;/*    * @brief: 删除两个链表中的重复部分，将剩余元素存在新表中    * @param: H1: 指向链表1的指针    * @param: H2: 指向链表2的指针    * @return: 返回表3    * @note: 仅适用于小链表，大链表可以用哈希表*/linklist list_purge(linklist H1, linklist H2)&#123;    if (H1 == NULL || H2 == NULL)     &#123;        printf(&quot;H1 or H2 is null\\n&quot;);        return NULL;    &#125;    linklist H3 = list_create();    int is_common = 0;  //初始化标记，09为不重复，1为重复    linklist TempPtr1 = H1-&gt;next;   //初始化Ptr1指向H1的第一个有效节点    while (TempPtr1 != NULL)    &#123;        linklist TempPtr2 = H2-&gt;next;   // 每次遍历TempPtr1时，重置TempPtr2，否则TempPtr2一旦遍历到NULL后不会返回        while (TempPtr2 != NULL)        &#123;            if (TempPtr1-&gt;data == TempPtr2-&gt;data)            &#123;                printf(&quot;common elements:%d\\n&quot;,TempPtr2-&gt;data);                                is_common = 1;                list_insert(H3, TempPtr2-&gt;data, 0);            &#125;            TempPtr2 = TempPtr2-&gt;next;  //更新TempPtr2        &#125;        if (is_common == 0)  // 如果不是重复元素，插入到H3中        &#123;            list_insert(H3, TempPtr1-&gt;data, 0);        &#125;        TempPtr1 = TempPtr1-&gt;next;  //更新TempPtr1    &#125;    return H3;&#125;/*    * @brief: 删除指定位置的节点    * @param: H: 指向链表的指针    * @param: pos：待删除结点的位置    * @return: 成功返回0，失败返回-1*/int list_delete(linklist H, int pos)&#123;    if (H == NULL)     &#123;        printf(&quot;no such linklist\\n&quot;);        return -1;    &#125;    // 如果删除的位置是第一个节点    if (pos == 1)    &#123;        linklist TempPtr = H-&gt;next; // 保存下一个节点        free(H); // 释放头节点        H = TempPtr; // 更新头指针        return 0;    &#125;    // 获取待删除节点的前一个节点    linklist Prev_Node = list_get(H, pos - 1);    if (Prev_Node == NULL || Prev_Node-&gt;next == NULL)    &#123;        printf(&quot;invalid position\\n&quot;);        return -1;    &#125;    // 获取待删除的节点    linklist TempPtr = Prev_Node-&gt;next;    Prev_Node-&gt;next = TempPtr-&gt;next; // 连接前后节点    free(TempPtr); // 释放被删除的节点    return 0;&#125;/*    * @brief: 删除整个链表并释放内存    * @param: H: 指向链表的指针    * @return: 成功返回0，失败返回-1*/int list_free(linklist H)&#123;    if (H == NULL)    &#123;        printf(&quot;no such linklist\\n&quot;);        return -1;    &#125;    linklist TempPtr = H;    while (H != NULL)    &#123;        TempPtr = H;    // 保存当前节点        H = H-&gt;next;    // 更新链表头指针为下一个节点        free(TempPtr);  // 释放当前节点    &#125;    return 0;&#125;/*    * @brief: 倒置链表    * @param: H: 指向链表的指针    * @return: 成功返回0，失败返回-1    * @note: 将节点拿出放到*/int list_reverse(linklist H)&#123;    if (H == NULL)    &#123;        printf(&quot;no such linklist\\n&quot;);        return -1;    &#125;    if (H-&gt;next == NULL)    &#123;        printf(&quot;linklist is empty\\n&quot;);        return -1;    &#125;    //链表一分为二    linklist p = H-&gt;next-&gt;next;    H-&gt;next-&gt;next = NULL;        while (p != NULL)    &#123;        linklist q = p; // 暂存当前节点        p = p-&gt;next;    // 移动到下一个节点        q-&gt;next = H-&gt;next; // 将当前节点插入到链表头部（头插法）        H-&gt;next = q; // 更新头节点为新插入的节点    &#125;    return 0;&#125;/*    * @brief: 求链表相邻两节点data值之和为最大的第一结点的指针    * @param: H: 指向链表的指针    * @return: 成功返回指针，失败返回NULL*/int list_getmax(linklist H)&#123;    if (H == NULL)    &#123;        printf(&quot;no such linklist\\n&quot;);        return -1;    &#125;    if (H-&gt;next == NULL)    &#123;        printf(&quot;linklist is empty\\n&quot;);        return -1;    &#125;    int sum_new, max = 0;    linklist p = H-&gt;next;    linklist max_p = H-&gt;next;    int sum = p-&gt;data + p-&gt;next-&gt;data;    while (p != NULL &amp;&amp; p-&gt;next != NULL)    &#123;        sum_new = p-&gt;data + p-&gt;next-&gt;data;                if (sum_new &gt;= max)        &#123;            max = sum_new;            max_p = p;        &#125;        p = p-&gt;next;    &#125;    //printf(&quot;max sum is %d&quot;,max);    return max;&#125;\n 栈(Stack)\n和微机原理中栈的原理相同\n注意：\n\n先进后出\n注意栈顶指针的更新\n\n栈主要用于以下场景：\n\n函数调用：使用栈来保存当前函数的局部变量、返回地址等信息。当函数调用另一个函数时，新的函数信息被压入栈中，函数执行完毕后会从栈中弹出，返回上一个函数。\n撤销操作\n递归\n二叉树遍历\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;linear_stack.h&quot;#include &lt;string.h&gt;/*    @brief: 创建新的栈    @param: len: 栈的长度    @return: 指向栈的指针*/sqstack *stack_create(int len)&#123;    if (len &lt; 0)    &#123;        printf(&quot;len is illegal\\n&quot;);        return NULL;    &#125;    sqstack *ss;    //申请用于放置结构体的内存    ss = (sqstack *)malloc(sizeof(sqstack));       if (ss == NULL) &#123;        printf(&quot;Failed to allocate memory for stack.\\n&quot;);        return NULL;    &#125;    //申请用于放置栈内数据的内存    ss-&gt;data = (data_t *)malloc(sizeof(data_t) * len);    if (ss-&gt;data == NULL) &#123;        printf(&quot;Failed to allocate memory for stack data.\\n&quot;);        free(ss);          return NULL;    &#125;    memset(ss-&gt;data, 0, len*sizeof(data_t));    ss-&gt;top = -1;    ss-&gt;maxlen = len;    return ss;&#125;/*    @brief: 入栈    @param: s：对应栈指针 value：待入栈值    @return: 成功返回0，失败返回-1*/int stack_push(sqstack *s, data_t value)&#123;    if (s == NULL)    &#123;        printf(&quot;no such stack\\n&quot;);        return -1;    &#125;    if (s-&gt;top == s-&gt;maxlen - 1)    &#123;        printf(&quot;stack is full\\n&quot;);        return -1;    &#125;    s-&gt;top++;    s-&gt;data[s-&gt;top] = value;    printf(&quot;stack push ok\\n&quot;);    return 0;&#125;/*    @brief: 判断栈是否为空    @param: s：对应栈指针    @return: 栈为空返回-1，非空返回0，函数非法返回-2*/int stack_empty(sqstack *s)&#123;    if (s == NULL)    &#123;        printf(&quot;no such stack\\n&quot;);        return -2;    &#125;    if (s-&gt;top == -1)    &#123;        printf(&quot;stack is empty\\n&quot;);        return -1;    &#125;    else    &#123;        return 0;    &#125;&#125;/*    @brief: 判断栈是否为满    @param: s：对应栈指针    @return: 栈为满返回-1，非满返回0，函数非法返回-2*/int stack_full(sqstack *s)&#123;    if (s == NULL)    &#123;        printf(&quot;no such stack\\n&quot;);        return -2;    &#125;    if (s-&gt;top == s-&gt;maxlen - 1)    &#123;        printf(&quot;stack is full\\n&quot;);        return -1;    &#125;    else    &#123;        return 0;    &#125;&#125;/*    @brief: 数据出栈    @param: s：对应栈指针    @return: 返回出栈值，如果栈为空或出错则返回-999*/data_t stack_pop(sqstack *s)&#123;    if (s == NULL)    &#123;        printf(&quot;Stack not initialized\\n&quot;);        return -999;      &#125;    if (s-&gt;top == -1)    &#123;        printf(&quot;Stack is empty\\n&quot;);        return -999;      &#125;         data_t temp = s-&gt;data[s-&gt;top];    s-&gt;top--;    return temp;&#125;/*    @brief: 清除栈内所有元素    @param: s：对应栈指针    @return: 成功返回0，失败返回-1*/int stack_clear(sqstack *s)&#123;    if (s == NULL)    &#123;        printf(&quot;Stack not initialized\\n&quot;);        return -1;      &#125;    if (s-&gt;top == -1)    &#123;        return 0;      &#125;    //一般的栈清空操作只会重置 top，但不释放内存    s-&gt;top = -1;    //free(s-&gt;data);    //s-&gt;data = NULL;    return 0;&#125;/*    @brief: 释放整个栈的空间    @param: s：对应栈指针    @return: 成功返回0，失败返回-1*/int stack_free(sqstack *s)&#123;    if (s == NULL)    &#123;        printf(&quot;Stack not initialized\\n&quot;);        return -1;      &#125;    free(s-&gt;data);    s-&gt;data = NULL;    free(s);    return 0;&#125;\n 队列(Queue)\n 基于数组的队列\n等同于现实生活中的“排队”，元素从列尾存入，列首取出\n双端队列：列首和列尾都可以进行存入和取出；或解释为：同一个队列共享列首和列尾\n队列多被用于：\n\n任务调度\n消息队列\nIO请求管理（确保系统资源的有序访问）\n\n队列结构体一般为\ntypedef int data_t;#define N 64typedef struct &#123;    data_t data[N];    int front, rear;    //rear为队尾后一个元素的下标&#125;sequeue_t;\n其中rear一般指示队尾元素的下一个位置，也就是下一个要入队的元素位置。用于处理队列为空或只有一个元素时的情况。头尾位置重合时，队列即为空。\n初始front, rear = 0;\n\n出队列：x = sq[front++]\n入队列：sq[rear++] = x;\n\n当队列中前几个元素出队时，会造成这些位置为空，从而浪费队列中的可存储空间。此时可以使用循环队列。\n为区别空队和满队，满队元素个数比数组元素个数少一个。\n/*    @brief: 创建空队列    @param: 无    @return: 指向队列的指针*/sequeue queue_create()&#123;    sequeue qq = (struct queue*)malloc(sizeof(struct queue));    if (qq == NULL)    &#123;        printf(&quot;malloc failed\\n&quot;);        return NULL;    &#125;    qq-&gt;front = 0;    qq-&gt;rear = 0;    memset(qq-&gt;data, 0, sizeof(qq-&gt;data));    return qq;&#125;/*    @brief: 遍历并打印队列    @param: q：队列指针    @return: 成功返回0，失败返回-1*/int queue_print(sequeue q)&#123;    if (q == NULL)    &#123;        printf(&quot;no such queue\\n&quot;);        return -1;    &#125;    if (q-&gt;front == q-&gt;rear)    &#123;        printf(&quot;queue is empty&quot;);        return -1;    &#125;    for (int i = q-&gt;front; i &lt; q-&gt;rear; i++)    &#123;        printf(&quot;%d &quot;, q-&gt;data[i]);    &#125;    return 0;&#125;/*    @brief: 元素入队    @param: q：队列指针 data：待入队元素    @return: 成功返回0，失败返回-1*/int enqueue(sequeue q, data_t data)&#123;    if (q == NULL)    &#123;        printf(&quot;no such queue\\n&quot;);        return -1;    &#125;    if ((q-&gt;rear + 1) % N == q-&gt;front)    &#123;        printf(&quot;queue is full\\n&quot;);        return -1;    &#125;    q-&gt;data[q-&gt;rear] = data;    q-&gt;rear = (q-&gt;rear + 1) % N;    // rear 指针移动到队列边界时，通过取余使其返回到数组开头，实现循环    return 0;&#125;/*    @brief: 元素出队    @param: q：队列指针    @return: 成功返回出队元素，失败返回-1    @note: 出队元素为队首的第一个元素*/int dequeue(sequeue q)&#123;    if (q == NULL)    &#123;        printf(&quot;no such queue\\n&quot;);        return -1;    &#125;    if (q-&gt;front == q-&gt;rear)    &#123;        printf(&quot;queue is empty&quot;);        return -1;    &#125;    int temp = q-&gt;data[q-&gt;front];    q-&gt;front = (q-&gt;front + 1) % N;    return temp;&#125;/*    @brief: 清空队列内元素，但不释放内存    @param: q：队列指针    @return: 成功返回0，失败返回-1    @note: */int queue_clear(sequeue q)&#123;    if (q == NULL)    &#123;        printf(&quot;no such queue\\n&quot;);        return -1;    &#125;    q-&gt;front = 0;    q-&gt;rear = 0;    return 0;&#125;\n 基于链式存储的队列\n插入操作在队尾进行，删除操作在队首进行，由队首指针和队尾指针控制队列操作\n结构体需要定义两个：节点结构体 和 队列结构体\ntypedef int data_t;typedef struct node&#123;    data_t data;    struct node* next;&#125;*linklist;typedef struct queue&#123;    linklist front;    linklist rear;&#125;;\n\n初始化：创建空队列，front和rear指针都为空\n入队：在队尾新增一个节点，并更新当前队尾节点的next指针\n出队：更新front指针到待出队节点的下一个节点，然后删除原有队首节点\n\n与线性表不同的是，链式队列中rear指针一般指向最后队列的一个节点，而非最后一个节点的下一个节点。\n判断链式队列是否为空的条件只有一个：front == NULL, rear == NULL，不能使用front==rear判断，因为这里front和rear都是指针，并且rear指向的是最后一个节点，而非线性队列中的指向最后一个位置的下一个位置（待插入位置）。假设队伍中只有一个元素，这时候front和rear二者相同，但队列不为空。\n 创建新的链式队列\n/*    @ brief：创建并初始化新的链式队列    @param：无    @return：成功指向新队列的指针，失败返回NULL*/struct queue* queue_create()&#123;    struct queue* q = (struct queue*)malloc(sizeof(struct queue));    if (q == NULL)    &#123;        printf(&quot;malloc failed\\n&quot;);        return NULL;    &#125;    q-&gt;front = NULL;    q-&gt;rear = NULL;    return q;&#125;\n\n为队列申请内存，暂时先不申请节点的，因为这是一个空队列，目前还没有元素\n因为队列中没有节点，front和rear指针都为NULL\n\n 遍历队列\n/*    @ brief：遍历链式队列并打印所有元素    @param：q：队列指针    @return：成功返回0，失败返回-1*/int queue_print(struct queue* q)&#123;    if (q == NULL)    &#123;        printf(&quot;no such queue\\n&quot;);        return -1;    &#125;    if (q-&gt;front == NULL)    &#123;        printf(&quot;queue is empty\\n&quot;);        return -1;    &#125;    struct node* temp = q-&gt;front;    while (temp != NULL)    &#123;        printf(&quot;%d&quot;, temp-&gt;data);        temp = temp-&gt;next;    &#125;    printf(&quot;\\n&quot;);    return 0;&#125;\n\n在遍历时要用临时指针temp来代替front，如果直接用front指针的话，遍历一次之后front就回不去了，整个队列会被破坏\n尽量不要在遍历前用temp存储front指针，用front指针遍历完之后再front = temp这种形式返回回去的这种方法，在多线程的时候可能会有问题\n遍历结束的条件是当temp指针走到NULL之后，表明从队首节点到队尾节点全都扫描到了，而不是temp(front)=rear或者temp(front)=rear-&gt;next，因为链式队列中rear指针指向的是最后一个（队尾）节点\n\n 其他\n/*    @ brief：创建并初始化新的链式队列    @param：无    @return：成功指向新队列的指针，失败返回NULL*/struct queue* queue_create()&#123;    struct queue* q = (struct queue*)malloc(sizeof(struct queue));    if (q == NULL)    &#123;        printf(&quot;malloc failed\\n&quot;);        return NULL;    &#125;    q-&gt;front = NULL;    q-&gt;rear = NULL;    return q;&#125;/*    @ brief：遍历链式队列并打印所有元素    @param：q：队列指针    @return：成功返回0，失败返回-1*/int queue_print(struct queue* q)&#123;    if (q == NULL)    &#123;        printf(&quot;no such queue\\n&quot;);        return -1;    &#125;    if (q-&gt;front == NULL)    &#123;        printf(&quot;queue is empty\\n&quot;);        return -1;    &#125;    struct node* temp = q-&gt;front;    while (temp != NULL)    &#123;        printf(&quot;%d &quot;, temp-&gt;data);        temp = temp-&gt;next;    &#125;    printf(&quot;\\n&quot;);    return 0;&#125;/*    @ brief：元素入队    @param：q：队列指针 val：待入队元素值    @return：成功返回0，失败返回-1*/int enqueue(struct queue* q, data_t val)&#123;    if (q == NULL)    &#123;        printf(&quot;no such queue\\n&quot;);        return -1;    &#125;    struct node* newnode = (struct node*)malloc(sizeof(struct node));    newnode-&gt;data = val;    newnode-&gt;next = NULL;    //判断原队列是否为空    if (q-&gt;rear == NULL)    &#123;        q-&gt;front = newnode;        q-&gt;rear = newnode;    &#125;    else    &#123;          q-&gt;rear-&gt;next = newnode;        q-&gt;rear = newnode;    &#125;    return 0;&#125;/*    @ brief：元素出队    @param：q：队列指针    @return：成功返回0，失败返回-1*/int dequeue(struct queue* q)&#123;    if (q == NULL)    &#123;        printf(&quot;no such queue\\n&quot;);        return -1;    &#125;    if (q-&gt;front == NULL)    &#123;        printf(&quot;queue is empty\\n&quot;);        return -1;    &#125;    struct node* temp_node = q-&gt;front;    int temp = temp_node-&gt;data;    q-&gt;front = q-&gt;front-&gt;next;    // 如果队列为空，则需要更新 rear 为 NULL    if (q-&gt;front == NULL)    &#123;        q-&gt;rear = NULL;    &#125;    free(temp_node);    return temp;&#125;/*    @ brief：清空队列并删除对应节点    @param：q：队列指针    @return：成功返回0，失败返回-1*/int queue_clear(struct queue* q)&#123;    if (q == NULL)    &#123;        printf(&quot;no such queue\\n&quot;);        return -1;    &#125;    if (q-&gt;front == NULL)    &#123;        return 0;    &#125;    //临时节点，用于储存待删除的节点而不影响后续节点的遍历    struct node* temp;          while (q-&gt;front != NULL)    &#123;        temp = q-&gt;front;        q-&gt;front = q-&gt;front-&gt;next;        free(temp);    &#125;    q-&gt;rear = NULL;    return 0;&#125;\n 球钟问题（队列和栈的应用）\n球钟问题（Ball Clock Problem）是一种经典的算法和数据结构题目，主要用于考察队列和栈的结合运用。问题的基本情景是：\n假设有一个球钟系统，它通过小球来计时。系统中有 3 个轨道，每个轨道容量不同：\n\n分钟轨道（Min Track）：最多可容纳 4 个小球。\n五分钟轨道（Five-Min Track）：最多可容纳 11 个小球。\n小时轨道（Hour Track）：最多可容纳 11 个小球。\n\n运作机制：\n\n初始状态下有一组编号为 1 到 n 的小球，n 是球的总数，这些小球依次通过队列进行处理。\n每分钟，第一个小球从队列中取出，放到分钟轨道上。\n当分钟轨道满（即放入第5个小球时），轨道中的 4 个小球被依次放回队列，保持原来的顺序，而第 5 个小球则进入五分钟轨道。\n当五分钟轨道满（即放入第12个小球时），轨道中的 11 个小球被依次放回队列，第 12 个小球进入小时轨道。\n当小时轨道满（即放入第12个小球时），轨道中的 11 个小球被依次放回队列，第 12 个小球也回到队列的末尾。\n\n问题的一个常见考点是计算在给定的初始状态下，经过多少分钟后，小球队列的顺序会恢复到最初的状态。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;queue.h&quot;#include &quot;linear_stack.h&quot;#define N 27int main()&#123;    struct queue* main_queue = queue_create();    struct stack* minute = stack_create(4);    struct stack* five_minute = stack_create(11);    struct stack* hour = stack_create(11);    int time = 0;    //初始化主队列中的27个小球    for (int i = 1; i &lt;= N; i++)    &#123;        enqueue(main_queue, i);    &#125;    while (!stack_full(hour))   //如果小时轨道未满，继续    &#123;        while (!stack_full(five_minute))    //如果五分钟轨道未满，继续        &#123;            while (!stack_full(minute))     //如果分钟轨道未满，继续            &#123;                int ball = dequeue(main_queue);     //从主队列中获取小球                stack_push(minute, ball);           // 放入分钟栈中                time++;                if (stack_full(minute))             //如果分钟栈满了                &#123;                    int count_min = 0;                    while (count_min &lt; 4)                        &#123;                        int min_top_ball = stack_pop(minute);   //从分钟栈中弹出一个小球                        enqueue(main_queue, min_top_ball);      //该小球送入主队列                        count_min++;                    &#125;                    stack_push(five_minute, ball);          //将一个小球推入五分钟栈                &#125;            &#125;            if (stack_full(five_minute))    //如果五分钟栈满了            &#123;                int count_five_min = 0;                while (count_five_min &lt; 11)                  &#123;                    int five_min_top_ball = stack_pop(five_minute);     //从五分钟栈中弹出一个小球                    enqueue(main_queue, five_min_top_ball);     //送回主队列                    count_five_min++;                &#125;                stack_push(hour, dequeue(main_queue));            &#125;        &#125;        if (stack_full(hour))        &#123;            int count_hour = 0;            while (count_hour &lt; 11)            &#123;                int hour_top_ball = stack_pop(hour);                enqueue(main_queue, hour_top_ball);                count_hour++;            &#125;        &#125;    &#125;    printf(&quot;钟表恢复到初始状态所需时间: %d 分钟\\n&quot;, time);    return 0;&#125;","categories":["数据结构"]},{"title":"晶振及其典型应用与设计参数","url":"/2024/07/31/%E6%99%B6%E6%8C%AF%E5%8F%8A%E5%85%B6%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8F%82%E6%95%B0/","content":" 有源晶振(Oscillator)和无源晶振(Crystal)\n晶振可以分为两类：\n\n有源晶振(Oscillator)\n无源晶振(Crystal)\n\n 有源晶振(Oscillator)\n又被称为石英晶体振荡器（简写OSC或XO）。\n有源晶振包含晶体振荡器和外围集成电路两个部分，工程上多集成于同一封装内，以4pin贴片形式出现，体积较大，引脚分别为VCC、GND、OUT和NC。\n有源晶振不需要使用MCU的内部振荡器，信号稳定，质量较好，而且连接方式比较简单（仍需设置电源滤波，通常使用一个电容和电感构成滤波网络，输出端用一个小阻值的电阻过滤信号），不需要复杂的配置电路。\n适用场景：有成本和功耗要求，时钟信号精度、稳定性要求不高，IC内部有晶振时钟电路。\n有源晶振原始输出波形一般为方波（若封装内已集成整形电路）。实际观测时因示波器带宽限制可能无法看到方波而只能看到正弦波，因方波的傅里叶分解结果为基频和奇数次谐波叠加，若带宽不够，很容易只能看到高频方波的低频谐波分量，即只显示正弦波。参见：有源晶振和无源晶振的输出波形\n\n 无源晶振(Crystal)\n又被称为石英晶体（Xtal）。\n无源晶振是有2个引脚的无极性元件，需要借助于时钟电路才能产生振荡信号，自身无法起振。其信号质量较差，通常需要精确匹配外围电路（用于信号匹配的RLC元件），更换不同频率的晶体时周边配置电路也需要做相应的调整。\n适用场景：时钟要求高，IC内部无晶振时钟电路。\n无源晶振原始输出波形为正弦波。\n\n 无源晶振的分析模型\n 电气模型\n在电气网络中，石英晶体可以转换成一组RLC等效电路，以利分析。这一电路模型有两个频率接近但特性不同的共振点：低阻抗的串联共振点与高阻抗的并联共振点。\n\nLaplaceLaplaceLaplace变换后，该等效电路网络的阻抗可以写成以下形式：\nZ(s)=(1sC1+sL1+R1)//(1sC0)Z(s)=(\\frac{1}{sC_1}+sL_1+R_1)//(\\frac{1}{sC_0})\nZ(s)=(sC1​1​+sL1​+R1​)//(sC0​1​)\n或\nZ(s)=s2+sr1L1+ωs2(sC0)[s2+sR1L1+ωp2]Z(s)=\\frac{s^2+s\\frac{r_1}{L_1}+\\omega_s^2}{(sC_0)[s^2+s\\frac{R_1}{L_1}+\\omega_p^2]}\nZ(s)=(sC0​)[s2+sL1​R1​​+ωp2​]s2+sL1​r1​​+ωs2​​\nωs=1/(L1C1)\\omega_s = 1/(\\sqrt{L_1C_1})\nωs​=1/(L1​C1​​)\nωp=C1+C0L1C1C0=ωs1+C1C0≈ωs(1+C12C0)(C0&gt;&gt;C1)\\omega_p = \\sqrt{\\frac{C_1+C_0}{L_1C_1C_0}}=\\omega_s \\sqrt{1+\\frac{C_1}{C_0}} \\approx \\omega_s(1+\\frac{C_1}{2C_0}) (C_0 &gt;&gt; C_1)\nωp​=L1​C1​C0​C1​+C0​​​=ωs​1+C0​C1​​​≈ωs​(1+2C0​C1​​)(C0​&gt;&gt;C1​)\n式中s=jωs=j\\omegas=jω，ωs\\omega_sωs​为串联共振频率，ωp\\omega_pωp​为并联共振频率，单位均为rad/srad/srad/s。\n在晶体两端并联上额外的并联电容器会使并联后的整体共振频率降低，因此，石英晶体厂商在制作并测量石英晶体的并联共振频率时，会在特定的并联电容值（称为负载电容）下进行测试。如使用较小的电容值，振荡频率会比规格高，反之比规格低。这一特性也可以用来微调振荡频率。\n 共振模式\n石英晶体提供了两种共振模式，由C1C_1C1​与L1L_1L1​构成的串联共振，与由C0C_0C0​、C1C_1C1​与L1L_1L1​构成的并联共振。\n对于一般的MHz级石英晶体而言，串联共振频率一般会比并联共振频率低若干KHz。频率在30MHz以下的石英晶体，通常工作时的频率处于串联共振频率与并联共振频率之间，此时石英晶体呈现电感性阻抗。因为，外部电路上的电容会把电路的振荡频率拉低一些。在设计石英晶体振荡电路时，也应令电路上的杂散电容与外加电容合计値与晶体厂商使用的负载电容值相同，振荡频率才会准确符合厂商的规格。\n频率在30MHz以上（到200MHz）的石英晶体，通常工作于串联共振模式，工作时的阻抗处于最低点，相当于RsR_sRs​。此种晶体通常标示串联电阻（&lt; 100 Ω\\OmegaΩ）而非并联负载电容。为了达到高的振荡频率，石英晶体会振荡在它的一个谐波频率上，此谐波频率是基频的整数倍。因为偶数次谐波会使得晶体内电场互相抵消，只有奇数次谐波可以利用，例如3倍、5倍、与7倍的泛音晶体。要达到所要的振荡频率，振荡电路上会加入额外的电容器与电感器，以选择出所需的频率。\n 温度效应\n石英晶体的频率特性取决于形状或切割方式。音叉型晶体通常会切割成温度特性是以25℃为中心的抛物线。这意味着，音叉晶体振荡器在室温下产生的共振频率接近其目标频率，当温度或增加或减少时频率都会降低。频率-温度曲线为抛物线的常见32.768千赫音叉晶体的温度系数是负百万分之0.04/摄氏度²。\nf=f0[1−0.04ppm(T−T0)2]f=f_0[1-0.04ppm(T-T_0)^2]\nf=f0​[1−0.04ppm(T−T0​)2]\n也就是说，如不考虑制作误差，以这种石英晶体控制频率的时钟，如运作在比室温低10°C的环境下，每年会比运作在室温下慢2分钟；如运作在比室温低摄氏20°C的环境下，则每年会比运作在室温下慢8分钟。\n 无源晶振典型电路及其参数\n 皮尔斯晶体振荡器（Pierce Crystal Oscillator）\n\n此电路中晶体决定了振荡频率，并以串联谐振频率工作，fsf_sfs​在输出和输入之间提供低阻抗路径。谐振时存在180度相移，因而反馈为正。输出正弦波的幅度限制在MOSFET漏极端子的最大电压范围内。电阻器R1R_1R1​控制反馈量和晶体驱动量，而射频扼流圈RFC上的电压在每个周期内反转。\n大多数数字时钟、手表和计时器都以某种形式使用皮尔斯振荡器，因为它可以使用最少的组件来实现。\n MCU振荡器\nMCU电路中，皮尔斯振荡器常以另一种较为简单的方式出现。\n\n其中包括\n\nCL1C_{L1}CL1​、CL2C_{L2}CL2​：外部负载电容\nREXTR_{EXT}REXT​：阻尼电阻，用于调节激励电流\nRFR_FRF​：反相器反馈电阻，强制反相器工作在线性放大区，用于改善起振。多数MCU会内置该电阻。\n\nMCU振荡器还有另一种更简洁的形式：\n\n该电路中省去了REXTR_{EXT}REXT​。\n 负载电容(CLC_LCL​)\n负载电容的标称值通常由晶振制造商提供，标示为CLC_LCL​。实际电路中的负载电容是并联在晶振两端的两个电容CL1C_{L1}CL1​、CL2C_{L2}CL2​，以及晶振内部电容以及布线电容（寄生电容）共同作用的结果，其计算公式为\nCL=C1×C2C1+C2+CsC_L=\\frac{C_1 \\times C_2}{C_1 + C_2}+C_{s}\nCL​=C1​+C2​C1​×C2​​+Cs​\n式中CsC_{s}Cs​是电路中其他杂散电容（包括晶振引脚电容和 PCB 布线电容），大小通常在3-5pFpFpF。\n实际应用中，选择负载电容的步骤为：\n\n查阅手册，确定晶振的标称负载电容 CLC_LCL​。\n根据经验或者实际测量估算电路板的杂散电容，一般经验值为3-10pFpFpF。\n根据公式选择合适的CL1C_{L1}CL1​、CL2C_{L2}CL2​，使其满足标称负载电容的要求。\n\n 振荡频率(Oscillation frequency)\n振动频率是指与晶体谐振器一起工作的振荡电路的实际频率。振动频率由晶体谐振器决定，并受MCU、外部负载电容、PCB杂散电容等的影响。\nfosc=fL=fr[C12(C0+Cs)+1]f_{osc}=f_{L}=f_{r}[\\frac{C_1}{2(C_0+C_s)}+1]\nfosc​=fL​=fr​[2(C0​+Cs​)C1​​+1]\n式中fLf_{L}fL​为负载共振频率，frf_{r}fr​为共振频率。\n注意：不能用示波器探头、万用表笔等测试工具直接探测晶振输入、输出端，因为示波器探头、万用表笔均具有寄生电容特性，测试时将改变整个负载电容的等效值，测试出的数据不准，同时也会改变晶体的ESR，甚至会出现晶振停振现象。\n参见：如何测量振荡频率\n 激励功率 (Drive Level)和REXTR_{EXT}REXT​\n激励功率是指施加在晶振上的功率，通常以微瓦 (μW\\mu WμW) 为单位。它表示晶振在工作时所消耗的能量。激励功率对于晶振的可靠性和寿命至关重要，过高的激励功率可能会导致晶振过热或损坏，过低的激励功率则可能导致晶振无法正常启动或工作不稳定。一般都按手册设计。\n激励功率的观测和调节可基于两种方法进行：\n 电流法\n根据\nDL=IRMS2×ESRDL=I_{RMS}^2 \\times ESR\nDL=IRMS2​×ESR\n参见：How to Measure the Drive Level\n 电压法\n此处略。\nREXTR_{EXT}REXT​用于调节激励功率。\n 静态电容（Static Capacitance）\n静态电容即为并联电容（Parallel Capacitance,C0C_0C0​），是指晶振在不振荡时其两端的电容。这一参数是晶振的固有特性之一，通常由制造商在晶振的规格书中给出。其在不施加任何电压或不进行振荡时测得。它反映了晶体材料和电极结构的固有特性。\n 温漂\n温漂是指晶振的振荡频率随温度变化而发生的偏移。温漂通常用 ppm/°C（百万分之几每摄氏度）来表示，它是晶振频率稳定性的重要指标之一。\n温漂受以下因素影响：\n\n材料特性。晶体材料的温度系数是影响温漂的主要因素。石英晶体的温度系数相对较低，但仍会随温度变化而导致频率漂移。\n晶体切割方式。不同的晶体切割方式（如 AT 切割、BT 切割等）对温漂有不同的影响。AT 切割的石英晶体在常用温度范围内具有较好的频率稳定性。\n电路设计。晶振电路中的元件（如负载电容、放大器等）对温度的敏感度也会影响整体的频率温漂。\n\n应对方法：\n\n选用温补晶振（TCXO），通过内部的温度补偿电路，修正因温度变化引起的频率漂移，从而提高晶振的频率稳定性。\n选用恒温控制晶振（OCXO），通过内置的恒温控制系统，将晶振保持在恒定温度下工作，极大地减少温漂影响。\n在温度相对稳定的环境中使用晶振，尽量避免极端温度变化。\n\n 品质因数（Quality Factor，Q值）\n品质因数QQQ是无量纲的参数，用来表示振荡系统的损耗情况。具体来说，它是储存在晶振中的能量与每周期损耗能量的比值。对于晶振，QQQ值越高，表示其能量损耗越小，振荡的稳定性和纯度越高。\nQ=f0ΔfQ=\\frac{f_0}{\\Delta f}\nQ=Δff0​​\n式中f0f_0f0​为晶振谐振频率，Δf\\Delta fΔf为频率响应的带宽（即晶振在其谐振频率处的响应下降到其最大值的1/21/\\sqrt 21/2​处的频率间隔）。\n高QQQ值晶振起振后的频率稳定性和噪声均较低，但其需要较长的起振时间以达到稳定。\n 典型应用\nSTM32F429IRTx需要在OSC_IN和OSC_OUT引脚外接25MHz晶振以供系统高速时钟源HSE，同时通过内部锁相环（PLL）进行倍频。\n\n\n手册推荐负载电容为10pFpFpF或20pFpFpF，选取10pFpFpF。\n根据工程设计经验，一般取手册值-2或-3pFpFpF后，再乘以2，作为目标负载电容值。此处即为\nCL′=(CL−2)×2=(10−2)×2=16pFC_L&#x27;=(C_L-2)\\times2=(10-2)\\times2=16pF\nCL′​=(CL​−2)×2=(10−2)×2=16pF\n根据\nCL′=C1×C2C1+C2+CsC_L&#x27;=\\frac{C_1 \\times C_2}{C_1 + C_2}+C_{s}\nCL′​=C1​+C2​C1​×C2​​+Cs​\nCsC_sCs​经验值为5pFpFpF，所以可解得C1=C2=22pFC_1=C_2=22pFC1​=C2​=22pF。\n","categories":["电子与电路设计"]},{"title":"机器学习基础","url":"/2024/09/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/","content":"Machine Learning can be divided to :\n- supervised learning\n- unsupervised learning\n Supervised learning\nNeeds data set with labels\nTO: predict unknown future output\n\n\nClassfication Problem (discrete): to predict a discrete output (say yes or no), e.g Cancer benign or malignant diagnosis\n\n\nRegression Problem (Continous): to predict a specific number, e.g Stock Price Prediction\n\n\nDuring a linear regression problem we have to solve a minimization problem, to minimize the difference between xxx and h(y)h(y)h(y).\n Regression Problem\nTraining set + learning algorithm -&gt; generate hypothesis function hhh\nhhh takes input xxx (e.g. size of house) and output yyy (e.g. estimated selling price)\nCost Function:\nJ(θ0,θ1)=12mΣ(hθ(x)−y)2J(\\theta_{0},\\theta_{1})=\\frac{1}{2m} \\Sigma (h_{\\theta}(x)-y)^2\nJ(θ0​,θ1​)=2m1​Σ(hθ​(x)−y)2\nSigma from 1 to m (m equal to sample size)\n Gradient Descent\nrepeat until convergence:\nθj:=θj−α∂∂θjJ(θ0,θ1)\\theta_j  := \\theta_j -\\alpha\\frac{\\partial}{\\partial \\theta_j}J(\\theta_0 , \\theta_1)\nθj​:=θj​−α∂θj​∂​J(θ0​,θ1​)\n(for jjj = 0 and jjj = 1)\n:= means denote assignment\nα\\alphaα:learning rate, basically controls how big is a step when descent\nθ0\\theta_0θ0​ and θ1\\theta_1θ1​ have to be updated simultaneously\n Linear Regression Algorithm\nTO: Apply gradient descent algorithm to minimize squared error cost function\n“Batch” gradient descent: each step of gradient descend uses all training examples\n Multiple features (variables)\nHypothesis:hθ(x)=θTx=θ0x0+θ1x1...+θnxnh_\\theta (x) = \\theta_T x = \\theta_0 x_0 + \\theta_1 x_1 ... + \\theta_n x_nhθ​(x)=θT​x=θ0​x0​+θ1​x1​...+θn​xn​\nParameters:θ0,θ1,...,θn\\theta_0,\\theta_1,...,\\theta_nθ0​,θ1​,...,θn​\nCost function:\nJ(θ0,θ1,...,θn)=12mΣ(hθ(x(i))−y(i))2J(\\theta_0,\\theta_1,...,\\theta_n) = \\frac{1}{2m}\\Sigma (h_\\theta(x^{(i)})-y^{(i)})^2\nJ(θ0​,θ1​,...,θn​)=2m1​Σ(hθ​(x(i))−y(i))2\nSigma from i=1 to m\nGradient descent:\nrepeat fellow:\nθj:=θj−α∂∂θjJ(θ0,θ1)\\theta_j  := \\theta_j -\\alpha\\frac{\\partial}{\\partial \\theta_j}J(\\theta_0 , \\theta_1)\nθj​:=θj​−α∂θj​∂​J(θ0​,θ1​)\n(simutaneously update for every jjj)\nAs a result new algorithm will be like fellow:\nθj:=θj−α1mΣ(hθ(x(i))−y(i))2xj(i)\\theta_j := \\theta_j - \\alpha \\frac{1}{m} \\Sigma (h_\\theta(x^{(i)})-y^{(i)})^2 x_j^{(i)}\nθj​:=θj​−αm1​Σ(hθ​(x(i))−y(i))2xj(i)​\n(simultaneously update θj\\theta_jθj​ for j=0,1，...,nj=0,1，...,nj=0,1，...,n)\nE.g from a data set with three features it may like follows:\nθ0:=θ0−α1mΣ(hθ(x(i))−y(i))2x0(i)\\theta_0 := \\theta_0 - \\alpha \\frac{1}{m} \\Sigma (h_\\theta(x^{(i)})-y^{(i)})^2 x_0^{(i)}θ0​:=θ0​−αm1​Σ(hθ​(x(i))−y(i))2x0(i)​\nθ1:=θ1−α1mΣ(hθ(x(i))−y(i))2x1(i)\\theta_1 := \\theta_1 - \\alpha \\frac{1}{m} \\Sigma (h_\\theta(x^{(i)})-y^{(i)})^2 x_1^{(i)}θ1​:=θ1​−αm1​Σ(hθ​(x(i))−y(i))2x1(i)​\nθ2:=θ2−α1mΣ(hθ(x(i))−y(i))2x2(i)\\theta_2 := \\theta_2 - \\alpha \\frac{1}{m} \\Sigma (h_\\theta(x^{(i)})-y^{(i)})^2 x_2^{(i)}\nθ2​:=θ2​−αm1​Σ(hθ​(x(i))−y(i))2x2(i)​\n Feature Scaling &amp; Mean normalization\nIdea:make sure features are on a similiar scale.\nE.g. x1x_1x1​ = size (0-2000 feet^2) while x2x_2x2​ = number of bedrooms (1-5)\n Learning rate\n\nif α\\alphaα is too small: slow convergence\nif α\\alphaα is too large: J(θ)J(\\theta)J(θ) may not decrease on every iteration; may not converge\n\nMake sure gradient descent is working correctly.Final goal is converge the cost function.\n Features and Polynomial Regression\nE.g. Housing prices prediction\nhθ(x)=θ0+θ1×frontage+θ2×depthh_\\theta (x) = \\theta_0 + \\theta_1 \\times frontage + \\theta_2 \\times depth\nhθ​(x)=θ0​+θ1​×frontage+θ2​×depth\nClearly frontage is the first feature x1x_1x1​ and depth is the second feature x2x_2x2​\nTo decide which feature is the most important factor to the housing price, thereafter a polynomial regression can be taken:\nhθ(x)=θ0+θ1×frontage+θ2×depth2h_\\theta (x) = \\theta_0 + \\theta_1 \\times frontage + \\theta_2 \\times depth^2\nhθ​(x)=θ0​+θ1​×frontage+θ2​×depth2\nthis formula can be written as:\nhθ(x)=θ0+θ1×x1+θ2×x22h_\\theta (x) = \\theta_0 + \\theta_1 \\times x_1 + \\theta_2 \\times x_2^2\nhθ​(x)=θ0​+θ1​×x1​+θ2​×x22​\nIn this case, feature scaling is becoming increasingly important to get them comparable.\n Classification Problem (Discrete)\n Sigmoid Function\nWant outputs 0 or 1\nSigmoid Function(Logistic Function):\ng(z)=11+e−zg(z)= \\frac{1}{1+e^{-z}}\ng(z)=1+e−z1​\n\nwhile zzz can be written as vector(w⃗\\vec{w}w is weights and xxx is feature):\nz=w⃗x+bz = \\vec{w}x + b\nz=wx+b\n Decision Boundary\nfw⃗,b(x)=g(w⃗x+b)=11+e−(w⃗x+b)=P(y=1∣x;w⃗,b)f_{\\vec{w},b}(x) = g(\\vec{w}x+b) = \\frac{1}{1+e^{-(\\vec{w}x+b)}}=P(y=1|x;\\vec{w},b)\nfw,b​(x)=g(wx+b)=1+e−(wx+b)1​=P(y=1∣x;w,b)\nClearly the decision boundary is the threshold value of fw⃗,b(x)f_{\\vec{w},b}(x)fw,b​(x).\nxxx is also can be replaced by x⃗\\vec{x}x if there are multiple features.\nClearly the descision boundary is\nw⃗x+b=0\\vec{w}x+b=0\nwx+b=0\n Cost Funciton\n\nSince MSE under logistic regression is a non-convex function, using MSE as cost function index may get “stuck” at the inflection point of the function, causing error.\nTarget:create or select a new cost function to make it convex.\nThe loss function of logistic regression uses the log-likelihood loss function, also known as the cross-entropy loss function, which is used to measure the difference between the model prediction and the true label. The loss function is defined as:\nL(θ)=−1m∑i=1m[y(i)log⁡hθ(x(i))+(1−y(i))log⁡(1−hθ(x(i)))]L(\\theta) = - \\frac{1}{m} \\sum_{i=1}^{m} \\left[ y^{(i)} \\log h_{\\theta}(x^{(i)}) + (1 - y^{(i)}) \\log (1 - h_{\\theta}(x^{(i)})) \\right]\nL(θ)=−m1​i=1∑m​[y(i)loghθ​(x(i))+(1−y(i))log(1−hθ​(x(i)))]\nwhile\n\nmmm:sample amounts\ny(i)y^{(i)}y(i): true label (0 or 1) of sample iii\nhθ(x(i))h_{\\theta}(x^{(i)})hθ​(x(i)): The model predicts the probability of sample iii, i.e. P(y=1∣x(i))P(y=1|x^{(i)})P(y=1∣x(i))\n\nThe goal of this loss function is to minimize the gap between the predicted and actual labels.\n Training Logistic regression\nUse gradient descent to minimize the cost function J(w⃗,b)J(\\vec{w},b)J(w,b).\nwe have\n∂∂wjJ(w⃗,b)=1m∑i=1m[fw⃗,b(x⃗(i)−y(i))]xj(i)\\frac{\\partial}{\\partial w_j} J(\\vec{w},b) = \\frac{1}{m} \\sum_{i=1}^{m} \\left[ f_{\\vec{w},b}(\\vec{x}^{(i)}-y^{(i)})\\right]x_j^{(i)} \n∂wj​∂​J(w,b)=m1​i=1∑m​[fw,b​(x(i)−y(i))]xj(i)​\nand\n∂∂bJ(w⃗,b)=1m∑i=1m[fw⃗,b(x⃗(i)−y(i))]\\frac{\\partial}{\\partial b} J(\\vec{w},b) = \\frac{1}{m} \\sum_{i=1}^{m} \\left[ f_{\\vec{w},b}(\\vec{x}^{(i)}-y^{(i)})\\right]\n∂b∂​J(w,b)=m1​i=1∑m​[fw,b​(x(i)−y(i))]\nwhat we need to do is update them simultaneously.\n Unsupervised learning\nNeeds data set without labels\nTO: Automatically discover the internal patterns or structures of data, such as dividing data into different clusters, revealing the inherent laws of data, or simplifying data representation.\nExample : Extracting vocals from audio\n 决策树(Decision Tree)\nE.g.：判断动物是否为猫\n\n决策树训练步骤\n\n确认第一个决策节点(Node)后对样本进行分类 例如：待检测动物的耳朵是圆的还是尖的\n确认剩下的节点\n\n需要解决的问题\n\n如何确定每个节点所用来进行分类的特征(Feature)？如：是根据耳朵类型进行分类还是根据体型进行分类\n什么时候停止继续分类（split）？\n\n某节点能够做到100%的分类时（如有猫DNA的动物一定是猫，不可能是其他）\n某节点之后决策树溢出\n\n\n继续进行决策所带来的提升低于阈值\n节点中的样本数量过少\n\n","categories":["深度学习"]},{"title":"简单H桥电机驱动电路分析及其隔离设计","url":"/2024/08/12/%E7%AE%80%E5%8D%95H%E6%A1%A5%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E9%9A%94%E7%A6%BB%E8%AE%BE%E8%AE%A1/","content":" H桥驱动电路（H-Bridge Circuit）\nH桥是一种相当简单的电路。它包含四个独立控制的MOSFET，用作引导电流流过负载（通常是电感负载，例如电机）的开关元件。\n\n具体的工作方式不再赘述，本文主要分析一些比较细节的点。\n MOSFET中的寄生二极管与外部续流二极管\n在N沟道MOSFET中，源极和漏极通常是N型区域，而基区是P型材料。这些区域之间形成了两个PN结，其中一个是在源极与基区之间，另一个是在漏极与基区之间。由于在MOSFET中，源极和基区通常是短接的，因此源极-基区的PN结不会起作用，而漏极-基区的PN结则形成了寄生二极管。该现象在大多数功率MOSFET中都会出现。这也就是为什么在一些仿真软件中，MOSFET的拓扑符号后会有一个反向并联的二极管标识。\n作为典型的感性负载，电机在电流变化时会产生反电动势。当H桥中的MOSFET切换状态时，电流的变化会导致电感负载产生一个高电压尖峰。这种电压尖峰可能会反向施加在MOSFET上，可能导致MOSFET损坏或造成不稳定的电路操作。\n为了保护MOSFET和其他电路元件，在每个MOSFET的漏极和源极之间通常会并联一个续流二极管。续流二极管的作用主要有以下几点：\n\n\n提供电流续流路径：当MOSFET关闭时，感性负载的电流无法立即停止，续流二极管为该电流提供了一个通路。这样可以避免因电流中断导致的高电压尖峰，从而保护MOSFET和其他电路元件。\n\n\n保护MOSFET：续流二极管可以限制感性负载产生的反电动势，避免这些电压尖峰直接加在MOSFET上，防止MOSFET因过压而损坏。\n\n\n稳定电路操作：在高频开关操作中，续流二极管可以减少电路中的电磁干扰（EMI）和噪声，提高电路的稳定性和可靠性。\n\n\nMOSFET自带的寄生二极管在电路中确实可以在某些情况下起到续流二极管的作用，特别是在开关断开的瞬间，它可以为电感性负载提供电流续流的路径。然而，由于寄生二极管的特性不如专门设计的续流二极管（例如肖特基二极管），它的导通电压较高，反向恢复时间较长，所以在实际电路设计中，寄生二极管往往不能完全替代续流二极管。因此，如果对续流二极管有严格的要求，通常会在电路中另外并联一个性能更好的二极管。\n\n 电流衰减模式\n电机是感性负载，电流不能突变。若要使电机减速，在断开电机两端所加的电压时，电压由工作值瞬间衰减至零，根据电磁感应定律，电机会根据电压变化率（du/dtdu/dtdu/dt）的大小而产生反向电动势。当电压变化率很大时，这个反电动势很有可能损坏MOSFET。因此想让电机停下，除了断开供电，还要形成一个续流的回路，释放掉电机上的能量。这就是刚刚提到过的续流二极管的作用。\n在减速时的电流再生过程中，H桥通常可以工作在两个模式：\n\n\n快速衰减（Fast Decay Mode）\n\n\n慢速衰减（Slow Decay Mode）\n\n\n注意：“衰减”指的是流过电机线圈（电感器）的电流，与电机的行为没有直接关系。不要认为快速衰减会使电机迅速停止。\n\n 快速衰减模式（Fast Decay Mode）\n\n该模式下，四个MOSFET全部关断，反电动势带来的反向感应电流通过Q2、Q3的寄生二极管（续流二极管）流动，此时反电动势带来的感应电流方向与电源电压方向相反，线圈电流迅速衰减。\n为避免同一侧的上下臂MOSFET同时导通而造成击穿，应当采取机制。具体为，添加一个令所有FET开关均处于关闭状态的时间段（被称为死区时间）。在此期间，允许激励FET开关切换到关闭状态，存在电感负载的电流由寄生二极管或外部续流肖特基二极管承载。\n快速衰减模式下电流虽然能够迅速降低到零，但电机速度会因惯性而逐渐减小，对外呈现“滑动”式的减速。\n 慢衰减模式（Slow Decay Mode）\n\n该模式下，Q1、Q3关断，Q2、Q4导通，感应电流以循环方式在流经Q2和Q4时降至零。在这种情况下，电流在流过电感阻抗和两个FET的导通阻抗时以热量的形式耗散。\n注意：虽然慢速衰减通常描述为两个低侧FET开关打开、两个高侧FET开关关闭，但相同现象可通过启用两个高侧 FET 开关、同时禁用两个低侧FET开关来实现。也就是说，衰减回路可以为上臂，也可以为下臂。部分IC支持通过相应的输入信号来配置。\n在直流电机上，慢速衰减模式会令电机绕组短路，进而形成反电动势短路，使得转子以极快速度停止旋转。\n 混合衰减（Mixed Decay Mode）\n在混合衰减再循环模式中，电流衰减至零的速度快于慢速衰减方法，但慢于快速衰减方法。实现此技术的方法是，协调FET开关的开/关时间，在固定时间内处于快速衰减模式，然后在剩余时间内处于慢速衰减模式。系统保持在快速衰减模式与慢速衰减模式中的时间比例被称为混合衰减百分比。\n混合衰减对于步进电机驱动很有意义，但最重要的是，它对微步进驱动极有意义。在微步进时，将保持一定波形以获得出色的运动质量。例如，通常会通过正弦波（电流曲线）来驱动步进电机绕组。也可以在相同范围内使用三角形和菱形。\n有关混合衰减的内容将另作介绍。\n MOSFET高低端驱动与自举电路\n在H桥电路中，MOSFET通常分为高端（High-Side）和低端（Low-Side）两个部分：\n\n\n高端MOSFET（High-Side MOSFET）： 连接在电源和负载之间的MOSFET。\n\n\n低端MOSFET（Low-Side MOSFET）： 连接在负载和地之间的MOSFET。\n\n\n已知MOSFET导通需要满足\nVGS&gt;VGS(th)V_{GS}&gt;V_{GS(th)}\nVGS​&gt;VGS(th)​\n对于低端MOSFET，源极通常接地，因此提高驱动电压使得VGS&gt;VGS(th)V_{GS}&gt;V_{GS(th)}VGS​&gt;VGS(th)​比较容易实现。而对于高端MOSFET，源极与负载相连，且源极电位通常高于地电位，因此对栅极直接驱动需要一个比电源电压更高的电压来导通MOSFET。这就需要特殊的高端驱动电路来生成这个较高的栅极驱动电压。\n自举电路是常用的一种解决方案，用于生成高端MOSFET所需的高电压驱动信号。它通常包括一个二极管和一个电容器（自举电容），配合驱动芯片工作。\n以半桥为例，当Q2导通时，Q1的源极被拉到地电位（低电平）。此时，自举电容C1通过二极管充电（此处所加电压V一般由LDO架构电源输出）。此时，自举电容的电压接近于电源电压V。\n\n当Q2断开时，SW位置电位不再为地电位，而自举电容C1两端储存了大小为V的电压，A点电压变为VSW+VV_{SW}+VVSW​+V，很容易就能够驱动高端MOSFET。此时由C1提供上管驱动阶段所需的所有电流。此时自举二极管（一般为肖特基二极管）处于反向截止状态，将自举压降限制在自举回路内，防止其回流至上一级从而损坏电路。\n\n参见：H桥自举电路分析\n自举电容持续放电将会导致高端MOSFET的栅极对地电压持续减小，直至其等于V。因此要让高端MOSFET持续导通，需要令自举电容不断充放电，或是增加自举电容容量、更换IC或在设计中避免持续导通需求。由于MOSFET的特性，自举电路在增加栅源电压的同时，还可令MOSFET的导通电阻减小，从而减少发热损耗。\n H桥驱动控制\n对MOSFET栅极引入PWM控制，可实现对电机转动方向和速度的调节。PWM的占空比对应电机转速，占空比越大，平均等效输出电压越大，转速越快。通常的PWM频率在10Khz至20KHz之间。若频率太低，电机转速会过低，同时容易出现高噪声或高频机械振动；频率太高，则MOSFET开关损耗带来的影响会变大，降低系统效率。\n根据不同桥臂的PWM控制方式，大致上可分为三种：\n\n\n受限单极模式\n\n\n单极模式\n\n\n双极模式\n\n\n 受限单极模式\n该模式下，电机电枢驱动电压极性是单一的，优点是控制电路较为简单，缺点是电机不能刹车，不能进行能耗制动，在负载超过设定速度时不能提供向力矩。调速静差大，调速性能很差，稳定性也不好。当PWM高电平时，电机两端分别为VM和GND，有电流流过，电机产生扭矩，进行转动。当PWM低电平时，电机两端未导通，不形成闭合回路，没有电流流过，此时电机的转动没有力来维持，难以控制。\n 单极模式\n单极模式引入互补PWM波（PWMN），其一般由MCU高级定时器生成，如STM32F429的TIM1、TIM8。\n\n相比受限单极模式，单极模式控制在Q1信号为低电平时，由互补PWM提供，对Q2施加高电平信号，令Q2打开。此时Q2、电机、Q4形成闭合回路。电机中仍然有电流流过，虽然电流会减小，但是仍会产生磁场，仍会产生力矩来继续控制电机转动。该模式优点是启动快，能加速、刹车、能耗制动、能量反馈，调速性能虽然不如双极模式好，但是相差不多，电机特性也较好。在负载超速时，也能提供反向力矩。\n 双极模式\n双极模式下电枢电压极性是正负交替的。\n\n图中，PWM1、PWM2均由定时器输出，PW1N、PW2N为他们的互补PWM通道。PWM1和PWM2周期相同，占空比相同，极性相反，使得对角线上的两个MOSFET能够同时导通，同时关断。最终电机的转动方向由PWM和PWM1共同决定，若A的PWM占空比高于50%则电流从左至右，若低于50%则从右至左。该模式在继承单极模式优点的基础下，在速度快要接近于0时也可以提供一定的力矩，加减速性能更好，因此正反转的性能优于单极模式。控制效果好。缺点是控制更复杂，工作时4个MOS都在工作，功耗大。\n 死区时间\n死区时间（Dead Time）是指在切换两个互补的MOSFET时，为了避免同时导通而导致短路或直通故障，在关断一个MOSFET和导通另一个MOSFET之间插入的延迟时间。死区时间提供了一个缓冲，确保一个MOSFET完全关闭后，另一个才开始导通，从而避免直通故障。\nMOSFET的导通和关断不是瞬时的，而是需要一定的时间。这包括MOSFET栅极充电和放电的时间。不同类型的MOSFET具有不同的开关速度（开通时间和关断时间）。如果死区时间设置得太短，可能不足以覆盖MOSFET的开关时间，导致直通故障。如果死区时间设置得太长，则会降低电路的效率。因为在死区时间内，两对互补的MOSFET都处于关闭状态，没有电流通过负载，导致功率损失和电机或负载的性能下降。\nMOSFET的开关速度与栅极电荷（Qgs、Qgd）和栅极驱动电流有关。死区时间应与这些参数相匹配。较低的栅极电荷通常意味着更快的开关速度，可以使用更短的死区时间。另一方面，高侧和低侧MOSFET的不同Rds(on)值也会影响开关速度，因此在设计死区时间时需要考虑。一些驱动IC会根据MOSFET的特性自动调整死区时间，以优化性能和保护MOSFET。\n 程序代码（以STM32 HAL库为例）\n以IRS21867S方案为例：\n\nMCU为STM32F1，PWM由TIM1通道3生成，PWM-N由TIM1通道3的互补通道生成；PWM1由TIM1通道2生成，PWM1-N由TIM1通道2的互补通道生成。PWM信号从对应的复用GPIO管脚连接至驱动IC。\n\n\n\n模式\nQ1（左上）栅极信号\nQ2（右上）栅极信号\nQ3（左下）栅极信号\nQ4（右下）栅极信号\n\n\n\n\n受限单极模式 (正转)\nPWM\nOFF\nOFF\nON\n\n\n受限单极模式 (反转)\nOFF\nPWM\nON\nOFF\n\n\n单极模式（正转）\nPWM\nOFF\nPWM-N\nON\n\n\n单极模式（反转）\nOFF\nPWM\nON\nPWM-N\n\n\n双极模式\nPWM1\nPWM2\nPWM1-N\nPWM2-N\n\n\n\n根据该真值表，即可通过修改对应的TIM通道的PWM极性来配置电机工作模式。\n为方便，可自定义工作模式函数。\n注意：下面的Set_Motor_Mode()函数仅设置了定时器状态。在受限单极模式和单极模式下，修改Set_Motor_Mode()函数后，一定要记得根据上表修改对应桥臂MOSFET的栅极信号以保证其处于恒导通状态，对电枢电流提供回路。\n// 电机工作模式设置（定时器状态）void Set_Motor_Mode(uint8_t mode)&#123;    switch (mode)    &#123;    case 0: // 受限单极模式（正转）        HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_2);        HAL_TIMEx_PWMN_Stop(&amp;htim1, TIM_CHANNEL_2);        HAL_TIM_PWM_Stop(&amp;htim1, TIM_CHANNEL_3);        HAL_TIMEx_PWMN_Stop(&amp;htim1, TIM_CHANNEL_3);        break;    case 1: // 受限单极模式（反转）        HAL_TIM_PWM_Stop(&amp;htim1, TIM_CHANNEL_2);        HAL_TIMEx_PWMN_Stop(&amp;htim1, TIM_CHANNEL_2);        HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_3);        HAL_TIMEx_PWMN_Stop(&amp;htim1, TIM_CHANNEL_3);        break;    case 2: // 单极模式（正转）        HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_2);        HAL_TIMEx_PWMN_Start(&amp;htim1, TIM_CHANNEL_2);        HAL_TIM_PWM_Stop(&amp;htim1, TIM_CHANNEL_3);        HAL_TIMEx_PWMN_Stop(&amp;htim1, TIM_CHANNEL_3);        break;    case 3: // 单极模式（反转）        HAL_TIM_PWM_Stop(&amp;htim1, TIM_CHANNEL_2);        HAL_TIMEx_PWMN_Stop(&amp;htim1, TIM_CHANNEL_2);        HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_3);        HAL_TIMEx_PWMN_Start(&amp;htim1, TIM_CHANNEL_3);        break;    case 4: // 双极模式        HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_2);        HAL_TIMEx_PWMN_Start(&amp;htim1, TIM_CHANNEL_2);        HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_3);        HAL_TIMEx_PWMN_Start(&amp;htim1, TIM_CHANNEL_3);        break;    case 5: // 关闭输出        HAL_TIM_PWM_Stop(&amp;htim1, TIM_CHANNEL_2);        HAL_TIMEx_PWMN_Stop(&amp;htim1, TIM_CHANNEL_2);        HAL_TIM_PWM_Stop(&amp;htim1, TIM_CHANNEL_3);        HAL_TIMEx_PWMN_Stop(&amp;htim1, TIM_CHANNEL_3);        break;                default:        // 处理非法模式        break;    &#125;&#125;\n配置TIM1：\nvoid MX_TIM1_Init(void)&#123;    TIM_ClockConfigTypeDef sClockSourceConfig = &#123;0&#125;;    TIM_OC_InitTypeDef sConfigOC = &#123;0&#125;;    TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = &#123;0&#125;;    htim1.Instance = TIM1;    htim1.Init.Prescaler = (uint32_t)((SystemCoreClock / 2) / 20000) - 1; //预分频寄存器写入    htim1.Init.CounterMode = TIM_COUNTERMODE_UP;    htim1.Init.Period = 1000 - 1; // 自动重载寄存器写入    htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;    htim1.Init.RepetitionCounter = 0;    htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;    HAL_TIM_Base_Init(&amp;htim1);    sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;    HAL_TIM_ConfigClockSource(&amp;htim1, &amp;sClockSourceConfig);    HAL_TIM_PWM_Init(&amp;htim1);    sConfigOC.OCMode = TIM_OCMODE_PWM1;    sConfigOC.Pulse = 500; // 初始占空比50%    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;    sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;    sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;    sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;    HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_2);    HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_3);    //死区设置    sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;    sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;    sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;    sBreakDeadTimeConfig.DeadTime = 100;    sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;    sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;    sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;    HAL_TIMEx_ConfigBreakDeadTime(&amp;htim1, &amp;sBreakDeadTimeConfig);&#125;\n定时器触发更新事件时间间隔为\nTout=(ARR+1)×(PSC+1)fclkT_{out}=\\frac{(ARR+1)\\times(PSC+1)}{f_{clk}}\nTout​=fclk​(ARR+1)×(PSC+1)​\n可按照该式自定义PWM频率。如要调整初始占空比，可通过改变Pulse参数值（范围为0到Period）来实现。\nPWM输出函数（以单极模式为例）：\nvoid set_pwm(int speed)&#123;    // 处理速度的正负，正值表示正转，负值表示反转    if (speed &gt; 0)    &#123;        Set_Motor_Mode(2);  // 正转        *******此处要记得将Q4栅极信号拉高*******    &#125;    else if (speed &lt; 0)    &#123;        Set_Motor_Mode(3);  // 反转        *******此处要记得将Q3栅极信号拉高*******        speed = -speed; // 将速度值取绝对值    &#125;    else    &#123;        Set_Motor_Mode(5);  // 停止        return;    &#125;    // 限制最低速度，确保电机能够启动    int min_speed = 10; // 定义最低速度    if (speed &lt; min_speed)    &#123;        speed = min_speed;    &#125;    // 将速度值映射到PWM占空比范围    speed = 700 - speed; // 这里700是基准值，越接近700，PWM占空比越小    TIM1-&gt;CCR2 = speed; // 设置TIM1通道2的PWM占空比    TIM1-&gt;CCR3 = speed; // 设置TIM1通道3的PWM占空比&#125;\n主函数：\nint main(void)&#123;    HAL_Init();    SystemClock_Config();    // 初始化TIM1    MX_TIM1_Init();    // 选择电机的工作模式    Set_Motor_Mode(???);         // 主循环    while (1)    &#123;        // 在这里可以通过修改占空比来控制电机速度        set_pwm(???);    &#125;&#125;\n以上是一个最简单的能让电机在开环下转起来的代码。如果要实现动态控制、动态调速，需要加入控制环节，另作介绍。\n","categories":["电子与电路设计"]},{"title":"电机驱动类PCB布局的最佳实践","url":"/2024/08/14/%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E7%B1%BBPCB%E5%B8%83%E5%B1%80%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","content":"原文转自德州仪器（TI）Application Note\n 简介\n电机驱动系统的 PCB 设计并非易事，需要特殊的考虑和技术才能实现最佳性能。电源效率、高速开关频率、低噪声抖动和紧凑的电路板设计是设计人员在布局电机驱动系统时必须考虑的几个主要因素。德州仪器的 DRV 设备非常适合此类系统，因为它们高度集成且配备了保护电路。本应用报告的目标是强调使用 DRV 设备时电机驱动布局的主要因素，并为高性能解决方案提供最佳实践指南，以减少热应力、优化效率并最大限度地降低电机驱动应用中的噪音。\n 接地优化\n任何良好的接地方案的目标都是为 IC 及其周围电路提供稳定的参考（Reference），而不受噪声和其他振荡的影响。本节介绍不同的接地技术、接地的常见挑战、使用接地平面的最佳方式以及双层板的接地注意事项。\n 常用术语/连接方式\n本节中使用的术语定义如下：\n\n\n单点接地（Single Point）：在单点分布中，所有参考点都源自同一源，从而确保每个负载都有自己的不间断接地路径（见图 1-1 右）。建议将此连接用于电源分布线。\n\n\n星形接地（Star Ground）：在星形接地分布中，所有参考点都位于中心；但是，源可能不集中。此方法平衡了所有资源之间的公共阻抗（图 1-1 左）。建议将此连接用于信号线。\n\n\n\n\n\n分区（Partitioning）：在使用分区接地方案的PCB中，数字、模拟和高功率信号有自己独立的区域（见图 1-2）。这种分离不是数字和模拟接地的物理分区。\n\n\n网格化（Grid）：网格化使整个电路板上的接地路径连续，以确保每个信号都有一条返回源的路径（见图 1-3）。这种做法涉及对元件放置、接地填充、过孔放置和走线路径进行细微更改，以最大限度地减少返回地面的路径。网格化有效地创建了一个更加互连的接地平面，可以降低噪声并降低电源和负载之间的阻抗。\n\n\n\n图 1-3 显示了使用接地网格实现有效接地平面的示例。在布局中实施网格化所做的更改很小，这表明小的改动可以产生大影响。\n\n在图 1-3 的示例中，布局 A 和布局 B 是顶层和底层，只留下接地填充、接地走线和前后层之间的过孔。图 1-3 中的布局 C 是电路板接地布线的简单棒状图。每根棒状图或腿代表接地导体的路径。大多数走线仅在一端连接。移除大多数单端走线后，图 1-3 中的布局 D 显示了整个电路板上的接地布线方式；布线上任意两点之间只有一条路径。\n图 1-3 中的布局 E、布局 F、布局 G 和布局 H 显示了为实现网格接地而修改的设计。在图 1-3 中的布局 E 和布局 F 中添加了一些走线（以实心黑色显示）并移动了几何图形（由箭头指示）。图 1-3 中的布局 G 显示了修改后的接地棒状图。两端连接的完整走线形成更完整的导体。比较图 1-3 中的布局 H 和布局 D，网格接地已创建了广泛的互连网络，从而创建了所需的网格。其效果几乎与实际接地平面一样有效。\n 使用地平面\n在 4 层板或更大的 2 层板设计中，建议使用接地平面。将 PCB 的一层作为连续接地平面可使每个信号具有最短的返回路径，并减少耦合和干扰。建议通过仔细布线信号线来尽量减少接地平面的不连续性，并将过孔彼此分开以防止平面中断。有关过孔放置的更多信息，请参阅下文。\n大多数 DRV 设备都有一个用作接地的导热焊盘，并使用接地铜来散热。图 1-4 显示了公共和分离接地平面的良好布局示例。\n\n注意：如果设计是空间受限的 2 层电路板，则接地平面并不总是可行的。在这种情况下，PCB 布局变得更加重要。必须小心谨慎，确保高电流路径远离敏感信号。PCB 的噪声部分（例如功率级 FET、自举电路和电荷泵）通常包含高噪声和纹波，应与此类信号隔离。\n 常见问题\n 电容和电感耦合\n当两条走线平行延伸时，即使距离很短，也可能发生电容或电感耦合。当一条走线的上升沿导致另一条走线的上升沿时，就会发生电容耦合。当一条走线具有上升沿或下降沿，而第二条走线具有耦合的下降沿或上升沿时，就会发生电感耦合。电容耦合比电感耦合更频繁地发生。\n耦合的严重程度取决于走线的长度、开关频率、电压变化和走线之间的距离。为了减少电容耦合，请将嘈杂的信号走线远离重要的数字和模拟信号。尝试在接地平面上布线。\n在带有预驱动器的开关应用中，必须特别注意确保预驱动器的高电流承载接地平面与 IC 其余部分的接地平面物理隔离。这两个地可以在星形点或单点接地位置连接，如上一节所述。\n 共模噪声和差模噪声\n差模噪声沿着迹线传播到接收设备，然后通过返回路径返回到源，从而导致两条迹线之间产生差分电压。当信号和返回路径上都产生电压时，就会发生共模噪声，这是由于共用阻抗上的电压降引起的。地弹就是共模噪声的一个例子。通过确保所有返回源的路径都是宽、短且阻抗低的迹线，可以大大降低发生此问题的可能性。\n\n 考虑EMC\n电磁兼容性 (EMC) 主要取决于布局和组件之间的电气连接。\n每个信号的返回路径必须从资源流向信号源，从而产生电流环路。该线路环路会形成一个天线，可以辐射电磁能量，该能量由电流幅度、信号的重复频率和电流环路的几何面积决定。建议尽量减少这些电流环路以获得最佳 EMC 性能，图 1-6 显示了常见的电流环路类型。\n\n图 1-6 中的电源线形成环路 A–C–D–B 和 A–E–F–B。系统运行所需的能量由这些线路传导。\n环路 L-M-F-D、N-Q-P-F 和 G-H-J-K 由信号和控制形成。如果不考虑系统外部的线路，这些线路所包围的面积通常很小。但是，必须在高频下考虑这些线路，因为它们通常会传输会影响 EMC 性能的信号。\n当连接器、接头或其他组件破坏接地平面时，也会形成电流环路。这会导致开关电流的高频分量在电路板周围传播得更远，从而有效地形成一个大环路。这种情况也可能发生在过孔中。\n 热效应\n电机驱动器并非理想设备，在实际应用中，部分功率会以热量的形式在内部耗散。必须在驱动器损坏之前处理转换为热量的能量。正确的 PCB 设计可以有效消除效率低下产生的热量，并使设备保持在推荐温度。\n PCB 传导和对流\n电机驱动器热性能的一个重要考虑因素是设备内部产生的热量可以消散的路径。热量从芯片传到较低温度环境的主要路径有三条：\n\n封装材料\n键合线\n导热 Pad\n\n以这三条路径为例，导热焊盘是热量从设备传出的最有效路径，其次是封装材料，最后是键合线。导热焊盘集成电路封装中使用的技术从芯片到外部铜平面创建了一条低热阻路径。因此，导热焊盘可以有效地将大量热量从芯片传导出去。驱动器下方的导热焊盘应足够大，以覆盖导热焊盘的整个区域，并且仍然包括 PCB 其他部分的大表面积。导热焊盘还应紧密结合到底部接地平面，并在导热焊盘正下方放置几个导热过孔。图 2-1 显示了设备芯片中产生的热量使用的出口路径示例。\n\n将顶部和底部接地平面连接到驱动器的导热焊盘可显著提高 PCB 设计中的散热量。因此，在布局中应将这些平面做得尽可能大。\n 连续Top-Layer导热焊盘\n将导热焊盘连接到实心铜平面是创建驱动器芯片产生的热量出口路径的重要要求。为了使热量从设备中流出，铜平面必须从导热焊盘连续到电路板上的其他区域。最佳做法是包括一条从驱动器下方的铜填充到宽阔的高表面积平面的宽出口路径。如果这些平面被中断，热量的出口路径就会收缩，从而增加热阻。热阻的增加会导致导热焊盘和同一平面上更宽的表面积之间的温差更大。图 2-2 显示了驱动器下方收缩和连续接地浇注引起的温升示例。\n\n在驱动器下方放置连续的铜导热焊盘对于设备高效冷却非常重要。\n将宽路径整合到高表面积平面可使驱动器导热焊盘和环境空气温度之间的热阻保持在最低水平。\n 铜厚 （Copper Thickness）\n虽然连续、宽阔的平面会降低热阻，但平面上的铜厚度也是 PCB 热性能的关键考虑因素。通过增加 PCB 上的铜镀层厚度，平面的有效热阻会降低。下式可计算铜厚度与平面面积之间的关系：\nθcu=(1λcu×length)/Area\\theta_{cu}=(\\frac{1}{\\lambda_{cu}}\\times length ) / Area\nθcu​=(λcu​1​×length)/Area\n假设长度和宽度为 1 厘米，镀层厚度为 1 盎司 (0.0035 厘米)，则与驱动器横向连接的铜平面的近似热阻可按照下式计算：\nθcu=(1λcu×length)/Area=(25℃cm/W×1cm)/1cm×0.0035cm=71.4℃/W\\theta_{cu}=(\\frac{1}{\\lambda_{cu}}\\times length ) / Area = (25 ℃ \\quad cm/W \\times 1 cm) / 1 cm \\times 0.0035 cm =71.4 ℃/W\nθcu​=(λcu​1​×length)/Area=(25℃cm/W×1cm)/1cm×0.0035cm=71.4℃/W\n如果铜厚度加倍，相同尺寸平面的热阻就会减半。连接到驱动器的接地平面上的铜厚度越厚，有助于高效地将热量从设备传导到周围空气中，而不会导致电路板上出现明显的温差。\n 散热过孔连接方式（Thermal via Connections）\n散热过孔应将顶层和底层连接在一起，以便热量可以从 IC 散发到两层。散热过孔不应使用热风焊盘（Thermal Relief，即十字花焊盘，为了防止因散热过快而导致的虚焊，在电源和地的过孔采用十字花的工艺连接，减少了接触面积，降低了散热速度，方便焊接）连接，因为热量从顶层通过通孔流到底层的路径受到限制。这种热流路径的收缩导致通孔周围顶层剩余部分的温度升高。直接连接通孔可使通孔和铜层之间的热阻尽可能低。散热通孔应与内部接地平面连接，并在镀通孔的整个圆周周围进行完整连接。不要用焊料掩模覆盖通孔，否则会导致过多的空洞。图 2-3 显示了散热通孔和直接连接通孔之间的温差。\n参见：如何使引脚接地为十字焊盘，但过孔为完全接地?\n\n散热焊盘接头将平面与过孔或组件电连接起来，但它们会减少组件或过孔与平面之间的热流。这样做的目的是让烙铁或回流炉只加热组件并确保可靠的焊接连接。这种方法对于不需要过孔在平面之间进行热传导的应用非常有效。然而，电源应用（例如电机驱动器）要求将这些过孔直接粘合到平面上，以实现层间的最佳热性能。\n 散热过孔宽度 （Thermal Via Width）\n虽然导热焊盘在芯片和 PCB 顶部接地平面之间提供了低阻抗热路径，但应考虑连接顶部和底部接地平面的过孔的热阻抗。德州仪器建议在导热焊盘正下方设置直径为 20 mil 的导热过孔，孔径为 8 mil。\n减小散热孔的直径或增加孔的尺寸会增加热阻。建议的 8 mil 孔尺寸和 20 mil 直径需要从散热焊盘到底层的最小焊料芯吸，并将过孔的热阻保持在最低水平。图 2-4 显示了推荐的过孔放置位置。\n\n PCB散热设计小结\n总结一下热设计，电机驱动器系统中热设计的主要考虑因素如下：\n\n导热焊盘（Thermal Pad）连接是器件芯片导热的最有效途径\n使用从导热焊盘到接地平面的连续顶层灌注\n尽可能使用 1.5 或 2 盎司铜厚\n使用直接连接热通孔\n使用 8 mil x 20 mil 的导热过孔（Via）尺寸，以避免过多的焊料渗入\n将热通孔分组为阵列，以最小化平面之间的热阻\n\n 过孔（Vias）\nPCB 上的通孔在电路板的不同层上具有两个位于相应位置的焊盘，它们通过穿过电路板的孔进行电连接。该孔通过电镀制成导电的。有几种类型的通孔，例如盲孔、埋孔和热孔。对于电机驱动器 PCB 设计，重点是普通通孔和热孔。\n通孔经常用于信号轨道和电源轨道的 PCB 布线。对于信号连接，电流很小（微安到毫安），一个或两个通孔可能足以将信号路由到另一层。对于电源连接，可以在电源或接地迹线上添加多通孔或“通孔拼接”，以确保层间以及电源和接地平面之间的低阻抗连接。还可以添加多通孔以将设备产生的热量散发到其他电路板层，如第上一节所述。\n\n 过孔电流承载量（Via Current Capacity）\n在电机驱动器 PCB 设计中，多通孔通常用于层间高电流连接。提供适当的通孔尺寸和数量以实现低电阻和长期可靠性非常重要。通常，通孔的直径至少应为走线的长度。在使用铜平面作为走线的情况下，多个通孔应位于电流进入或离开元件引脚的位置附近。\n下表列出了按照 IPC-2152 标准，1 盎司 PCB 在温度升高 10°C 时不同通孔直径的电流容量。\n\n\n\nVia \t Diameter\nCurrent Capacity\n\n\n\n\n6  \t    mil\n0.2       A\n\n\n8  \t   mil\n0.55      A\n\n\n10 \t   mil\n0.81      A\n\n\n12 \t    mil\n0.84      A\n\n\n16 \t   mil\n1.1       A\n\n\n\n 过孔布局建议\n 多过孔布局\n多通孔对于低寄生接地和大电流连接非常有用。图 3-2、图 3-3 和图 3-4 显示了多通孔放置在电路板设计的不同位置的示例。\n\n\n\n 过孔放置\n尽管过孔很小，但它们会占用 PCB 和接地平面上的空间。将多个过孔布线在一起会在平面上产生间隙，并影响电流和接地回路。良好的过孔布局可为所有信号创建充足的返回路径。图 3-5 显示了如何避免过孔造成不必要的接地平面分裂的示例。\n\n 通用布线技巧\n在进行电机驱动器 PCB 设计时，请遵循以下通用布线技术：\n\n使栅极驱动器走线尽可能宽且长度尽可能短。对于至少 1 盎司铜，从 20 密耳的走线宽度开始，如果大电流需要，则走线宽度可以更大。\n\n\n\n高端FET栅极的信号走线应当尽可能靠近开关节点走线，以尽量减少电感、环路面积以及 dv/dt 开关引起噪声的可能性。\n\n\n\n不要使用直角走线。走线中的 90 度弯曲会起到阻抗的作用，并可能导致电流反射。当电机的相位切换时，急弯可能会引发电磁干扰 (EMI) 问题。圆形弯曲是理想的，但在实际设计中可能不切实际。拐角布线的最佳做法是使用钝角。图 4-3 显示了走线中不同角度的示例。\n\n\n\n将过孔过渡到焊盘，特别是将输出引脚上的细线过渡到粗线。泪滴（Teardrop）技术可降低信号转换的热应力。该技术还可避免线的开裂，并使线在机械上更坚固。泪滴技术适用于从小信号过渡到通孔焊盘的情况。\n\n\n\n绕物体布线时，应以平行对的方式布线，以避免因分叉布线而导致的差分阻抗和不连续性。这种方法对于电流检测放大器的信号非常重要。\n\n\n\n将无源元件（例如源匹配电阻或交流耦合电容）放置在信号路径内，并将它们并排放置。平行放置元件可产生更宽的走线间距。不建议交错放置元件，因为这会造成狭窄的区域。\n\n\n\n将电路的模拟部分和数字部分分开接地是抑制噪声的最简单、最有效的方法之一。\n\n\n Bulk电容和旁路电容的放置\n Bulk电容放置\n在电机驱动系统设计中，Bulk电容器（大容量电容器）可最大限度地减少低频电流瞬变的影响，并存储电荷以提供电机驱动器切换时所需的大电流。选择Bulk电容器时，请考虑电机系统所需的最高电流、电源电压纹波和电机类型。\n使用Bulk电解电容帮助从通过电机绕组驱动的电流中获取低频、高值电流。这些电容器通常大于 10 μF，具体取决于应用要求。\n将所有Bulk电容器放置在电源模块或电路板的电源入口点附近。TI 建议每个Bulk电容器都有多个通孔将焊盘连接到相应的电源层。TI 还建议所有Bulk电容器都具有低等效串联电阻 (ESR)。\n\n\n 电荷泵电容器（Charge Pump Capacitor）和自举电容\nTI 的大多数电机驱动设备 (DRVxx) 都使用电荷泵或自举电容器来完全切换高侧 N 沟道 MOSFET 的栅极。将这些电容器放置在尽可能靠近电机驱动设备的位置。在图 5-3 中，C4 电容器是用于从 VM 到 VCP 引脚的电荷泵输出的电容，而 C7 电容器是用于电荷泵切换节点的电容。\n\n 旁路（Bypass）/解耦（Decoupling）电容放置\n 靠近电源\n旁路电容用于将高频噪声最小化，以减少进入 DRV 器件电源引脚的噪声。TI 建议将电容尽可能靠近器件的电源输入引脚和接地引脚。如果旁路电容和器件之间的走线长度没有最小化，它们可能会在旁路电容要过滤的高频下产生电感。走线电感增加的阻抗可能导致电源引脚处的电压或电流产生振铃，从而导致 EMI 并影响数字或模拟电路的性能。最佳做法是将值较小的电容尽可能靠近器件放置，以最大限度地减少走线电感的影响。将值较大的电容连接到值较小的电容之后，因为随着电容值的增加，电感变得更小。\n\n如上文所示，使用的过孔越多，阻抗越低。TI 强烈建议在电源层和接地层使用多个过孔。将过孔直接放置在电容器的安装焊盘上是一种有效的方法，可以最大限度地减少布线面积，同时仍能实现电流流动布线。请遵循以下旁路电容器指南：\n\n\n不要在旁路电容器和有源器件之间使用过孔。可视化高频电流流动并尽可能减少高频电流环路。\n\n\n确保旁路电容器与有源元件位于同一层，以获得最佳效果。不要在旁路电容器引脚和 IC 电源或接地引脚之间放置过孔。\n\n\n将过孔布线到旁路电容器中，然后再布线到有源元件中。\n\n\n使用最多的过孔和最宽的走线以获得最佳布局。\n\n\n旁路电容器越近越好（小于 0.5 厘米，0.2 英寸）。\n\n\n不要使用大于 3:1 的长宽比。\n\n\n\n 靠近功率级（Power Stage）\n对于功率级上的旁路电容，请使用小型陶瓷电容器来衰减由 MOSFET 和其他寄生电容切换引起的高频电流。这些电容器的电容值通常小于 10 μF，具体取决于应用要求。\n\n 靠近开关电流源（Switch Current Source）\n正确布局和放置这些电容器对于确保其有效性至关重要。电容和开关电流源之间的任何额外寄生电感都会降低其效果。理想情况下，将电容器放置在尽可能靠近开关电流源的位置，在本例中为电机和 MOSFET。图 5-7 显示了基于上一个原理图示例的示例布局。\n\n 靠近电流测量运放\n对于带有集成电流检测放大器 (CSA) 的设备，TI 建议将额外的去耦电容尽可能靠近检测引脚放置，并使用大约 1 nF 的值。图 5-8 显示了去耦电容 C12、C13 和 C17。\n\n 靠近稳压器（Voltage Regulators）\n对于带有稳压器的器件，请将电容器尽可能靠近引脚放置。尽量减少接地引脚的接地回路。例如，图 5-9 显示 C18 电容器尽可能靠近 DVDD 稳压器。\n\n MOSFET的放置与功率级布线\n栅极驱动器和功率 MOSFET 的放置对于预驱动器电机驱动解决方案的正确功能和最佳性能至关重要。对于带有集成 MOSFET 的电机驱动器，例如 DRV8870、DRV8313、DRV10987、DRV10983-Q1 和 DRV8873-Q1，正确的布线已在内部完成。对于栅极驱动器，例如 DRV8701、DRV8304、DRV8306、DRV8323、DRV8343-Q1 和 DRV8353，仔细规划 PCB 的布局和功率 MOSFET 的放置非常重要。以下部分介绍了一些常见的 MOSFET 拓扑，并介绍了使用常见电机驱动架构的基本布局示例。\n 常见功率 MOSFET 封装\n本节介绍一些常见的 N 沟道功率 MOSFET 封装类型。大多数\n功率 MOSFET 都有这四种选项之一。通过了解封装类型、尺寸和引脚排列，可以更好地设计 PCB 以获得最佳解决方案。\n图 6-1 中的符号代表 N 沟道功率 MOSFET。虽然 MOSFET 是一种四端器件，具有源极、栅极、漏极和体极，但体极通常位于源极端子。\n\nMOSFET 封装与功率级和散热直接相关。不同的封装具有不同的布线规则。\n DPAK\n图 6-2 所示的 DPAK (SOT-252) 封装是业界最常用的封装之一。此封装在尺寸和性能之间实现了折衷。DPAK 封装通常用于高功率 MOSFET 和稳压器。\n\n D2PAK\nD2PAK（SOT-252）封装（见图 6-3）是 DPAK 封装的较大版本，可以提供更好的散热效果。\n\n TO-220\nTO-220 封装（见图 6-4）是一种通孔 MOSFET 封装。直立片可用于安装散热器。使用这种封装的缺点是它需要更多空间，并且通常比表面贴装封装（例如 DPAK 和 D2PAK 封装）更高。\n\n 8-Pin SON\n8 引脚 SON 封装（见图 6-5）是最常见的无引线封装。此封装提供了一种解决方案，可实现最小的电路板空间和最佳性能。大多数引线封装具有相似的引脚排列。8 引脚 SON 封装的独特之处在于，与引线封装（TO-252 和 TO-220）相比，栅极引脚位于相反的一侧。\n\n MOSFET布局设置\n图 6-6 和图 6-7 显示了两种典型配置的常见 MOSFET 位置和布局；分别为半桥堆叠和半桥并排，适用于有引线和无引线封装。\n\n\n这些半桥布局可以重复用于多个半桥拓扑，包括 H 桥（两个半桥）、逆变器（三个半桥）和双 H 桥（四个半桥）。\n 功率级布局设计\n在为功率 MOSFET 选择正确的位置后，下一步是确保布线正确。由于 MOSFET 用于高功率、电机驱动开关应用，因此设计对非理想布局引入的寄生效应很敏感。本节介绍了一些需要布线的关键信号以及管理这些信号的最佳实践。功率级如图 6-8 所示。\n\n 开关节点（Switch Node）\n开关节点是高端 MOSFET 的源极引脚和低端 MOSFET 的漏极引脚之间的连接，如图 6-10 所示。此节点是最终连接到负载（在本应用中为电机）的网络。开关节点是半桥配置中要路由的最关键信号，因为此网络上的信号具有高频、大电流特性。图 6-8 所示的电路具有由 PCB 和功率 MOSFET 引起的许多非理想寄生效应。图 6-9 显示了其中一些主要寄生效应，它们是开关节点振铃现象的主要原因。\n\n开关节点振铃是由于 PCB 和功率 MOSFET 的寄生效应导致的开关节点上的 LC 振荡。开关节点振铃会导致 EMI 并产生过冲和下冲电压，这可能会违反 MOSFET 漏极-源极电压和栅极驱动器引脚的绝对最大额定值。它还会降低功率级的效率。\n可以通过外部措施和系统调整（降低斜率、外部缓冲器等）来解决开关节点振铃问题，但基本合理的布局可以解决许多主要问题。图 6-10 中的布局示例显示了最小化高端 MOSFET 源极和低端 MOSFET 漏极之间电感的设计。最佳做法是最小化铜平面连接的长度并最大化其宽度，并使用具有最小寄生电感的 MOSFET 封装。\n\n 大电流循环路径（High-Current Loop Paths）\n由于电机应用依赖于高开关电流，因此最小化高电流路径的总环路电感至关重要。最小化该电感可最大程度地减少电压纹波和噪声，并可减少对额外旁路电容的需求。\n在电机系统中，高电流环路从电源的正极开始，经过高端功率 MOSFET，经过电机绕组，经过相反的低端 MOSFET，再回到电源的负极。图 6-11 以 H 桥示例显示了此流程。\n\n应通过以下方式最小化高电流环路路径：\n\n\n对整个高电流环路使用正确的走线宽度。增加走线宽度可降低寄生电感。\n\n\n使用正确的布局来最小化元件之间的距离。减少走线长度可降低寄生电感。\n\n\n尽量减少高电流路径中的层跳转数量，并在使用高电流走线跳转层时使用正确的通孔尺寸和数量。\n\n\n图 6-12 显示的是优化大电流环路的示例布局。\n\n VDRAIN 检测引脚\nVDRAIN 引脚用于感测高端 MOSFET 漏极电压。具有 VDRAIN 引脚的电机驱动设备必须经过一定的布线才能获得最佳性能。由于电压供应首先到达高端 MOSFET 的漏极，因此 VDRAIN 引脚的布线对于布局至关重要。VDRAIN\n引脚为电压供应 (VM) 提供 Kelvin 连接，从而可以在发生过流事件时监控高端 MOSFET 的 VDS 电压（见图 6-13）。由于功率级中的 VM 连接通常由大铜平面和宽走线组成以支持所需的电流，因此平面的额外电感和压降可能会影响 VDS 测量精度。因此，将 VDRAIN 引脚通过一条走线直接布线到外部功率 MOSFET 的漏极。TI 建议在漏极附近使用 Net Tie 以尽量减少可能导致错误 OCP 故障的额外电感（见图 6-14）。\n\n\n有关 Kelvin 连接，参见：The basics of Kelvin connections\nNet Tie 是一种在PCB设计中将两个或多个不同的网络在特定位置进行连接的技术，通常用于管理不同网络之间的连接关系。它是一种特殊的器件，形式上可以表现为一小段连接铜皮、过孔或其他类似的结构。有关更多 ，参见：Net Ties and How to Use Them\n 电流检测放大器布线（Current Sense Amplifier Routing）\nTI 的各种电机驱动器都包含具有内置电流感应功能的器件，其中大多数使用外部分流电阻作为测量源。将电流感应放大器与驱动器结合使用为电机接口提供了一体化解决方案，并允许以更低的成本实现更高质量的电流感应。图 7-1 显示了所有可用的电流感应拓扑。\n\n这些设备内置的集成电流检测放大器 (CSA) 通常分为三类，每类都有各自的优点。以下将介绍这些类别。\n 单高端电流分流器（Single High-Side Current Shunt）\n图 7-2 显示了高端（High-Side）电流检测电路。\n\n使用高侧电流检测的好处包括：\n\n\n直接测量电源电流\n\n\n可以检测负载短路\n\n\n不受地（GND）干扰\n\n\n使用高端电流检测的缺点是它需要更多的共模电压。\n 单低端电流分流器（Single Low-Side Current Shunt）\n图 7-3 显示了低端电流分流电路。\n\n使用低侧电流分流器的好处是它需要的共模电压较低。\n使用低侧电流分流器的缺点是它更容易受到接地噪声的影响，并且无法检测接地短路。\n 两相和三相电流分流放大器（Two-Phase and Three-Phase Current Shunt Amplifiers）\n图 7-4 显示了具有两相和三相 CSA 的电路。\n\n两相和三相 CSA 对电路板布局有利，因为它们对共模电压的要求较低。它们还可以单独测量每个通道，因此可用于更复杂的控制方案，例如磁场定向控制。\n在电路板布局中使用两相和三相 CSA 的缺点包括：\n\n对接地噪声的敏感性更高\n无法检测接地短路\n可能需要更多软件来实现总系统电流\n\n 器件选型\n在选择检测电阻（精密电阻）时，需要在精度和功耗之间进行权衡。由于功率级中的大电流会流过检测电阻，因此所选电阻值必须很小，以将功耗保持在最低水平。对于大电流系统，电阻值通常以 mΩ 为单位。例如，驱动 20 A 电流并使用 1 mΩ 检测电阻的系统将从该电阻上耗散 400 mW。在这种情况下，CSA 的输入仅接收 20 mV 的信号。增加电阻值可以提高信噪比，但也会增加功耗。\nCSA 的性能参数也必须考虑。在针对系统中的最坏情况电流进行设计时，所选的分流电阻应防止电流检测输入引脚上的电压高于 CSA 的绝对最大额定值。在正常运行期间，此电压必须保持在差分电压范围的指定参数范围内。要选择检测电阻，请参阅器件数据表。\n对于使用外部增益电阻的器件（例如 DRV3201-Q1），请选择具有高精度的组件。组件不匹配会导致整个系统的共模和差模增益发生很大变化。\n 器件放置（Placement）\n检测电阻的放置位置应与功率级的组件一致，以最大限度地减少走线阻抗。分流电阻也应放置在靠近 CSA 连接的位置，以降低在电路板上其他走线上耦合的可能性。\n对于高端电流检测，分流电阻应靠近电源和高端 MOSFET 源极之间的星点。对于使用外部增益电阻的高端电流检测设备（例如 DRV3205-Q1），分压器中的第一个电阻应放置在最靠近分流电阻的位置。其余组件应放置在最靠近设备的位置。\n对于低端电流检测，分流电阻应位于低端 MOSFET 的源极和功率级的星点接地连接之间。\n对于在两个或三个单独相位上具有分流电阻的系统，分流电阻应放置在相应低端 MOSFET 的源极和星点接地连接之间。\n 布线（Routing）\n必须使用差分对来路由检测信号。在差分对中，两个信号在布局中紧密耦合，并且走线必须从分流器或检测电阻器平行延伸到 IC 输入端的 CSA。\n\n 实用工具（Net Tie 和 差分对）\n许多现代 CAD 工具都实现了可帮助布局工程师正确布线 PCB 的功能。本节中介绍的功能是 Altium Designer 工具的一部分；但是，许多其他工具也具有类似的功能。\n在初始阶段布线 PCB 时，有助于显示哪些组件布线到哪里的指南在检测电阻布线的情况下可能会产生误导。在低侧分流电阻的情况下，负输入可以直接接地，而正输入可以直接连接到低侧源极引脚。为避免这种情况，请在设备和分流电阻之间放置一个 Net Tie，以便设计人员可以在放置期间而不是布线期间放置布线限制。图 7-6 显示了 Net Tie 放置的示例。\n\n使用差分对的布局技术通过并行布线两个紧密耦合的信号来降低共模噪声。TI 建议使用差分对将信号从分流电阻布线到 CSA。为了进一步降低噪声耦合，请勿将噪声敏感的走线与噪声（开关）信号并行布线。\n 输入和输出过滤（Input and Output Filters）\n感测放大器的输入和输出滤波器尽可能靠近感测放大器。这种放置方式可确保设备接收到的不需要的噪声被限制在滤波器和感测放大器之间。图 7-7 显示了输入滤波器（C40、R30 和 R31）的示例布局。\n\n\n CSA 小结\n设计电机驱动器的电路板布局时，请执行以下操作：\n\n使用开尔文连接\n使布局对称\n使用 Net Ties 和差分布线工具\n\n","categories":["电子与电路设计"]},{"title":"线性系统理论期末考点","url":"/2024/10/22/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9/","content":" 第七章 数学基础\n\n单模矩阵与单模变换\n互质性与互质性判据（秩判据）\n既约性与既约性判据（行次系数矩阵或列次系数矩阵）\n非既约矩阵的既约化\nSmith标准形\n\n 第八章 矩阵分式描述（MFD）\n\n左MFD与右MFD的求法\n真与严真的性质与判据\n\n有理分式判别法（分子次数小于等于为真，小于分母次数为严真）\nG(s)G(s)G(s)阵判别法（s趋向无穷时G(s)G(s)G(s)等于常阵为真，等于零为严真）\n列既约右MFD列次系数判别法\n行既约左MFD行次系数判别法\n\n\n从非真MFD导出严真MFD（多项式除法导出有理分式部分并求出新的R(s)R(s)R(s)作为N(s)N(s)N(s)）\n不可简约MFD的性质与判据（互质性判据，判断有无同时降秩的sss值）\n由可简约MFD求不可简约MFD的算法（以右MFD为例）\n\n求gcrd表为R(s)R(s)R(s)\n求R(s)R(s)R(s)的逆，表为R−1(s)R^{-1}(s)R−1(s)\nD(s)D(s)D(s)和N(s)N(s)N(s)分别右乘R−1(s)R^{-1}(s)R−1(s)得到新的D(s)D(s)D(s)和N(s)N(s)N(s)\n组合，解毕\n\n\n\n 第九章  传递函数矩阵的结构特性\n\n史密斯-麦克米伦形的形式与导出\n\n求出所有元有理分式的最小公分母，表为d(s)d(s)d(s)\n分子矩阵化为Smith标准形\n消去公因子，解毕\n\n\nM(s)的基本特性\n\n唯一性\n非保真性\n\n\n有限零点和有限极点\n\nRosenbrock零极点定义（基于M(s)的判别法，只适用于有限复平面）\n推论性定义\n\n基于不可简约MFD：极点令detD(s)detD(s)detD(s)等于0，零点令N(s)N(s)N(s)降秩\n基于状态空间方程：极点令det(sI−A)=0det(sI-A)=0det(sI−A)=0，零点令系统矩阵降秩\n\n\n零点直观解释与其阻塞定理（书P479）\n\n\n结构指数\n\n定义（书P480），来自于零极点集合，基于S-M形求解\n含义（书P481）\n\n\n无穷远处的零点和极点\n\n思路：引入s=λ−1s=\\lambda^{-1}s=λ−1，化为以λ\\lambdaλ为变量的有理分式矩阵H(λ)H(\\lambda)H(λ)，求出其S-M形，然后按照有限零极点定义求解\n\n\n评价值\n\n有限复平面的评价值求法（书P486）\n由评价值构造S-M形（书P489）\n无穷远处评价值求法（分母次数-分子次数，书P490）\n\n\nS-M形的合成表达式（书P492）\n\n 易错考点\n\n零极点推论性定义都基于不可简约MFD，如果题目给出的是可简约MFD，需要转化为不可简约MFD\n根据G(s)G(s)G(s)求评价值时，直接求各阶子式，子式中包含的分式所对应的sss即为所求的零极点集合，不需要求M(s)M(s)M(s)再求零极点\nM(s)M(s)M(s)中对角线各元素必须满足整除性，具体为分子次数随位置增加越来越大，分母次数越来越小\n求解M(s)M(s)M(s)过程中导出N(s)N(s)N(s)时，分母需首一化\n根据零点阻塞定理求对应的x0x_0x0​和u(t)u(t)u(t)时，先由Cx0=0Cx_0=0Cx0​=0确认非零初始状态x0x_0x0​，然后由(sI−A)x0+Bu0=0(sI-A)x_0+Bu_0=0(sI−A)x0​+Bu0​=0求u0u_0u0​\nsss在无穷远处的评价值即为对应的有理分式的分母次数减去分子次数\nsss在无穷远处的零点和极点即为λ=1/s\\lambda=1/sλ=1/s矩阵在λ=0\\lambda=0λ=0处的零点和极点\n\n 第十章 传递函数矩阵的状态空间实现\n\n实现的定义与属性（唯一性、维数、最小实现）\n\nG(s)=C(sI−A)−1BG(s)=C(sI-A)^{-1}BG(s)=C(sI−A)−1B\n实现维数：dim(A)dim(A)dim(A)\n最小实现：所有实现中维数最小\n\n\n标量传递函数/传函矩阵的标准实现（要求G(s)G(s)G(s)严真）\n\n能控标准形实现（书P528）\n\n将G(s)G(s)G(s)表示为P(s)d(s)\\frac{P(s)}{d(s)}d(s)P(s)​的形式，并全部展开\nP(s)P(s)P(s)按sns^nsn系数拆开为P0(s)P_0(s)P0​(s)、P1(s)P_1(s)P1​(s)…\n类似于标量传递函数能控形求解方式进行组合\n能控形实现一般不保证能观性\n\n\n能观标准形实现（书P530）\n\n\nMFD的标准实现（要求MFD严真）\n\n控制器形实现\n观测器形实现\n\n\n\n 易错考点\n\n控制器形和观测器形都要求MFD为严真，如果给出的MFD非严真，则需求其严真部分的MFD。在分离出Q(s)Q(s)Q(s)和Gsp(s)G_{sp}(s)Gsp​(s)后，考虑Gsp(s)=R(s)×D−1(s)G_{sp}(s)=R(s)\\times D^{-1}(s)Gsp​(s)=R(s)×D−1(s)，有R(s)=Gsp(s)×D(s)R(s)=G_{sp}(s)\\times D(s)R(s)=Gsp​(s)×D(s)\n若MFD为不可简约，则该MFD的实现必为最小实现\n最小实现的形式不唯一但必定代数等价\n若题目要求判断是否为实现，则通过G(s)=C(sI−A)−1BG(s)=C(sI-A)^{-1}BG(s)=C(sI−A)−1B判断\n如果要求判断是否为最小实现\n\n若已知状态空间方程，判断其是否同时满足能控且能观\n若已知MFD，判断其是否为不可简约\n\n\n给定MFD的控制器形实现，判断实现维数时，所求维数即为dim(Ac)=degdetD(s)dim(A_c)=deg det D(s)dim(Ac​)=degdetD(s)\n控制器形求解步骤\n\n确认MFD为右严真MFD，如非严真，将其严真化\n写出每行的列次数\n写出DhcD_{hc}Dhc​、DlcD_{lc}Dlc​、NlcN_{lc}Nlc​\n写出Ac0A^{0}_cAc0​、Bc0B^{0}_cBc0​\n由Ac=Ac0−Bc0×Dhc−1×DlcA_c=A^{0}_c-B^{0}_c\\times D^{-1}_{hc}\\times D_{lc}Ac​=Ac0​−Bc0​×Dhc−1​×Dlc​、Bc=Bc0×Dhc−1B_c=B^{0}_c\\times D^{-1}_{hc}Bc​=Bc0​×Dhc−1​、Cc=NlcC_c=N_{lc}Cc​=Nlc​\n\n\n\n 第十一章 PMD\n\nPMD的形式\n\n同传递函数矩阵G(s)G(s)G(s)的关系\n\nG(s)=R−1(s)P(s)Q(s)+W(s)G(s)=R^{-1}(s)P(s)Q(s)+W(s)G(s)=R−1(s)P(s)Q(s)+W(s)\n\n\n同状态空间描述的关系\n\nP(s)=sI−A,Q(s)=B,R(s)=CP(s)=sI-A,Q(s)=B,R(s)=CP(s)=sI−A,Q(s)=B,R(s)=C\n\n\n同严真MFD的关系\n\n右MFD：P(s)=D(s),Q(s)=I,R(s)=N(s)P(s)=D(s),Q(s)=I,R(s)=N(s)P(s)=D(s),Q(s)=I,R(s)=N(s)\n左MFD：P(s)=DL(s),Q(s)=NL(s),R(s)=IP(s)=D_L(s),Q(s)=N_L(s),R(s)=IP(s)=DL​(s),Q(s)=NL​(s),R(s)=I\n\n\n\n\n不可简约PMD\n\n判断不可简约条件\n\nP(s),Q(s)P(s),Q(s)P(s),Q(s)左互质\nP(s),R(s)P(s),R(s)P(s),R(s)右互质\n\n\n不可简约PMD的构造（不可简约MFD构造的组合）\n\n\nPMD的观测器形实现\n\n由PMD化左MFD\n判断左MFD行既约，后判断是否严真\n构造左MFD观测器形实现\n转化为PMD观测器形实现（书P579）\n判断是否为最小实现（PMD不可简约，MFD不可简约，完全能控和能观）\n\n\nPMD的极点和零点\n\nPMD的极点（detP(s)=0detP(s)=0detP(s)=0）\nPMD的传输零点（系统矩阵降秩）\n输入解耦零点（PQ行降秩）\n输出解耦零点（PR列降秩）\n\n\n系统矩阵\n\n 第十二章 线性时不变控制系统的复频域分析\n\n并联系统\n\n完全能控 == D1(s)D_1(s)D1​(s)和D2(s)D_2(s)D2​(s)左互质\n完全能观 == DL1(s)D_{L1}(s)DL1​(s)和DL2(s)D_{L2}(s)DL2​(s)右互质\nG1(s)G_1(s)G1​(s)和G2(s)G_2(s)G2​(s)无公共极点可推出SPS_PSP​完全能控和完全能观\n\n\n串联系统\n\n完全能控 == D2(s)D_2(s)D2​(s)和N1(s)N_1(s)N1​(s)左互质\n完全能观 == DL1(s)D_{L1}(s)DL1​(s)和NL2(s)N_{L2}(s)NL2​(s)右互质\n\n\n输出反馈系统的能观/能控性（书P622）\n\n完全能控 == S12S_{12}S12​完全能控\n完全能观 == S21S_{21}S21​完全能观\n若S2S_2S2​为常阵，则S1S_1S1​能控能观等价于整个系统能控能观\nGF(s)=G1(s)[I+G2(s)G1(s)]−1=[I+G1(s)G2(s)]−1G2(s)G_F(s)=G_1(s)[I+G_2(s)G_1(s)]^{-1}=[I+G_1(s)G_2(s)]^{-1}G_2(s)GF​(s)=G1​(s)[I+G2​(s)G1​(s)]−1=[I+G1​(s)G2​(s)]−1G2​(s)\n\n\n直接输出反馈系统的稳定性分析\n\n系统BIBO稳定 == 系统渐进稳定\n系统以有理分式矩阵表征时\n\n系统渐进/BIBO稳定 == Δ1(s)det[I+G1(s)]=0\\Delta_1(s)det[I+G_1(s)]=0Δ1​(s)det[I+G1​(s)]=0的根全部具有负实部\n\n\n系统以不可简约右MFD表征时\n\n系统渐进/BIBO稳定 == Δ1(s)det[D1(s)+N1(s)]=0\\Delta_1(s)det[D_1(s)+N_1(s)]=0Δ1​(s)det[D1​(s)+N1​(s)]=0的根全部具有负实部\n\n\n系统以不可简约左MFD表征时\n\n系统渐进/BIBO稳定 == Δ1(s)det[DL1(s)+NL1(s)]=0\\Delta_1(s)det[D_{L1}(s)+N_{L1}(s)]=0Δ1​(s)det[DL1​(s)+NL1​(s)]=0的根全部具有负实部\n\n\n\n\n带补偿器的输出反馈系统的稳定性\n\n渐进稳定与BIBO稳定的等价条件\n\n若S12S_{12}S12​能控，S21S_{21}S21​能观，二者等价\n若不满足上一个条件，只能通过渐进稳定推出BIBO稳定\n\n\nG1(s)G_1(s)G1​(s)和G2(s)G_2(s)G2​(s)均以有理分式矩阵表征\n\n渐进稳定 == Δ1(s)Δ2(s)det[I+G1(s)G2(s)]=0\\Delta_1(s)\\Delta_2(s)det[I+G_1(s)G_2(s)]=0Δ1​(s)Δ2​(s)det[I+G1​(s)G2​(s)]=0的根全部具有负实部\n\n\nG1(s)G_1(s)G1​(s)和G2(s)G_2(s)G2​(s)以不可简约左MFD和右MFD表征\n\n渐进稳定 == det[DL1(s)D2(s)+NL1(s)N2(s)]=0det[D_{L1}(s)D_2(s)+N_{L1}(s)N_2(s)]=0det[DL1​(s)D2​(s)+NL1​(s)N2​(s)]=0的根均具有负实部\n\n\nG1(s)G_1(s)G1​(s)和G2(s)G_2(s)G2​(s)以不可简约右MFD和左MFD表征\n\n渐进稳定 == det[DL2(s)D1(s)+NL2(s)N1(s)]=0det[D_{L2}(s)D_1(s)+N_{L2}(s)N_1(s)]=0det[DL2​(s)D1​(s)+NL2​(s)N1​(s)]=0的根均具有负实部\n\n\n特殊情形\n\n若反馈通路为常阵，则系统渐近稳定==BIBO稳定\n\n\n\n\n\n"}]