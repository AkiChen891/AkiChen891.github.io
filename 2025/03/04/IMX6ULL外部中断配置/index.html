<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Cortex-A7中断系统  中断向量表 Cortex-A7的中断向量表共有8个异常中断，其中一个未使用，有效中断为7个：    向量地址 中断类型 中断模式     0X00 复位中断(Rest) 特权模式(SVC)   0X04 未定义指令中断(Undefined Instruction) 未定义指令中止模式(Undef)   0X08 软中断(Software Interrupt,SWI)">
<meta property="og:type" content="article">
<meta property="og:title" content="IMX6ULL外部中断配置">
<meta property="og:url" content="http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/index.html">
<meta property="og:site_name" content="Aki&#39;s Blog">
<meta property="og:description" content="Cortex-A7中断系统  中断向量表 Cortex-A7的中断向量表共有8个异常中断，其中一个未使用，有效中断为7个：    向量地址 中断类型 中断模式     0X00 复位中断(Rest) 特权模式(SVC)   0X04 未定义指令中断(Undefined Instruction) 未定义指令中止模式(Undef)   0X08 软中断(Software Interrupt,SWI)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://akichen891.github.io/images/linux/GIC_1.png">
<meta property="og:image" content="http://akichen891.github.io/images/linux/GIC_2.png">
<meta property="og:image" content="http://akichen891.github.io/images/linux/GIC_3.png">
<meta property="article:published_time" content="2025-03-04T04:51:55.000Z">
<meta property="article:modified_time" content="2025-03-05T13:25:35.204Z">
<meta property="article:author" content="Aki">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://akichen891.github.io/images/linux/GIC_1.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>IMX6ULL外部中断配置</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2025/03/05/DDR3%E9%85%8D%E7%BD%AE/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2025/03/03/%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&text=IMX6ULL外部中断配置"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&title=IMX6ULL外部中断配置"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&is_video=false&description=IMX6ULL外部中断配置"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=IMX6ULL外部中断配置&body=Check out this article: http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&title=IMX6ULL外部中断配置"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&title=IMX6ULL外部中断配置"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&title=IMX6ULL外部中断配置"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&title=IMX6ULL外部中断配置"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&name=IMX6ULL外部中断配置&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&t=IMX6ULL外部中断配置"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#cortex-a7%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text"> Cortex-A7中断系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text"> 中断向量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6starts"><span class="toc-number">1.2.</span> <span class="toc-text"> 汇编代码(启动文件start.S)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8-2"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 中断向量表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gic%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text"> GIC控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%ADid"><span class="toc-number">1.4.</span> <span class="toc-text"> 中断ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gic%E9%80%BB%E8%BE%91%E5%88%86%E5%9D%97"><span class="toc-number">1.5.</span> <span class="toc-text"> GIC逻辑分块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cp15%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text"> CP15协处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BD%BF%E8%83%BD"><span class="toc-number">1.7.</span> <span class="toc-text"> 中断使能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#irq%E5%92%8Cfiq%E6%80%BB%E4%B8%AD%E6%96%AD%E4%BD%BF%E8%83%BD"><span class="toc-number">1.7.1.</span> <span class="toc-text"> IRQ和FIQ总中断使能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#id0-id1019-%E4%B8%AD%E6%96%AD%E4%BD%BF%E8%83%BD%E5%92%8C%E7%A6%81%E6%AD%A2"><span class="toc-number">1.7.2.</span> <span class="toc-text"> ID0 - ID1019 中断使能和禁止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.8.</span> <span class="toc-text"> 中断优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E6%95%B0%E9%87%8F%E9%85%8D%E7%BD%AE"><span class="toc-number">1.8.1.</span> <span class="toc-text"> 优先级数量配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E5%AD%90%E4%BC%98%E5%85%88%E7%BA%A7%E4%BD%8D%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">1.8.2.</span> <span class="toc-text"> 抢占优先级和子优先级位数配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.8.3.</span> <span class="toc-text"> 优先级设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.</span> <span class="toc-text"> 复位中断服务函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%B8%AD%E6%96%AD"><span class="toc-number">1.10.</span> <span class="toc-text"> 其他中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#irq%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.</span> <span class="toc-text"> IRQ中断服务函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%87%E4%BB%B6c%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.</span> <span class="toc-text"> 中断驱动文件（C函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.13.</span> <span class="toc-text"> 中断处理全流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8C%89%E9%94%AE%E6%B6%88%E6%8A%96"><span class="toc-number">2.</span> <span class="toc-text"> 示例（定时器按键消抖）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text"> 按键初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text"> 定时器初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpio-isr%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text"> GPIO ISR函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8-isr%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text"> 定时器 ISR函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text"> 辅助函数</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        IMX6ULL外部中断配置
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Aki</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-03-04T04:51:55.000Z" class="dt-published" itemprop="datePublished">2025-03-04</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F-Linux%E5%BC%80%E5%8F%91/">嵌入式(Linux开发)</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="cortex-a7中断系统"><a class="markdownIt-Anchor" href="#cortex-a7中断系统"></a> Cortex-A7中断系统</h2>
<h3 id="中断向量表"><a class="markdownIt-Anchor" href="#中断向量表"></a> 中断向量表</h3>
<p>Cortex-A7的中断向量表共有8个异常中断，其中一个未使用，有效中断为7个：</p>
<table>
<thead>
<tr>
<th>向量地址</th>
<th>中断类型</th>
<th>中断模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>0X00</td>
<td>复位中断(Rest)</td>
<td>特权模式(SVC)</td>
</tr>
<tr>
<td>0X04</td>
<td>未定义指令中断(Undefined Instruction)</td>
<td>未定义指令中止模式(Undef)</td>
</tr>
<tr>
<td>0X08</td>
<td>软中断(Software Interrupt,SWI)</td>
<td>特权模式(SVC)</td>
</tr>
<tr>
<td>0X0C</td>
<td>指令预取中止中断(Prefetch Abort)</td>
<td>中止模式</td>
</tr>
<tr>
<td>0X10</td>
<td>数据访问中止中断(Data Abort)</td>
<td>中止模式</td>
</tr>
<tr>
<td>0X14</td>
<td>未使用(Not Used)</td>
<td>未使用</td>
</tr>
<tr>
<td>0X18</td>
<td>IRQ 中断(IRQ Interrupt)</td>
<td>外部中断模式(IRQ)</td>
</tr>
<tr>
<td>0X1C</td>
<td>FIQ 中断(FIQ Interrupt)</td>
<td>快速中断模式(FIQ)</td>
</tr>
</tbody>
</table>
<p>不同于Cortex-M在中断向量表中列出了所有的中断向量，Cortex-A将所有属于内核CPU的外部中断放在0x18的IRQ中断中，任意外部中断都会触发IRQ中断，然后在IRQ中断中通过读取寄存器的方式来判断具体的中断类型，然后做出相应处理。</p>
<h3 id="汇编代码启动文件starts"><a class="markdownIt-Anchor" href="#汇编代码启动文件starts"></a> 汇编代码(启动文件<code>start.S</code>)</h3>
<h4 id="中断向量表-2"><a class="markdownIt-Anchor" href="#中断向量表-2"></a> 中断向量表</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.global _start  				/* 全局标号 */</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	ldr pc, =Reset_Handler		/* 复位中断 					*/	</span><br><span class="line">	ldr pc, =Undefined_Handler	/* 未定义中断 					*/</span><br><span class="line">	ldr pc, =SVC_Handler		/* SVC(Supervisor)中断 		*/</span><br><span class="line">	ldr pc, =PrefAbort_Handler	/* 预取终止中断 					*/</span><br><span class="line">	ldr pc, =DataAbort_Handler	/* 数据终止中断 					*/</span><br><span class="line">	ldr	pc, =NotUsed_Handler	/* 未使用中断					*/</span><br><span class="line">	ldr pc, =IRQ_Handler		/* IRQ中断 					*/</span><br><span class="line">	ldr pc, =FIQ_Handler		/* FIQ(快速中断)未定义中断 			*/</span><br></pre></td></tr></table></figure>
<p>指定中断发生后调用对应的中断复位函数。<code>pc</code>为程序计数器，用来指出下一条指令在主存储器中的地址。中断发生后，主程序的下一条指令地址会自动更新为中断服务函数的地址。</p>
<h3 id="gic控制器"><a class="markdownIt-Anchor" href="#gic控制器"></a> GIC控制器</h3>
<p><img src="/images/linux/GIC_1.png" alt="GIC v2框图"></p>
<p>类似于STM32的NVIC，Cortex-A的中断控制器名字叫GIC，GIC负责处理输入的所有中断，然后生成一个IRQ信号上报给ARM内核。GIC将众多的中断源分为三类：</p>
<ul>
<li>SPI，共享中断，常见外部中断均属于SPI中断</li>
<li>PPI，私有中断，指定核心处理</li>
<li>SGI，软件中断，通过向寄存器<code>GICR_SGIR</code>写入数据触发，常用于多核通信</li>
</ul>
<h3 id="中断id"><a class="markdownIt-Anchor" href="#中断id"></a> 中断ID</h3>
<p>I.MX6UL的1020个中断ID分配如下：</p>
<ul>
<li>ID0 - ID15：分配至SGI</li>
<li>ID16 - ID31：分配至PPI</li>
<li>ID32 - ID1019：分配至SPI</li>
</ul>
<p>I.MX6U的中断源由官方SDK在<code>MCIMX6Y2.h</code>中给出，共有160个，每个中断源有独属的中断ID。</p>
<h3 id="gic逻辑分块"><a class="markdownIt-Anchor" href="#gic逻辑分块"></a> GIC逻辑分块</h3>
<p>GIC架构分为两个逻辑块：</p>
<ul>
<li>Distributor：分发器端，负责处理中断事件分发问题（中断事件该发送到哪个CPU Interface上去）。分发器收集所有的中断源，可控制每个中断的优先级，具体功能有：
<ol>
<li>全局中断使能控制</li>
<li>控制每个中断的使能或关闭</li>
<li>设置中断优先级</li>
<li>设置每个中断的目标处理器列表</li>
<li>设置每个外部中断的触发模式：电平触发或边沿触发</li>
<li>设置每个中断属于组 0 还是组 1</li>
</ol>
</li>
<li>CPU Interface：CPU接口端，具体功能有：
<ol>
<li>使能或者关闭发送到 CPU Core 的中断请求信号</li>
<li>应答中断</li>
<li>通知中断处理完成</li>
<li>设置优先级掩码，通过掩码来设置哪些中断不需要上报给 CPU Core</li>
<li>定义抢占策略</li>
<li>当多个中断到来的时候，选择优先级最高的中断通知给 CPU Core</li>
</ol>
</li>
</ul>
<p>GIC控制器的所有寄存器在<code>core_ca7.h</code>中声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * GIC寄存器描述结构体，</span><br><span class="line"> * GIC分为分发器端和CPU接口端</span><br><span class="line"> */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">        uint32_t RESERVED0[1024];</span><br><span class="line">  __IOM uint32_t D_CTLR;                 /*!&lt; Offset: 0x1000 (R/W) Distributor Control Register */</span><br><span class="line">  __IM  uint32_t D_TYPER;                /*!&lt; Offset: 0x1004 (R/ )  Interrupt Controller Type Register */</span><br><span class="line">  __IM  uint32_t D_IIDR;                 /*!&lt; Offset: 0x1008 (R/ )  Distributor Implementer Identification Register */</span><br><span class="line">        uint32_t RESERVED1[29];</span><br><span class="line">  __IOM uint32_t D_IGROUPR[16];          /*!&lt; Offset: 0x1080 - 0x0BC (R/W) Interrupt Group Registers */</span><br><span class="line">        uint32_t RESERVED2[16];</span><br><span class="line">  __IOM uint32_t D_ISENABLER[16];        /*!&lt; Offset: 0x1100 - 0x13C (R/W) Interrupt Set-Enable Registers */</span><br><span class="line">        uint32_t RESERVED3[16];</span><br><span class="line">  __IOM uint32_t D_ICENABLER[16];        /*!&lt; Offset: 0x1180 - 0x1BC (R/W) Interrupt Clear-Enable Registers */</span><br><span class="line">        uint32_t RESERVED4[16];</span><br><span class="line">  __IOM uint32_t D_ISPENDR[16];          /*!&lt; Offset: 0x1200 - 0x23C (R/W) Interrupt Set-Pending Registers */</span><br><span class="line">        uint32_t RESERVED5[16];</span><br><span class="line">  __IOM uint32_t D_ICPENDR[16];          /*!&lt; Offset: 0x1280 - 0x2BC (R/W) Interrupt Clear-Pending Registers */</span><br><span class="line">        uint32_t RESERVED6[16];</span><br><span class="line">  __IOM uint32_t D_ISACTIVER[16];        /*!&lt; Offset: 0x1300 - 0x33C (R/W) Interrupt Set-Active Registers */</span><br><span class="line">        uint32_t RESERVED7[16];</span><br><span class="line">  __IOM uint32_t D_ICACTIVER[16];        /*!&lt; Offset: 0x1380 - 0x3BC (R/W) Interrupt Clear-Active Registers */</span><br><span class="line">        uint32_t RESERVED8[16];</span><br><span class="line">  __IOM uint8_t  D_IPRIORITYR[512];      /*!&lt; Offset: 0x1400 - 0x5FC (R/W) Interrupt Priority Registers */</span><br><span class="line">        uint32_t RESERVED9[128];</span><br><span class="line">  __IOM uint8_t  D_ITARGETSR[512];       /*!&lt; Offset: 0x1800 - 0x9FC (R/W) Interrupt Targets Registers */</span><br><span class="line">        uint32_t RESERVED10[128];</span><br><span class="line">  __IOM uint32_t D_ICFGR[32];            /*!&lt; Offset: 0x1C00 - 0xC7C (R/W) Interrupt configuration registers */</span><br><span class="line">        uint32_t RESERVED11[32];</span><br><span class="line">  __IM  uint32_t D_PPISR;                /*!&lt; Offset: 0x1D00 (R/ ) Private Peripheral Interrupt Status Register */</span><br><span class="line">  __IM  uint32_t D_SPISR[15];            /*!&lt; Offset: 0x1D04 - 0xD3C (R/ ) Shared Peripheral Interrupt Status Registers */</span><br><span class="line">        uint32_t RESERVED12[112];</span><br><span class="line">  __OM  uint32_t D_SGIR;                 /*!&lt; Offset: 0x1F00 ( /W) Software Generated Interrupt Register */</span><br><span class="line">        uint32_t RESERVED13[3];</span><br><span class="line">  __IOM uint8_t  D_CPENDSGIR[16];        /*!&lt; Offset: 0x1F10 - 0xF1C (R/W) SGI Clear-Pending Registers */</span><br><span class="line">  __IOM uint8_t  D_SPENDSGIR[16];        /*!&lt; Offset: 0x1F20 - 0xF2C (R/W) SGI Set-Pending Registers */</span><br><span class="line">        uint32_t RESERVED14[40];</span><br><span class="line">  __IM  uint32_t D_PIDR4;                /*!&lt; Offset: 0x1FD0 (R/ ) Peripheral ID4 Register */</span><br><span class="line">  __IM  uint32_t D_PIDR5;                /*!&lt; Offset: 0x1FD4 (R/ ) Peripheral ID5 Register */</span><br><span class="line">  __IM  uint32_t D_PIDR6;                /*!&lt; Offset: 0x1FD8 (R/ ) Peripheral ID6 Register */</span><br><span class="line">  __IM  uint32_t D_PIDR7;                /*!&lt; Offset: 0x1FDC (R/ ) Peripheral ID7 Register */</span><br><span class="line">  __IM  uint32_t D_PIDR0;                /*!&lt; Offset: 0x1FE0 (R/ ) Peripheral ID0 Register */</span><br><span class="line">  __IM  uint32_t D_PIDR1;                /*!&lt; Offset: 0x1FE4 (R/ ) Peripheral ID1 Register */</span><br><span class="line">  __IM  uint32_t D_PIDR2;                /*!&lt; Offset: 0x1FE8 (R/ ) Peripheral ID2 Register */</span><br><span class="line">  __IM  uint32_t D_PIDR3;                /*!&lt; Offset: 0x1FEC (R/ ) Peripheral ID3 Register */</span><br><span class="line">  __IM  uint32_t D_CIDR0;                /*!&lt; Offset: 0x1FF0 (R/ ) Component ID0 Register */</span><br><span class="line">  __IM  uint32_t D_CIDR1;                /*!&lt; Offset: 0x1FF4 (R/ ) Component ID1 Register */</span><br><span class="line">  __IM  uint32_t D_CIDR2;                /*!&lt; Offset: 0x1FF8 (R/ ) Component ID2 Register */</span><br><span class="line">  __IM  uint32_t D_CIDR3;                /*!&lt; Offset: 0x1FFC (R/ ) Component ID3 Register */</span><br><span class="line"></span><br><span class="line">  __IOM uint32_t C_CTLR;                 /*!&lt; Offset: 0x2000 (R/W) CPU Interface Control Register */</span><br><span class="line">  __IOM uint32_t C_PMR;                  /*!&lt; Offset: 0x2004 (R/W) Interrupt Priority Mask Register */</span><br><span class="line">  __IOM uint32_t C_BPR;                  /*!&lt; Offset: 0x2008 (R/W) Binary Point Register */</span><br><span class="line">  __IM  uint32_t C_IAR;                  /*!&lt; Offset: 0x200C (R/ ) Interrupt Acknowledge Register */</span><br><span class="line">  __OM  uint32_t C_EOIR;                 /*!&lt; Offset: 0x2010 ( /W) End Of Interrupt Register */</span><br><span class="line">  __IM  uint32_t C_RPR;                  /*!&lt; Offset: 0x2014 (R/ ) Running Priority Register */</span><br><span class="line">  __IM  uint32_t C_HPPIR;                /*!&lt; Offset: 0x2018 (R/ ) Highest Priority Pending Interrupt Register */</span><br><span class="line">  __IOM uint32_t C_ABPR;                 /*!&lt; Offset: 0x201C (R/W) Aliased Binary Point Register */</span><br><span class="line">  __IM  uint32_t C_AIAR;                 /*!&lt; Offset: 0x2020 (R/ ) Aliased Interrupt Acknowledge Register */</span><br><span class="line">  __OM  uint32_t C_AEOIR;                /*!&lt; Offset: 0x2024 ( /W) Aliased End Of Interrupt Register */</span><br><span class="line">  __IM  uint32_t C_AHPPIR;               /*!&lt; Offset: 0x2028 (R/ ) Aliased Highest Priority Pending Interrupt Register */</span><br><span class="line">        uint32_t RESERVED15[41];</span><br><span class="line">  __IOM uint32_t C_APR0;                 /*!&lt; Offset: 0x20D0 (R/W) Active Priority Register */</span><br><span class="line">        uint32_t RESERVED16[3];</span><br><span class="line">  __IOM uint32_t C_NSAPR0;               /*!&lt; Offset: 0x20E0 (R/W) Non-secure Active Priority Register */</span><br><span class="line">        uint32_t RESERVED17[6];</span><br><span class="line">  __IM  uint32_t C_IIDR;                 /*!&lt; Offset: 0x20FC (R/ ) CPU Interface Identification Register */</span><br><span class="line">        uint32_t RESERVED18[960];</span><br><span class="line">  __OM  uint32_t C_DIR;                  /*!&lt; Offset: 0x3000 ( /W) Deactivate Interrupt Register */</span><br><span class="line">&#125; GIC_Type;</span><br></pre></td></tr></table></figure>
<p>不过，这里只给出了GIC各寄存器的偏移地址，基地址需要通过CP15协处理器获取。</p>
<h3 id="cp15协处理器"><a class="markdownIt-Anchor" href="#cp15协处理器"></a> CP15协处理器</h3>
<p>CP15协处理器共有16个32位寄存器。对CP15协处理器的访问可通过下列指令完成：</p>
<ul>
<li><strong>MRC</strong>：将CP15的寄存器数据读取到ARM寄存器中</li>
<li><strong>MCR</strong>：将ARM寄存器数据写入到CP15寄存器中。格式：<code>MCR&#123;cond&#125; p15, &lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;, &lt;opc2&gt;</code>
<ul>
<li>cond：指令执行的条件码。若忽略，表示无条件执行</li>
<li>opc1：CP15要执行的操作码</li>
<li>Rt：ARM源寄存器</li>
<li>CRn：CP15的目标寄存器</li>
<li>CRm：CP15中附加的目标寄存器或源操作数寄存器。如不需要附加信息，该位应设置为<code>c0</code></li>
<li>opc2：可选的CP15特定操作码，不需要时设置为0</li>
</ul>
</li>
</ul>
<p>CP15的16个寄存器在被MRC和MCR指令访问时，指令中的参数搭配若不同，得到的寄存器含义也不同。以c0寄存器为例：</p>
<p><img src="/images/linux/GIC_2.png" alt="CP15 c0寄存器参数搭配"></p>
<p>例如，当<code>opc1 = 0</code>, <code>CRm = c0</code>, <code>opc2 = 0</code>时，此时c0是MIDR寄存器，即主ID寄存器，包含厂商编号、主版本号、架构代码等信息。</p>
<p>对于c15寄存器:<br>
<img src="/images/linux/GIC_3.png" alt="CP15 c15寄存器参数搭配"></p>
<p>可见GIC基地址保存在CBAR中，因此可通过<code>MRC p15, 4, r1, c15, c0, 0</code>指令获取GIC基地址至r1中。现在就可以设置GIC的寄存器了，比如：读取当前中断ID，将ID保存在<code>GICC_IAR</code>中，SDK中已经给出<code>GICC_IAR</code>的偏移地址<code>__IM  uint32_t C_IAR;                  /*!&lt; Offset: 0x200C (R/ ) Interrupt Acknowledge Register */</code>为<code>0x200C</code>，因此获取当前中断ID的汇编代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MRC p15, 5, r1, c15, c0 ,0  ;获取GIC基地址</span><br><span class="line">ADD r1, r1, #0x2000         ;基地址+0x2000得到CPU接口端寄存器起始地址</span><br><span class="line">LDR r0, [r1, #0xC]          ;读取GIC_IAR的值</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>c0寄存器可获取到处理器内核信息</li>
<li>c1寄存器可使能或禁止MMU、I/D Cache</li>
<li>c12寄存器可设置中断向量偏移</li>
<li>c15可获取GIC基地址</li>
</ul>
<h3 id="中断使能"><a class="markdownIt-Anchor" href="#中断使能"></a> 中断使能</h3>
<h4 id="irq和fiq总中断使能"><a class="markdownIt-Anchor" href="#irq和fiq总中断使能"></a> IRQ和FIQ总中断使能</h4>
<p>汇编下支持以下快捷指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cpsid i</td>
<td>禁止IRQ中断</td>
</tr>
<tr>
<td>cpsie i</td>
<td>使能IRQ中断</td>
</tr>
<tr>
<td>cpsid f</td>
<td>禁止FIQ中断</td>
</tr>
<tr>
<td>cpsie f</td>
<td>使能FIQ中断</td>
</tr>
</tbody>
</table>
<h4 id="id0-id1019-中断使能和禁止"><a class="markdownIt-Anchor" href="#id0-id1019-中断使能和禁止"></a> ID0 - ID1019 中断使能和禁止</h4>
<p>由以下寄存器完成：</p>
<ul>
<li><code>GICD_ISENABLERn</code>：<code>GICD_ISENABLER0</code>的bit[15:0]对应ID15 - 0的SGI中断，bit[31:16]对应ID31 - 16的PPI中断</li>
<li><code>GICD_ICENABLERn</code>：<code>GICD_ISENABLER1</code> - <code>GICD_ISENABLER15</code>控制SPI中断</li>
</ul>
<h3 id="中断优先级"><a class="markdownIt-Anchor" href="#中断优先级"></a> 中断优先级</h3>
<h4 id="优先级数量配置"><a class="markdownIt-Anchor" href="#优先级数量配置"></a> 优先级数量配置</h4>
<p><code>GICC_PMR</code>寄存器用于配置优先级数量，寄存器低8位有效。I.MX6U是Cortex-A7内核，支持32个优先级，因此<code>GICC_PMR</code>设置为<code>0b11111000</code>.</p>
<h4 id="抢占优先级和子优先级位数配置"><a class="markdownIt-Anchor" href="#抢占优先级和子优先级位数配置"></a> 抢占优先级和子优先级位数配置</h4>
<p>抢占优先级和子优先级各占多少位由寄存器<code>GICC_BPR</code>决定，低3位有效，配置如下所示：</p>
<table>
<thead>
<tr>
<th>Binary Point</th>
<th>抢占优先级域</th>
<th>子优先级域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>[7:1]</td>
<td>[0]</td>
<td>7 级抢占优先级，1 级子优先级。</td>
</tr>
<tr>
<td>1</td>
<td>[7:2]</td>
<td>[1:0]</td>
<td>6 级抢占优先级，2 级子优先级。</td>
</tr>
<tr>
<td>2</td>
<td>[7:3]</td>
<td>[2:0]</td>
<td>5 级抢占优先级，3 级子优先级。</td>
</tr>
<tr>
<td>3</td>
<td>[7:4]</td>
<td>[3:0]</td>
<td>4 级抢占优先级，4 级子优先级。</td>
</tr>
<tr>
<td>4</td>
<td>[7:5]</td>
<td>[4:0]</td>
<td>3 级抢占优先级，5 级子优先级。</td>
</tr>
<tr>
<td>5</td>
<td>[7:6]</td>
<td>[5:0]</td>
<td>2 级抢占优先级，6 级子优先级。</td>
</tr>
<tr>
<td>6</td>
<td>[7:7]</td>
<td>[6:0]</td>
<td>1 级抢占优先级，7 级子优先级。</td>
</tr>
<tr>
<td>7</td>
<td>无</td>
<td>[7:0]</td>
<td>0 级抢占优先级，8 级子优先级。</td>
</tr>
</tbody>
</table>
<p>一般而言所有的中断优先级位都配置为抢占优先级。如IMX6U的优先级位数为5（32个优先级），可设置Binary point为2，表示5个优先级位全部为抢占优先级。</p>
<h4 id="优先级设置"><a class="markdownIt-Anchor" href="#优先级设置"></a> 优先级设置</h4>
<p>某个中断ID的中断优先级设置由寄存器<code>GICD_IPRIORITYR</code>完成，每个中断ID配有一个该寄存器，共512个。如果优先级个数为32，即使用<code>GICD_IPRIORITYR</code>的bit[7:4]来设置优先级（实际优先级左移3位）。例如，要设置ID == 40中断优先级为5：<code>GICD_IPRIORITYR[40] = 5 &lt;&lt; 3</code></p>
<p>总结一下，中断优先级设置分三部分：</p>
<ol>
<li>设置<code>GICC_PMR</code>，配置优先级个数，IMX6U为32级</li>
<li>设置抢占优先级和子优先级位数，一般默认所有位数都为抢占优先级</li>
<li>设置指定中断ID的优先级</li>
</ol>
<h3 id="复位中断服务函数"><a class="markdownIt-Anchor" href="#复位中断服务函数"></a> 复位中断服务函数</h3>
<p>整个启动文件在设置完中断向量表后，要进行复位中断的设置，其分为以下步骤：</p>
<ol>
<li>设置复位中断：关闭IRQ，然后关闭I/D Cache、MMU、对齐检测和分支预测</li>
<li>进行中断向量表重映射</li>
<li>设置IRQ模式、SYS模式和SVC模式下的栈指针，栈大小均为2MB</li>
<li>打开IRQ中断</li>
<li>跳转至main函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/* 复位中断 */	</span><br><span class="line">Reset_Handler:</span><br><span class="line"></span><br><span class="line">	cpsid i						/* 关闭全局中断 */</span><br><span class="line"></span><br><span class="line">	/* 关闭I,DCache和MMU </span><br><span class="line">	 * 采取读-改-写的方式。</span><br><span class="line">	 */</span><br><span class="line">	mrc     p15, 0, r0, c1, c0, 0     /* 读取CP15的C1寄存器到R0中       		        	*/</span><br><span class="line">    bic     r0,  r0, #(0x1 &lt;&lt; 12)     /* 清除C1寄存器的bit12位(I位)，关闭I Cache            	*/</span><br><span class="line">    bic     r0,  r0, #(0x1 &lt;&lt;  2)     /* 清除C1寄存器的bit2(C位)，关闭D Cache    				*/</span><br><span class="line">    bic     r0,  r0, #0x2             /* 清除C1寄存器的bit1(A位)，关闭对齐						*/</span><br><span class="line">    bic     r0,  r0, #(0x1 &lt;&lt; 11)     /* 清除C1寄存器的bit11(Z位)，关闭分支预测					*/</span><br><span class="line">    bic     r0,  r0, #0x1             /* 清除C1寄存器的bit0(M位)，关闭MMU				       	*/</span><br><span class="line">    mcr     p15, 0, r0, c1, c0, 0     /* 将r0寄存器中的值写入到CP15的C1寄存器中	 				*/</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">	/* 汇编版本设置中断向量表偏移 */</span><br><span class="line">	ldr r0, =0X87800000</span><br><span class="line"></span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line">	mcr p15, 0, r0, c12, c0, 0</span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">	/* 设置各个模式下的栈指针，</span><br><span class="line">	 * 注意：IMX6UL的堆栈是向下增长的！</span><br><span class="line">	 * 堆栈指针地址一定要是4字节地址对齐的！！！</span><br><span class="line">	 * DDR范围:0X80000000~0X9FFFFFFF</span><br><span class="line">	 */</span><br><span class="line">	/* 进入IRQ模式 */</span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #0x1f 	/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span><br><span class="line">	orr r0, r0, #0x12 	/* r0或上0x13,表示使用IRQ模式					*/</span><br><span class="line">	msr cpsr, r0		/* 将r0 的数据写入到cpsr_c中 					*/</span><br><span class="line">	ldr sp, =0x80600000	/* 设置IRQ模式下的栈首地址为0X80600000,大小为2MB */</span><br><span class="line"></span><br><span class="line">	/* 进入SYS模式 */</span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #0x1f 	/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span><br><span class="line">	orr r0, r0, #0x1f 	/* r0或上0x13,表示使用SYS模式					*/</span><br><span class="line">	msr cpsr, r0		/* 将r0 的数据写入到cpsr_c中 					*/</span><br><span class="line">	ldr sp, =0x80400000	/* 设置SYS模式下的栈首地址为0X80400000,大小为2MB */</span><br><span class="line"></span><br><span class="line">	/* 进入SVC模式 */</span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #0x1f 	/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span><br><span class="line">	orr r0, r0, #0x13 	/* r0或上0x13,表示使用SVC模式					*/</span><br><span class="line">	msr cpsr, r0		/* 将r0 的数据写入到cpsr_c中 					*/</span><br><span class="line">	ldr sp, =0X80200000	/* 设置SVC模式下的栈首地址为0X80200000,大小为2MB */</span><br><span class="line"></span><br><span class="line">	cpsie i				/* 打开全局中断 */</span><br><span class="line">#if 0</span><br><span class="line">	/* 使能IRQ中断 */</span><br><span class="line">	mrs r0, cpsr		/* 读取cpsr寄存器值到r0中 			*/</span><br><span class="line">	bic r0, r0, #0x80	/* 将r0寄存器中bit7清零，也就是CPSR中的I位清零，表示允许IRQ中断 */</span><br><span class="line">	msr cpsr, r0		/* 将r0重新写入到cpsr中 			*/</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	b main				/* 跳转到main函数 			 	*/</span><br></pre></td></tr></table></figure>
<h3 id="其他中断"><a class="markdownIt-Anchor" href="#其他中断"></a> 其他中断</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* 未定义中断 */</span><br><span class="line">Undefined_Handler:</span><br><span class="line">	ldr r0, =Undefined_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line">/* SVC中断 */</span><br><span class="line">SVC_Handler:</span><br><span class="line">	ldr r0, =SVC_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line">/* 预取终止中断 */</span><br><span class="line">PrefAbort_Handler:</span><br><span class="line">	ldr r0, =PrefAbort_Handler	</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line">/* 数据终止中断 */</span><br><span class="line">DataAbort_Handler:</span><br><span class="line">	ldr r0, =DataAbort_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line">/* 未使用的中断 */</span><br><span class="line">NotUsed_Handler:</span><br><span class="line"></span><br><span class="line">	ldr r0, =NotUsed_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line">    /* FIQ中断 */</span><br><span class="line">FIQ_Handler:</span><br><span class="line"></span><br><span class="line">	ldr r0, =FIQ_Handler	</span><br><span class="line">	bx r0	</span><br></pre></td></tr></table></figure>
<h3 id="irq中断服务函数"><a class="markdownIt-Anchor" href="#irq中断服务函数"></a> IRQ中断服务函数</h3>
<p>所有的外部中断都会触发IRQ中断，因此IRQ中断服务函数的工作就是获取当前发生的中断ID以确定中断来源，然后根据不同的外部中断来进行不同的处理。这里会涉及到几个ARM中常用的寄存器：</p>
<ul>
<li>IP寄存器：内部程序调用暂存寄存器，子程序的连接text段中常使用该规则</li>
<li>SP寄存器：栈指针寄存器，用于存储当前栈顶地址。程序执行过程中，栈是用来存储临时变量、函数调用返回地址等数据的重要数据结构，SP寄存器的值会随着栈的变化而变化</li>
<li>LR寄存器：连接寄存器，程序跳转（子程序调用，中断跳转）后，arm自动在该寄存器中存入原程序（未跳转）的下一条指令的地址，也叫函数调用返回地址。当一个函数被调用时，LR寄存器会存储调用该函数的下一条指令的地址，当函数执行完毕后，程序会跳转到LR寄存器中存储的地址继续执行。</li>
<li>PC寄存器：程序计数器，保存的是当前正在取指的指令的地址（arm采用2级流水线，因此是当前正在执行指令的地址+8）。PC寄存器是ARM中的程序计数器，用于存储下一条将要执行的指令的地址。</li>
</ul>
<p>此外，还有两个比较重要的状态寄存器：</p>
<ul>
<li>CPSR：程序状态寄存器，在任何处理器模式下被访问。它包含了条件标志位、中断禁止位、当前处理器模式标志以及其他的一些控制和状态位。CPSR在用户级编程时用于存储条件码。</li>
<li>SPSR：程序状态保存寄存器，每一种处理器模式下都有一个状态寄存器SPSR,SPSR用于保存CPSR的状态，以便异常返回后恢复异常发生时的工作状态。当特定的异常中断发生时，这个寄存器用于存放当前程序状态寄存器的内容。在异常中断退出时，可以用SPSR来恢复CPSR。由于用户模式和系统模式不是异常中断模式，所以他没有SPSR。当用户在用户模式或系统模式访问SPSR，将产生不可预知的后果。</li>
</ul>
<p>二者常用于MRS或MSR指令,用于spsr中的值转移到寄存器或把寄存器的内容加载到spsr中，如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mrs r0, spsr                /* 读取spsr寄存器 */</span><br><span class="line">msr spsr_cxsf, r0            /* 恢复spsr */</span><br></pre></td></tr></table></figure>
<p>IRQ中断服务函数的编写大致分为以下步骤：</p>
<ol>
<li>进入IRQ模式，保存上下文。ARM在进入IRQ模式会自动切换LR和SPSR，但不会自动保存其他寄存器，因此需手动保存r0-r3和r12寄存器（后续操作可能修改）。自动切换时，LR保存被中断指令的下一条指令<code>-4</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* IRQ中断 */</span><br><span class="line">IRQ_Handler:</span><br><span class="line">	push &#123;lr&#125;					/* 保存lr地址 */</span><br><span class="line">	push &#123;r0-r3, r12&#125;			/* 保存r0-r3，r12寄存器 */</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>保存现场。SPSR存储被中断前CPU的模式状态，必须保存SPSR以正确恢复中断前的执行环境。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mrs r0, spsr				/* 读取spsr寄存器 */</span><br><span class="line">push &#123;r0&#125;					/* 保存spsr寄存器 */</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>获取GIC中断号。通过MRC向cp15读取寄存器以获取GIC基址，从而计算GICC_IAR地址并读取，读取后自动标记该中断为active状态，获取到的中断号<code>r0</code>作为参数传递给C语言ISR。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mrc p15, 4, r1, c15, c0, 0 /* 读取CP15的C0寄存器内的值到R1寄存器中</span><br><span class="line">							* 参考文档ARM Cortex-A(armV7)编程手册V4.0.pdf P49</span><br><span class="line">							* Cortex-A7 Technical ReferenceManua.pdf P68 P138</span><br><span class="line">							*/							</span><br><span class="line">add r1, r1, #0X2000			/* GIC基地址加0X2000，也就是GIC的CPU接口端基地址 */</span><br><span class="line">ldr r0, [r1, #0XC]			/* GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，</span><br><span class="line">							 * GICC_IAR寄存器保存这当前发生中断的中断号，我们要根据</span><br><span class="line">							 * 这个中断号来绝对调用哪个中断服务函数</span><br><span class="line">							 */</span><br><span class="line">push &#123;r0, r1&#125;				/* 保存r0,r1 */</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>切换至SVC模式并调用C函数。IAR模式栈空间有限，切换至SVC模式（特权模式）以获得更大的栈空间，并允许C函数处理更复杂的逻辑，如中断嵌套。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cps #0x13					/* 进入SVC模式，允许其他中断再次进去 */</span><br><span class="line"></span><br><span class="line">push &#123;lr&#125;					/* 保存SVC模式的lr寄存器 */</span><br><span class="line">ldr r2, =system_irqhandler	/* 加载C语言中断处理函数到r2寄存器中*/</span><br><span class="line">blx r2						/* 运行C语言中断处理函数，带有中断号参数，保存在R0寄存器中 */</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>恢复模式并发送中断结束信号。向向GIC的End of Interrupt Register (GICC_EOIR) 写入中断号，告知中断控制器该中断已处理完毕。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop &#123;lr&#125;					/* 执行完C语言中断服务函数，lr出栈 */</span><br><span class="line">cps #0x12					/* 进入IRQ模式 */</span><br><span class="line">pop &#123;r0, r1&#125;				</span><br><span class="line">str r0, [r1, #0X10]			/* 中断执行完成，写EOIR */</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>恢复中断前状态并返回。</li>
</ol>
<p>这里是一个很容易搞错的点。ARM使用三级流水线机制：取指-&gt;译指-&gt;执行，而我们总以执行位置作为参考点，因此PC永远是当前执行位置<code>+8</code>；LR存放函数调用结束后返回继续执行的地址，也就是当前执行指令的下一条(<code>+4</code>)。进入IRQ中断时，中断总是在执行一条指令后再进入，此时PC更新为<code>+12</code>，相应的LR变为<code>+8</code>，然后LR被入栈保存。如果中断结束后，直接将LR出栈，程序会从<code>+8</code>处开始运行，那么<code>+4</code>处的指令就直接被跳过了。因此，中断结束后将LR出栈时，要将LR<code>-4</code>。</p>
<p>用表格可以解释为：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>状态A：中断前</th>
<th>状态B：进入中断后</th>
<th>状态C：中断恢复</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>MOV R1, R0</td>
<td>准备执行</td>
<td>已执行</td>
<td></td>
</tr>
<tr>
<td>0x04</td>
<td>MOV R2, R1</td>
<td>LR</td>
<td></td>
<td>LR（恢复为状态A时的PC值-4）</td>
</tr>
<tr>
<td>0x08</td>
<td>MOV R3, R2</td>
<td>PC</td>
<td>LR（已入栈）</td>
<td></td>
</tr>
<tr>
<td>0x0c</td>
<td>MOV R4 ,R3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>PC值</td>
<td>0x08</td>
<td>0x12</td>
<td>由LR值决定</td>
</tr>
<tr>
<td></td>
<td>LR值</td>
<td>0x04</td>
<td>0x08</td>
<td>0x04</td>
</tr>
</tbody>
</table>
<p>再通俗一点：PC始终指向当前执行指令+8，发生中断时，入栈保存的LR实际上是PC的地址，如果返回时将LR直接赋给PC，中间就跳过了一个指令，因此LR出栈后要<code>-4</code>才能赋给PC。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pop &#123;r0&#125;						</span><br><span class="line">msr spsr_cxsf, r0			/* 恢复spsr */</span><br><span class="line"></span><br><span class="line">pop &#123;r0-r3, r12&#125;			/* r0-r3,r12出栈 */</span><br><span class="line">pop &#123;lr&#125;					/* lr出栈 */</span><br><span class="line">subs pc, lr, #4				/* 将计算后的地址（lr-4）赋给pc */	</span><br></pre></td></tr></table></figure>
<h3 id="中断驱动文件c函数"><a class="markdownIt-Anchor" href="#中断驱动文件c函数"></a> 中断驱动文件（C函数）</h3>
<ol>
<li>中断初始化函数。向量表基地址设置为程序存放开始地址。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void int_init(void) &#123;</span><br><span class="line">    GIC_Init();                        // 初始化通用中断控制器，该函数由SDK提供</span><br><span class="line">    system_irqtable_init();            // 初始化中断函数表</span><br><span class="line">    __set_VBAR((uint32_t)0x87800000);  // 设置向量表基地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>中断向量表初始化。将所有中断初始化为default_irqhandler（死循环），强制开发者显式注册有效ISR，避免未处理中断导致不可控行为。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void system_irqtable_init(void) &#123;</span><br><span class="line">    unsigned int i = 0;</span><br><span class="line">    irqNesting = 0;  // 重置嵌套计数器</span><br><span class="line">    </span><br><span class="line">    for(i = 0; i &lt; NUMBER_OF_INT_VECTORS; i++) &#123;</span><br><span class="line">        system_register_irqhandler((IRQn_Type)i, default_irqhandler, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>中断注册函数。用于绑定中断服务函数和中断源。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void system_register_irqhandler(IRQn_Type irq, system_irq_handler_t handler, void *userParam) &#123;</span><br><span class="line">    irqTable[irq].irqHandler = handler;   // 注册处理函数</span><br><span class="line">    irqTable[irq].userParam = userParam;  // 绑定用户参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>中断分发器。默认允许中断嵌套。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void system_irqhandler(unsigned int giccIar) &#123;</span><br><span class="line">    uint32_t intNum = giccIar &amp; 0x3FFUL;  // 提取中断号</span><br><span class="line">    </span><br><span class="line">    /* 校验中断号有效性 */</span><br><span class="line">    if ((intNum == 1023) || (intNum &gt;= NUMBER_OF_INT_VECTORS)) &#123;</span><br><span class="line">        return;  // 非法中断号（1023伪中断或中断号不在表内）直接返回</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    irqNesting++;  // 嵌套计数增加</span><br><span class="line">    </span><br><span class="line">    /* 调用注册的ISR */</span><br><span class="line">    irqTable[intNum].irqHandler(intNum, irqTable[intNum].userParam);</span><br><span class="line"> </span><br><span class="line">    irqNesting--;  // 嵌套计数减少</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中断处理全流程"><a class="markdownIt-Anchor" href="#中断处理全流程"></a> 中断处理全流程</h3>
<ol>
<li>硬件触发：外设触发中断，GIC将中断请求发送至CPU。</li>
<li>汇编入口：CPU跳转至IRQ_Handler，保存上下文并调用system_irqhandler(giccIar)。</li>
<li>中断分发：
<ul>
<li>解析giccIar获取有效中断号</li>
<li>查表irqTable[intNum]获取处理函数和参数</li>
</ul>
</li>
<li>ISR执行：执行用户注册的函数（如uart_isr），处理具体中断任务。</li>
<li>中断结束：汇编代码写GICC_EOIR通知GIC处理完成。</li>
</ol>
<h2 id="示例定时器按键消抖"><a class="markdownIt-Anchor" href="#示例定时器按键消抖"></a> 示例（定时器按键消抖）</h2>
<p>实现功能：</p>
<ol>
<li>按下按键，进入外部中断，在中断中开启定时器</li>
<li>定时器中断中完成消抖延时，中断周期即为延时时间。如果定时中断触发，表示消抖完成，执行按键处理函数</li>
</ol>
<h3 id="按键初始化"><a class="markdownIt-Anchor" href="#按键初始化"></a> 按键初始化</h3>
<ol>
<li>设置GPIO复用和Config</li>
<li>填充gpio结构体，初始化gpio</li>
<li>使能中断，注册ISR（绑定中断源和对应的ISR）</li>
<li>初始化定时器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void filterkey_init(void)</span><br><span class="line">&#123;	</span><br><span class="line">	gpio_pin_config_t key_config;</span><br><span class="line">	</span><br><span class="line">	/* 1、初始化IO复用 */</span><br><span class="line">	IOMUXC_SetPinMux(IOMUXC_UART1_CTS_B_GPIO1_IO18,0);	/* 复用为GPIO1_IO18 */</span><br><span class="line"></span><br><span class="line">	/* 2、、配置GPIO1_IO18的IO属性	</span><br><span class="line">	 *bit 16:0 HYS关闭</span><br><span class="line">	 *bit [15:14]: 11 默认22K上拉</span><br><span class="line">	 *bit [13]: 1 pull功能</span><br><span class="line">	 *bit [12]: 1 pull/keeper使能</span><br><span class="line">	 *bit [11]: 0 关闭开路输出</span><br><span class="line">	 *bit [7:6]: 10 速度100Mhz</span><br><span class="line">	 *bit [5:3]: 000 关闭输出</span><br><span class="line">	 *bit [0]: 0 低转换率</span><br><span class="line">	 */</span><br><span class="line">	IOMUXC_SetPinConfig(IOMUXC_UART1_CTS_B_GPIO1_IO18,0xF080);</span><br><span class="line">	</span><br><span class="line">	/* 3、初始化GPIO为中断 */</span><br><span class="line">	key_config.direction = kGPIO_DigitalInput;          /* 输入 */</span><br><span class="line">	key_config.interruptMode = kGPIO_IntFallingEdge;    /* 下降沿触发 */</span><br><span class="line">	key_config.outputLogic = 1;</span><br><span class="line">	gpio_init(GPIO1, 18, &amp;key_config);</span><br><span class="line"></span><br><span class="line">	GIC_EnableIRQ(GPIO1_Combined_16_31_IRQn); /* 使能GIC中对应的中断 */</span><br><span class="line">	</span><br><span class="line">	/* 注册中断服务函数 */</span><br><span class="line">	system_register_irqhandler(GPIO1_Combined_16_31_IRQn, </span><br><span class="line">							   (system_irq_handler_t)gpio1_16_31_irqhandler, </span><br><span class="line">							   NULL);</span><br><span class="line">	</span><br><span class="line">	gpio_enableint(GPIO1, 18);		/* 使能GPIO1_IO18的中断功能 */</span><br><span class="line"></span><br><span class="line">	filtertimer_init(66000000/100);	/* 初始化定时器,10ms */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时器初始化"><a class="markdownIt-Anchor" href="#定时器初始化"></a> 定时器初始化</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void filtertimer_init(unsigned int value)</span><br><span class="line">&#123;</span><br><span class="line">	EPIT1-&gt;CR = 0;	//先清零</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">     * CR寄存器:</span><br><span class="line">     * bit25:24 01 时钟源选择Peripheral clock=66MHz</span><br><span class="line">     * bit15:4  0  1分频</span><br><span class="line">     * bit3:	1  当计数器到0的话从LR重新加载数值</span><br><span class="line">     * bit2:	1  比较中断使能</span><br><span class="line">     * bit1:    1  初始计数值来源于LR寄存器值</span><br><span class="line">     * bit0:    0  先关闭EPIT1</span><br><span class="line">     */</span><br><span class="line">	EPIT1-&gt;CR = (1&lt;&lt;24 | 1&lt;&lt;3 | 1&lt;&lt;2 | 1&lt;&lt;1);</span><br><span class="line"></span><br><span class="line">	/* 计数值 */</span><br><span class="line">	EPIT1-&gt;LR = value;</span><br><span class="line">	</span><br><span class="line">	/* 比较寄存器，当计数器值和此寄存器值相等的话就会产生中断 */</span><br><span class="line">	EPIT1-&gt;CMPR	= 0;	</span><br><span class="line">	</span><br><span class="line">	GIC_EnableIRQ(EPIT1_IRQn);	/* 使能GIC中对应的中断 */</span><br><span class="line">	</span><br><span class="line">	/* 注册中断服务函数		    */</span><br><span class="line">	system_register_irqhandler(EPIT1_IRQn, (system_irq_handler_t)filtertimer_irqhandler, NULL);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gpio-isr函数"><a class="markdownIt-Anchor" href="#gpio-isr函数"></a> GPIO ISR函数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void gpio1_16_31_irqhandler(void)</span><br><span class="line">&#123; </span><br><span class="line">	/* 开启定时器 */</span><br><span class="line">	filtertimer_restart(66000000/100);</span><br><span class="line"></span><br><span class="line">	/* 清除中断标志位 */</span><br><span class="line">	gpio_clearintflags(GPIO1, 18);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时器-isr函数"><a class="markdownIt-Anchor" href="#定时器-isr函数"></a> 定时器 ISR函数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void filtertimer_irqhandler(void)</span><br><span class="line">&#123; </span><br><span class="line">	static unsigned char state = OFF;</span><br><span class="line"></span><br><span class="line">	if(EPIT1-&gt;SR &amp; (1&lt;&lt;0)) 					/* 判断比较事件是否发生			*/</span><br><span class="line">	&#123;</span><br><span class="line">		filtertimer_stop();					/* 关闭定时器 				*/</span><br><span class="line">		if(gpio_pinread(GPIO1, 18) == 0)	/* KEY0 				*/</span><br><span class="line">		&#123;</span><br><span class="line">			state = !state;</span><br><span class="line">			beep_switch(state);				/* 反转蜂鸣器 				*/</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	EPIT1-&gt;SR |= 1&lt;&lt;0; 						/* 清除中断标志位 				*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="辅助函数"><a class="markdownIt-Anchor" href="#辅助函数"></a> 辅助函数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void filtertimer_stop(void)</span><br><span class="line">&#123;</span><br><span class="line">	EPIT1-&gt;CR &amp;= ~(1&lt;&lt;0);	/* 关闭定时器 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void filtertimer_restart(unsigned int value)</span><br><span class="line">&#123;</span><br><span class="line">	EPIT1-&gt;CR &amp;= ~(1&lt;&lt;0);	/* 先关闭定时器 */</span><br><span class="line">	EPIT1-&gt;LR = value;		/* 计数值 			*/</span><br><span class="line">	EPIT1-&gt;CR |= (1&lt;&lt;0);	/* 打开定时器 		*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#cortex-a7%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text"> Cortex-A7中断系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text"> 中断向量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6starts"><span class="toc-number">1.2.</span> <span class="toc-text"> 汇编代码(启动文件start.S)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8-2"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 中断向量表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gic%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text"> GIC控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%ADid"><span class="toc-number">1.4.</span> <span class="toc-text"> 中断ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gic%E9%80%BB%E8%BE%91%E5%88%86%E5%9D%97"><span class="toc-number">1.5.</span> <span class="toc-text"> GIC逻辑分块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cp15%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text"> CP15协处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BD%BF%E8%83%BD"><span class="toc-number">1.7.</span> <span class="toc-text"> 中断使能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#irq%E5%92%8Cfiq%E6%80%BB%E4%B8%AD%E6%96%AD%E4%BD%BF%E8%83%BD"><span class="toc-number">1.7.1.</span> <span class="toc-text"> IRQ和FIQ总中断使能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#id0-id1019-%E4%B8%AD%E6%96%AD%E4%BD%BF%E8%83%BD%E5%92%8C%E7%A6%81%E6%AD%A2"><span class="toc-number">1.7.2.</span> <span class="toc-text"> ID0 - ID1019 中断使能和禁止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.8.</span> <span class="toc-text"> 中断优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E6%95%B0%E9%87%8F%E9%85%8D%E7%BD%AE"><span class="toc-number">1.8.1.</span> <span class="toc-text"> 优先级数量配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E5%AD%90%E4%BC%98%E5%85%88%E7%BA%A7%E4%BD%8D%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">1.8.2.</span> <span class="toc-text"> 抢占优先级和子优先级位数配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.8.3.</span> <span class="toc-text"> 优先级设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.</span> <span class="toc-text"> 复位中断服务函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%B8%AD%E6%96%AD"><span class="toc-number">1.10.</span> <span class="toc-text"> 其他中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#irq%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.</span> <span class="toc-text"> IRQ中断服务函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%87%E4%BB%B6c%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.</span> <span class="toc-text"> 中断驱动文件（C函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.13.</span> <span class="toc-text"> 中断处理全流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8C%89%E9%94%AE%E6%B6%88%E6%8A%96"><span class="toc-number">2.</span> <span class="toc-text"> 示例（定时器按键消抖）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text"> 按键初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text"> 定时器初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpio-isr%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text"> GPIO ISR函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8-isr%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text"> 定时器 ISR函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text"> 辅助函数</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&text=IMX6ULL外部中断配置"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&title=IMX6ULL外部中断配置"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&is_video=false&description=IMX6ULL外部中断配置"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=IMX6ULL外部中断配置&body=Check out this article: http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&title=IMX6ULL外部中断配置"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&title=IMX6ULL外部中断配置"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&title=IMX6ULL外部中断配置"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&title=IMX6ULL外部中断配置"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&name=IMX6ULL外部中断配置&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://akichen891.github.io/2025/03/04/IMX6ULL%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/&t=IMX6ULL外部中断配置"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    Aki
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
