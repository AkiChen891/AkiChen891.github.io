<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="I2C简介 I2C是由数据线SDA和时钟线SCL构成的串行总线，用于发送或接收数据。其中SDA用于传输数据。SCL用于同步时钟信号。I2C还有以下特征：  主从架构  主机（Master）：控制通信过程，生成时钟信号并启动通信 从机（Slave）：响应主机指令，按地址匹配参与通信   地址：每个从设备具有唯一的7位或10位地址，用于识别通信目标。主设备在通信开始时发送从设备地址，从设备响应后开始">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32中的I2C通信【24CXX EEPROM】">
<meta property="og:url" content="http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/index.html">
<meta property="og:site_name" content="Aki&#39;s Blog">
<meta property="og:description" content="I2C简介 I2C是由数据线SDA和时钟线SCL构成的串行总线，用于发送或接收数据。其中SDA用于传输数据。SCL用于同步时钟信号。I2C还有以下特征：  主从架构  主机（Master）：控制通信过程，生成时钟信号并启动通信 从机（Slave）：响应主机指令，按地址匹配参与通信   地址：每个从设备具有唯一的7位或10位地址，用于识别通信目标。主设备在通信开始时发送从设备地址，从设备响应后开始">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://akichen891.github.io/images/arm/i2c1.png">
<meta property="og:image" content="http://akichen891.github.io/images/arm/i2c2.png">
<meta property="og:image" content="http://akichen891.github.io/images/arm/i2c3.png">
<meta property="og:image" content="http://akichen891.github.io/images/arm/24c021.png">
<meta property="og:image" content="http://akichen891.github.io/images/arm/24c022.png">
<meta property="og:image" content="http://akichen891.github.io/images/arm/24c023.png">
<meta property="og:image" content="http://akichen891.github.io/images/arm/24c024.png">
<meta property="og:image" content="http://akichen891.github.io/images/arm/24c025.png">
<meta property="og:image" content="http://akichen891.github.io/images/arm/i2c4.png">
<meta property="og:image" content="http://akichen891.github.io/images/arm/i2c5.png">
<meta property="og:image" content="http://akichen891.github.io/images/arm/24c026.png">
<meta property="article:published_time" content="2024-12-07T12:41:46.000Z">
<meta property="article:modified_time" content="2024-12-13T13:14:16.000Z">
<meta property="article:author" content="Aki">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://akichen891.github.io/images/arm/i2c1.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>STM32中的I2C通信【24CXX EEPROM】</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2024/12/12/RNN%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E7%BB%84%E6%88%90%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2024/12/04/STM32%E5%86%85%E9%83%A8%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E9%87%87%E9%9B%86/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&text=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&title=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&is_video=false&description=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=STM32中的I2C通信【24CXX EEPROM】&body=Check out this article: http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&title=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&title=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&title=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&title=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&name=STM32中的I2C通信【24CXX EEPROM】&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&t=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#i2c%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text"> I2C简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#i2c%E6%97%B6%E5%BA%8F%E5%92%8C%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text"> I2C时序和读写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.1.</span> <span class="toc-text"> 时序信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text"> 写操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text"> 读操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24c02%E6%97%B6%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text"> 24C02时序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24c02%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text"> 24C02读写操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9Fi2c"><span class="toc-number">5.</span> <span class="toc-text"> 软件模拟I2C</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#custom_i2ch%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text"> custom_i2c.h（头文件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#custom_i2cc"><span class="toc-number">5.2.</span> <span class="toc-text"> custom_i2c.c</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.2.1.</span> <span class="toc-text"> 初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6"><span class="toc-number">5.2.2.</span> <span class="toc-text"> 延时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%B7%E5%A7%8B%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%81%9C%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.2.3.</span> <span class="toc-text"> 起始信号与停止信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%AD%97%E8%8A%82"><span class="toc-number">5.2.4.</span> <span class="toc-text"> 发送字节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%AD%97%E8%8A%82"><span class="toc-number">5.2.5.</span> <span class="toc-text"> 读取字节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%AD%94%E4%BF%A1%E5%8F%B7ack"><span class="toc-number">5.2.6.</span> <span class="toc-text"> 应答信号（ACK）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24cxx-eeprom-%E9%A9%B1%E5%8A%A8"><span class="toc-number">6.</span> <span class="toc-text"> 24CXX EEPROM 驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C-2"><span class="toc-number">6.1.</span> <span class="toc-text"> 写操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C-2"><span class="toc-number">6.2.</span> <span class="toc-text"> 读操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81"><span class="toc-number">6.3.</span> <span class="toc-text"> 检测工作状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text"> 应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text"> 小结</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        STM32中的I2C通信【24CXX EEPROM】
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Aki</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-12-07T12:41:46.000Z" class="dt-published" itemprop="datePublished">2024-12-07</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%EF%BC%88%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%EF%BC%89/">嵌入式（裸机开发）</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="i2c简介"><a class="markdownIt-Anchor" href="#i2c简介"></a> I2C简介</h2>
<p>I2C是由数据线SDA和时钟线SCL构成的串行总线，用于发送或接收数据。其中SDA用于传输数据。SCL用于同步时钟信号。I2C还有以下特征：</p>
<ol>
<li>主从架构
<ul>
<li>主机（Master）：控制通信过程，生成时钟信号并启动通信</li>
<li>从机（Slave）：响应主机指令，按地址匹配参与通信</li>
</ul>
</li>
<li>地址：每个从设备具有唯一的7位或10位地址，用于识别通信目标。主设备在通信开始时发送从设备地址，从设备响应后开始数据传输</li>
<li>半双工通信： 数据线支持双向通信，但同一时刻只允许数据单向传输</li>
<li>数据速率：
<ul>
<li>标准模式（Standard Mode）：最大速率100 kbps</li>
<li>快速模式（Fast Mode）：最大速率400 kbps</li>
<li>高速模式（High-Speed Mode）：最大速率3.4 Mbps</li>
</ul>
</li>
<li>开漏设计：信号线通常采用开漏驱动，需要外部上拉电阻将信号线拉高到逻辑高电平。因此总线空闲时，SDA和DCL都为高电平。</li>
<li>多设备连接：可以有多个具备 IIC 通信能力的设备挂载在上面，同时支持多个主机和多个从机，连接到总线的接口数量只由总线电容 400pF 的限制决定。</li>
</ol>
<h2 id="i2c时序和读写操作"><a class="markdownIt-Anchor" href="#i2c时序和读写操作"></a> I2C时序和读写操作</h2>
<h3 id="时序信号"><a class="markdownIt-Anchor" href="#时序信号"></a> 时序信号</h3>
<p><img src="/images/arm/i2c1.png" alt="I2C总线时序图"></p>
<ol>
<li>起始信号：主机发出，为电平跳变信号而非恒电平信号。SCL为高电平期间，SDA由高电平跳变至低电平，总线被占用，准备数据传输</li>
<li>停止信号：主机发出，为电平跳变信号而非恒电平信号。SCL为高电平期间，SDA由低电平跳变至高电平，总线空闲</li>
<li>应答信号：发送器每发送一个字节，就在时钟脉冲 9 期间释放数据线，由接收器反馈一个应答信号。应答信号为低电平时，规定为有效应答位（ACK 简称应答位），表示接收器已经成功地接收了该字节。应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功</li>
<li>数据有效性：总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。数据在 SCL 的上升沿到来之前就需准备好。并在下降沿到来之前必须稳定</li>
<li>数据传输：总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在 SCL 串行时钟的配合下，在 SDA 上逐位地串行传送每一位数据。数据位的传输是边沿触发</li>
<li>空闲状态：SDA 和 SCL两条信号线同时处于高电平时，规定为总线的空闲状态。此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高</li>
</ol>
<h3 id="写操作"><a class="markdownIt-Anchor" href="#写操作"></a> 写操作</h3>
<p><img src="/images/arm/i2c2.png" alt="I2C写操作通讯"></p>
<ol>
<li>主机发送起始信号，令总线上的所有从机等待接收数据</li>
<li>主机发送从机地址+‘0’（写操作）组成的8位数据。从机接收到地址后，比对该地址是否为本机地址。若为本机地址，从机发送应答信号</li>
<li>主机向从机发送数据</li>
</ol>
<h3 id="读操作"><a class="markdownIt-Anchor" href="#读操作"></a> 读操作</h3>
<p><img src="/images/arm/i2c3.png" alt="I2C读操作通讯"></p>
<ol>
<li>主机发送起始信号，令总线上的所有从机等待接收数据</li>
<li>主机发送从机地址+‘1’（读操作）组成的8位数据。从机接收到地址后，比对该地址是否为本机地址。若为本机地址，从机发送应答信号</li>
<li>从机向主机发送数据</li>
</ol>
<p>若主机一直返回应答信号，那么从机可以一直发送数据，直到主机发送NACK信号为止。</p>
<h2 id="24c02时序"><a class="markdownIt-Anchor" href="#24c02时序"></a> 24C02时序</h2>
<p>24C02 是一个 2K bit 的串行 EEPROM 存储器，内部含有 256 个字节。在 24C02 里面还有一个 8 字节的页写缓冲器。该设备的通信方式为 IIC，通过其 SCL 和 SDA 与其他设备通信。</p>
<p><img src="/images/arm/24c021.png" alt="24C02引脚"></p>
<p>WP为写保护引脚，高电平只读，低电平开放读写功能。24C02的设备地址共8位，包含不可编程部分和可编程部分，可编程部分根据硬件Pin A0、A1、A2决定；设备地址最后一位用于设置是读操作还是写操作。具体为：</p>
<p><img src="/images/arm/24c022.png" alt="24C02设备地址格式"></p>
<p>本文中A0、A1、A2均接地，故24C02设备读操作地址为<code>0xA1</code>，写操作地址为<code>0xA0</code>。</p>
<h2 id="24c02读写操作"><a class="markdownIt-Anchor" href="#24c02读写操作"></a> 24C02读写操作</h2>
<p><img src="/images/arm/24c023.png" alt="24C02写时序"></p>
<p>主机在 IIC 总线发送第 1 个字节的数据为24C02的设备地址<code>0xA0</code>，用于寻找总线上的24C02，在获得24C02的应答信号之后，继续发送第 2 个字节数据，该字节数据是 24C02 的内存地址，再等到 24C02 的应答信号，主机继续发送第 3 字节数据，这里的数据即是写入在第 2 字节内存地址的数据。主机完成写操作后，可以发出停止信号，终止数据传输。这种写操作每次只能写入1字节数据。</p>
<p><img src="/images/arm/24c024.png" alt="24C02页写时序"></p>
<p>写操作时，24C02可以使用页写时序，其和普通写时序的区别是页写时序只需要告知一次内存地址1，后面的数据会按照写入顺序存入内存地址2、内存地址3等，节省通信时间。</p>
<p><img src="/images/arm/24c025.png" alt="24C02读时序"></p>
<p>24C02读取数据的过程是一个复合的时序，其中包含写时序和读时序。通常第一个通信过程为写时序，起始信号产生后，主机发送24C02设备地址<code>0xA0</code>，获取从机应答信号后，接着发送需要读取的内存地址；在随后的读时序中，起始信号产生后，主机发送24C02设备地址<code>0xA1</code>, 获取从机应答信号后，从机返回刚刚在写时序中传递的内存地址的数据，以字节为单位传输在总线上，假如主机获取数据后返回的是应答信号，那么从机会一直传输数据，当主机发出的是非应答信号并以停止信号发出为结束，从机结束传输。</p>
<h2 id="软件模拟i2c"><a class="markdownIt-Anchor" href="#软件模拟i2c"></a> 软件模拟I2C</h2>
<p>HAL库自带的硬件I2C函数比较复杂，多采用软件模拟I2C的方式操作GPIO以获得I2C时序。</p>
<h3 id="custom_i2ch头文件"><a class="markdownIt-Anchor" href="#custom_i2ch头文件"></a> custom_i2c.h（头文件）</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> ****************************************************************************************************</span><br><span class="line"> * @file        custom_i2c.h</span><br><span class="line"> * @author      Aki</span><br><span class="line"> * @version     V1.0</span><br><span class="line"> * @date        2024-12-11</span><br><span class="line"> * @brief       软件IIC头文件</span><br><span class="line"> ****************************************************************************************************</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#ifndef __MYIIC_H</span><br><span class="line">#define __MYIIC_H</span><br><span class="line"></span><br><span class="line">#include &quot;sys.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/******************************************************************************************/</span><br><span class="line">/* 引脚定义 */</span><br><span class="line"></span><br><span class="line">#define IIC_SCL_GPIO_PORT               GPIOH</span><br><span class="line">#define IIC_SCL_GPIO_PIN                GPIO_PIN_4</span><br><span class="line">#define IIC_SCL_GPIO_CLK_ENABLE()       do&#123; __HAL_RCC_GPIOH_CLK_ENABLE(); &#125;while(0)   /* PH口时钟使能 */</span><br><span class="line"></span><br><span class="line">#define IIC_SDA_GPIO_PORT               GPIOH</span><br><span class="line">#define IIC_SDA_GPIO_PIN                GPIO_PIN_5</span><br><span class="line">#define IIC_SDA_GPIO_CLK_ENABLE()       do&#123; __HAL_RCC_GPIOH_CLK_ENABLE(); &#125;while(0)   /* PH口时钟使能 */</span><br><span class="line"></span><br><span class="line">/******************************************************************************************/</span><br><span class="line">/* IO操作 */</span><br><span class="line"></span><br><span class="line">#define IIC_SCL(x)        do&#123; x ? \</span><br><span class="line">                              HAL_GPIO_WritePin(IIC_SCL_GPIO_PORT, IIC_SCL_GPIO_PIN, GPIO_PIN_SET) : \</span><br><span class="line">                              HAL_GPIO_WritePin(IIC_SCL_GPIO_PORT, IIC_SCL_GPIO_PIN, GPIO_PIN_RESET); \</span><br><span class="line">                          &#125;while(0)       /* SCL */</span><br><span class="line"></span><br><span class="line">#define IIC_SDA(x)        do&#123; x ? \</span><br><span class="line">                              HAL_GPIO_WritePin(IIC_SDA_GPIO_PORT, IIC_SDA_GPIO_PIN, GPIO_PIN_SET) : \</span><br><span class="line">                              HAL_GPIO_WritePin(IIC_SDA_GPIO_PORT, IIC_SDA_GPIO_PIN, GPIO_PIN_RESET); \</span><br><span class="line">                          &#125;while(0)       /* SDA */</span><br><span class="line"></span><br><span class="line">#define IIC_READ_SDA     HAL_GPIO_ReadPin(IIC_SDA_GPIO_PORT, IIC_SDA_GPIO_PIN)        /* 读取SDA电平 */</span><br><span class="line"></span><br><span class="line">/******************************************************************************************/</span><br><span class="line"></span><br><span class="line">void iic_init(void);                        </span><br><span class="line">void iic_start(void);                       </span><br><span class="line">void iic_stop(void);                      </span><br><span class="line">void iic_ack(void);                        </span><br><span class="line">void iic_nack(void);                       </span><br><span class="line">uint8_t iic_wait_ack(void);                 </span><br><span class="line">void iic_send_byte(uint8_t data);          </span><br><span class="line">uint8_t iic_read_byte(unsigned char ack);   </span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>这里宏定义利用了两个小技巧：</p>
<ul>
<li>三目运算符：x ? … : … 是一个条件（三目）运算符。它的工作原理是：根据 x 的值（x 是一个表达式），判断执行哪一部分代码。如果 x 为 true（非零），执行冒号前的表达式；如果 x 为 false（零），执行冒号后的表达式。</li>
<li><code>do &#123; ... &#125; while(0)</code>：确保宏只执行一次且不会干扰外部代码结构的惯用法。这样做可以确保宏在使用时，代码不会因缺少括号而引发语法错误。</li>
</ul>
<h3 id="custom_i2cc"><a class="markdownIt-Anchor" href="#custom_i2cc"></a> custom_i2c.c</h3>
<h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">    @brief:IIC初始化</span><br><span class="line">    @param:NULL</span><br><span class="line">    @return:NULL</span><br><span class="line">**/</span><br><span class="line">void iic_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef gpio_init_struct;</span><br><span class="line"></span><br><span class="line">    IIC_SCL_GPIO_CLK_ENABLE();  /* SCL引脚时钟使能 */</span><br><span class="line">    IIC_SDA_GPIO_CLK_ENABLE();  /* SDA引脚时钟使能 */</span><br><span class="line"></span><br><span class="line">    /* SCL */</span><br><span class="line">    gpio_init_struct.Pin = IIC_SCL_GPIO_PIN;</span><br><span class="line">    gpio_init_struct.Mode = GPIO_MODE_OUTPUT_PP;    /* 推挽输出 */</span><br><span class="line">    gpio_init_struct.Pull = GPIO_PULLUP;            /* 上拉 */</span><br><span class="line">    gpio_init_struct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;</span><br><span class="line">    HAL_GPIO_Init(IIC_SCL_GPIO_PORT, &amp;gpio_init_struct);</span><br><span class="line"></span><br><span class="line">    /* SDA */</span><br><span class="line">    gpio_init_struct.Pin = IIC_SDA_GPIO_PIN;</span><br><span class="line">    gpio_init_struct.Mode = GPIO_MODE_OUTPUT_OD;    /* 开漏输出 */</span><br><span class="line">    HAL_GPIO_Init(IIC_SDA_GPIO_PORT, &amp;gpio_init_struct);</span><br><span class="line"></span><br><span class="line">    iic_stop();     /* 停止总线上所有设备 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里SDA线使用开漏输出，这意味着当SDA引脚输出低电平时，设备直接将线拉低（输出低电平）；而当设备输出高电平时，它并不直接将线拉高，而是将SDA引脚设置为高阻态（即不驱动该引脚。当一个设备希望发送数据时，如果它需要输出0（低电平），它会直接将SDA引脚拉低。当它需要发送1（高电平），它不会直接将SDA引脚拉高，而是让SDA引脚处于高阻态，让总线上的其他设备（如果有）通过拉高SDA线来实现高电平。这么做可以有效避免连接多个从机时发生电平冲突。STM32F429使用开漏模式时，必须外界上拉电阻。</p>
<h4 id="延时"><a class="markdownIt-Anchor" href="#延时"></a> 延时</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">    @brief:IIC延时函数</span><br><span class="line">    @param:NULL</span><br><span class="line">    @return:NULL</span><br><span class="line">**/</span><br><span class="line">static void iic_delay(void)</span><br><span class="line">&#123;</span><br><span class="line">    delay_us(2);    /* 读写速度在250Khz以内 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为获得稳定的读写结果，需限制读写速度，此处通过延时2us的形式实现。</p>
<h4 id="起始信号与停止信号"><a class="markdownIt-Anchor" href="#起始信号与停止信号"></a> 起始信号与停止信号</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">    @brief:IIC起始信号</span><br><span class="line">    @param:NULL</span><br><span class="line">    @return:NULL</span><br><span class="line">**/</span><br><span class="line">void iic_start(void)</span><br><span class="line">&#123;</span><br><span class="line">    IIC_SDA(1);</span><br><span class="line">    IIC_SCL(1);</span><br><span class="line">    iic_delay();</span><br><span class="line">    IIC_SDA(0);   /* START信号 */</span><br><span class="line">    iic_delay();</span><br><span class="line">    IIC_SCL(0);   /* 钳住总线，准备发送或接收数据（SCL只有低电平期间允许改变SDA状态） */</span><br><span class="line">    iic_delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">    @brief:IIC停止信号</span><br><span class="line">    @param:NULL</span><br><span class="line">    @return:NULL</span><br><span class="line">**/</span><br><span class="line">void iic_stop(void)</span><br><span class="line">&#123;</span><br><span class="line">    IIC_SDA(0);     /* STOP信号 */</span><br><span class="line">    iic_delay();</span><br><span class="line">    IIC_SCL(1);</span><br><span class="line">    iic_delay();</span><br><span class="line">    IIC_SDA(1);     /* 总线结束信号 */</span><br><span class="line">    iic_delay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/arm/i2c4.png" alt="START和STOP时序"></p>
<p>根据IIC时序图，起始信号和停止信号分别为：</p>
<ul>
<li>START：SCL高电平，SDA从1跳变至0</li>
<li>STOP：SCL高电平，SDA从0跳变至1</li>
</ul>
<p>上面的两个函数实现的就是这个功能，同时加入了延时来保证能得到稳定的电平。需要注意，停止信号发出时，SCL需要在SDA电平开始跳变前就保持高电平。</p>
<h4 id="发送字节"><a class="markdownIt-Anchor" href="#发送字节"></a> 发送字节</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">    @brief:IIC发送一个字节</span><br><span class="line">    @param:data：要发送的数据</span><br><span class="line">    @return:NULL</span><br><span class="line">**/</span><br><span class="line">void iic_send_byte(uint8_t data)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t t;</span><br><span class="line"></span><br><span class="line">    for (t = 0; t &lt; 8; t++)</span><br><span class="line">    &#123;</span><br><span class="line">        IIC_SDA((data &amp; 0x80) &gt;&gt; 7);    /* 提取高位 */</span><br><span class="line">        iic_delay();</span><br><span class="line">        IIC_SCL(1);     /* 拉高SCL并维持高电平，开始发送 */</span><br><span class="line">        iic_delay();</span><br><span class="line">        IIC_SCL(0);     /* 发送结束，拉低SCL，准备下一位数据 */</span><br><span class="line">        data &lt;&lt;= 1;     /* 左移1位，循环发送 */</span><br><span class="line">    &#125;</span><br><span class="line">    IIC_SDA(1);     /* 发送完成，释放SDA线 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/arm/i2c5.png" alt="I2C发送时序"></p>
<p>发送字节时，由于一个时钟周期内I2C只能发送一位(bit)数据，因此发送需要循环8次，模拟8个时钟信号，才能把形参的8位数据都发送出去。也就是我们需要提取出形参的每一位并发送。这里使用了<code>(data &amp; 0x80) &gt;&gt; 7</code>的方式。<code>(data &amp; 0x80)</code>是将形参与<code>0x80</code>，也就是<code>10000000</code>进行与运算，然后右移7位，提取出形参的最高位。如果最高位是1，那么SDA就拉高；反之SDA则拉低。每个周期完成后，data左移1位，将原先是次高位的数移到最高位，重复这个过程8次。全部发送完成后，释放SDA线。</p>
<h4 id="读取字节"><a class="markdownIt-Anchor" href="#读取字节"></a> 读取字节</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">    @brief:IIC读取一个字节</span><br><span class="line">    @param:ack: ack=1时，发送ack; ack=0时，发送nack</span><br><span class="line">    @return:接收到的数据</span><br><span class="line">**/</span><br><span class="line">uint8_t iic_read_byte(uint8_t ack)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t i, receive = 0x00;</span><br><span class="line"></span><br><span class="line">    /* 1个字节共8位，单次接收1位，循环8次 */</span><br><span class="line">    for (i = 0; i &lt; 8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        receive &lt;&lt;= 1;      /* 输出时高位先输出，因此接收时先收到的数据是高位，要左移 */</span><br><span class="line">        IIC_SCL(1);         /* 拉高SCL，SDA准备接收 */</span><br><span class="line">        iic_delay();</span><br><span class="line"></span><br><span class="line">        if (IIC_READ_SDA)   /* 如果SDA为高电平 */</span><br><span class="line">        &#123;</span><br><span class="line">            receive++;      /* 第0位（低位）置1 */</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IIC_SCL(0);         /* 接收结束，拉低SCL */</span><br><span class="line">        iic_delay();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!ack)</span><br><span class="line">    &#123;</span><br><span class="line">        iic_nack();         /* 发送nACK信号 */</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        iic_ack();          /* 发送ACK信号 */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在时序方面，I2C读取字节和写入字节是一致的。</p>
<h4 id="应答信号ack"><a class="markdownIt-Anchor" href="#应答信号ack"></a> 应答信号（ACK）</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">    @brief:等待应答信号</span><br><span class="line">    @param:NULL</span><br><span class="line">    @return:1=失败；0=成功</span><br><span class="line">**/</span><br><span class="line">uint8_t iic_wait_ack(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t waittime = 0;</span><br><span class="line">    uint8_t rack = 0;</span><br><span class="line"></span><br><span class="line">    IIC_SDA(1);     /* 主机释放SDA（外部器件此时可拉低SDA电平） */</span><br><span class="line">    iic_delay();</span><br><span class="line">    IIC_SCL(1);     /* 拉高SCL，从机此时可返回ACK */</span><br><span class="line">    iic_delay();</span><br><span class="line"></span><br><span class="line">    while (IIC_READ_SDA)    /* 等待应答 */</span><br><span class="line">    &#123;</span><br><span class="line">        waittime++;</span><br><span class="line"></span><br><span class="line">        if (waittime &gt; 250)</span><br><span class="line">        &#123;</span><br><span class="line">            iic_stop();</span><br><span class="line">            rack = 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IIC_SCL(0);     /* SCL=0，结束ACK检查 */</span><br><span class="line">    iic_delay();</span><br><span class="line">    return rack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等待应答信号一般用在写时序中，在<code>iic_send_byte</code>后调用。当读取到SDA为低电平时，表示ACK信号；SDA为高电平则为NACK信号。若等待超时，则主机会直接发出停止信号。若正常接收到ACK信号，主机拉低SCL线，返回flag。这一段内容对应总线时序图中的红圈3，也就是脉冲9。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">    @brief:产生ACK应答</span><br><span class="line">    @param:NULL</span><br><span class="line">    @return:NULL</span><br><span class="line">    @note：ACK应答时，SDA拉低，SCL=0-&gt;1-&gt;0</span><br><span class="line">**/</span><br><span class="line">void iic_ack(void)</span><br><span class="line">&#123;</span><br><span class="line">    IIC_SDA(0);     </span><br><span class="line">    iic_delay();</span><br><span class="line">    IIC_SCL(1);     </span><br><span class="line">    iic_delay();</span><br><span class="line">    IIC_SCL(0);     </span><br><span class="line">    iic_delay();</span><br><span class="line">    IIC_SDA(1);     </span><br><span class="line">    iic_delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">    @brief:不产生ACK应答（NACK）</span><br><span class="line">    @param:NULL</span><br><span class="line">    @return:NULL</span><br><span class="line">    @note：NACK应答时，SDA拉高，SCL=0-&gt;1-&gt;0</span><br><span class="line">**/</span><br><span class="line">void iic_nack(void)</span><br><span class="line">&#123;</span><br><span class="line">    IIC_SDA(1);</span><br><span class="line">    iic_delay();</span><br><span class="line">    IIC_SCL(1);</span><br><span class="line">    iic_delay();</span><br><span class="line">    IIC_SCL(0);</span><br><span class="line">    iic_delay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两个函数用于主机作为接收端时，在接收完数据后向从机返回ACK或NACK信号。二者对应的也是线时序图中的红圈3，也就是脉冲9。</p>
<h2 id="24cxx-eeprom-驱动"><a class="markdownIt-Anchor" href="#24cxx-eeprom-驱动"></a> 24CXX EEPROM 驱动</h2>
<h3 id="写操作-2"><a class="markdownIt-Anchor" href="#写操作-2"></a> 写操作</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @brief 向 AT24CXX 指定地址写入一个数据</span><br><span class="line">* @param addr: 写入数据的目的地址</span><br><span class="line">* @param data: 要写入的数据</span><br><span class="line">* @retval 无</span><br><span class="line">*/</span><br><span class="line">void at24cxx_write_one_byte(uint16_t addr, uint8_t data)</span><br><span class="line">&#123;</span><br><span class="line">    iic_start();       /* IIC起始信号 */</span><br><span class="line"></span><br><span class="line">    if (EE_TYPE &gt; AT24C16)  /* 容量大于24C16时分2个字节发送目标内存地址 */</span><br><span class="line">    &#123;</span><br><span class="line">        iic_send_byte(0xA0);    /* 发送写命令，从机设备地址为0xA0，最低位为0表示写入 */</span><br><span class="line">        iic_wait_ack();         /* 发送完一个字节后等待ACK */</span><br><span class="line">        iic_send_byte(addr &gt;&gt; 8);   /* 发送高位内存地址 */</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        iic_send_byte(0xA0 + ((addr &gt;&gt; 8) &lt;&lt; 1));   /* 发送器件0xA0 + 高位a8/a9/a10地址，写数据 */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_send_byte(addr % 256);  /* 发送低位内存地址 */</span><br><span class="line">    iic_wait_ack();</span><br><span class="line"></span><br><span class="line">    iic_send_byte(data);    /* 发送1个字节 */</span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_stop();</span><br><span class="line">    delay_ms(10);       /* EEPROM写入速度慢，必须等待写入完成再写下一个 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>24CXX的写操作主要包含三个步骤：写入设备地址，写入目标内存地址，写入待传输数据。设备地址之前已经介绍过，高7位为固定地址，低1位为<code>'0'</code>时表示写操作。</p>
<ul>
<li>若EEPROM容量大于24C16，比如24C32和24C64，EEPROM总的字节数分别为4096和8192，对应寻址线为12根和13根，即内存地址是12位和13位的，显然发送内存地址时就需要分高字节和低字节两次发送。</li>
<li>若EEPROM容量小于或等于24C16，则寻址线最多为11根，内存地址最多是11位的。通过<code>iic_send_byte(0xA0 + ((addr &gt;&gt; 8) &lt;&lt; 1))</code>，可以让主机下发读写命令时自带3位高地址，剩下的8位地址只需要合在一起在低位发送即可，也就是<code>iic_send_byte(addr % 256)</code>。</li>
</ul>
<p>这种设备地址低位和内存地址高位相结合的设计可以看作是EEPROM和独特设计，用来节省资源。</p>
<h3 id="读操作-2"><a class="markdownIt-Anchor" href="#读操作-2"></a> 读操作</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @brief 在 AT24CXX 指定地址写入一个数据</span><br><span class="line">* @param addr: 写入数据的目的地址</span><br><span class="line">* @param data: 要写入的数据</span><br><span class="line">* @retval 无</span><br><span class="line">*/</span><br><span class="line">uint8_t at24cxx_read_one_byte(uint16_t addr)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t temp = 0;</span><br><span class="line">    iic_start();</span><br><span class="line"></span><br><span class="line">    /* 根据不同的 24CXX 型号, 发送高位地址</span><br><span class="line">    * 1, 24C16 以上的型号, 分 2 个字节发送地址</span><br><span class="line">    * 2, 24C16 及以下的型号, 分 1 个低字节地址 + 占用器件地址的 bit1 ~ bit3 位</span><br><span class="line">    * 用于表示高位地址, 最多 11 位地址</span><br><span class="line">    * 对于 24C01/02, 其器件地址格式(8bit)为: 1 0 1 0 A2 A1 A0 R/W</span><br><span class="line">    * 对于 24C04, 其器件地址格式(8bit)为: 1 0 1 0 A2 A1 a8 R/W</span><br><span class="line">    * 对于 24C08, 其器件地址格式(8bit)为: 1 0 1 0 A2 a9 a8 R/W</span><br><span class="line">    * 对于 24C16, 其器件地址格式(8bit)为: 1 0 1 0 a10 a9 a8 R/W</span><br><span class="line">    * R/W : 读/写控制位 0,表示写; 1,表示读;</span><br><span class="line">    * A0/A1/A2 : 对应器件的 1,2,3 引脚(只有 24C01/02/04/8 有这些脚)</span><br><span class="line">    * a8/a9/a10: 对应存储整列的高位地址, 11bit 地址最多可以表示 2048 个位置,</span><br><span class="line">    * 可以寻址 24C16 及以内的型号</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">   if (EE_TYPE &gt; AT24C16)       /* 24C16以上型号分2个字节发送地址 */</span><br><span class="line">   &#123;</span><br><span class="line">        iic_send_byte(0xA0);    /* 最低位为0，表示写入*/</span><br><span class="line">        iic_wait_ack();         /* 发送完一个字节后等待ACK信号 */</span><br><span class="line">        iic_send_byte(addr &gt;&gt; 8);       /* 发送高字节地址 */</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">        /* 发送器件0xA0 + 高位a8/a9/a10地址，写数据 */</span><br><span class="line">        iic_send_byte(0xA0 + ((addr &gt;&gt; 8) &lt;&lt; 1));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   iic_wait_ack();</span><br><span class="line">   iic_send_byte(addr % 256);       /* 发送低位地址*/</span><br><span class="line">   iic_wait_ack();</span><br><span class="line"></span><br><span class="line">   iic_start();                     /* 重新发送起始信号*/</span><br><span class="line">   iic_send_byte(0xA1);             /* 进入接收模式，最低位为1，表示读取*/</span><br><span class="line">   iic_wait_ack();</span><br><span class="line">   temp = iic_read_byte(0);         /* 接收一个字节数据 */</span><br><span class="line">   iic_stop();</span><br><span class="line"></span><br><span class="line">   return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>iic_send_byte(addr % 256)</code>用来提取内存地址的低8位。也可以用<code>addr &amp;= 0x00FF</code>来代替。</p>
<h3 id="检测工作状态"><a class="markdownIt-Anchor" href="#检测工作状态"></a> 检测工作状态</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @brief 检查 AT24CXX 是否正常</span><br><span class="line">* @note 检测原理: 在器件的末地址写入 0X55, 然后再读取, </span><br><span class="line">* 如果读取值为 0X55 则表示检测正常. 否则,则表示检测失败.</span><br><span class="line">* @param 无</span><br><span class="line">* @retval 检测结果</span><br><span class="line">* 0: 检测成功</span><br><span class="line">* 1: 检测失败</span><br><span class="line">*/</span><br><span class="line">uint8_t at24cxx_check(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t temp;</span><br><span class="line">    uint16_t addr = EE_TYPE;                /* 目标内存地址为EEPROM末地址 */</span><br><span class="line">    temp = at24cxx_read_one_byte(addr);     /* 避免每次开机都写入*/</span><br><span class="line"></span><br><span class="line">    if (temp == 0x55)                       /* 读取数据正常 */</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else                                    /* 第一次初始化时 */</span><br><span class="line">    &#123;</span><br><span class="line">        at24cxx_write_one_byte(addr, 0x55); /* 先写入 */</span><br><span class="line">        temp = at24cxx_read_one_byte(255);  /* 再读取 */</span><br><span class="line">        if (temp == 0x55) return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种操作和RTC实验很类似，利用EEPROM掉电后内存不丢失的特性，固定在第一次写入时于内存末地址写入<code>0x55</code>，然后再去读一下看看是否写入成功，以此来检测芯片是否正常工作。</p>
<h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2>
<p>实现一个简单的应用：按下KEY1，向EEPROM的首地址写入字符串，写入成功串口打印“write ok”；按下KEY0，读取EEPROM首地址内容，串口打印读取结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN 2 */</span><br><span class="line">  while (at24cxx_check())</span><br><span class="line">  &#123;</span><br><span class="line">    led_red_toggle();</span><br><span class="line">    delay_ms(500);</span><br><span class="line">  &#125;</span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">    uint8_t key;</span><br><span class="line">    uint8_t writeok[] = &quot;write ok\n&quot;;</span><br><span class="line">    uint8_t txbuf[] = &quot;mua\n&quot;;</span><br><span class="line">    uint8_t rxbuf[5];</span><br><span class="line">    uint8_t readok[15];</span><br><span class="line"></span><br><span class="line">    key = key_scan(0);</span><br><span class="line"></span><br><span class="line">    if (key == KEY1_pressed)    /* 如果KEY1被按下 */</span><br><span class="line">    &#123;</span><br><span class="line">      at24cxx_write(0, txbuf, sizeof(txbuf));</span><br><span class="line">      HAL_UART_Transmit_IT(&amp;huart1, writeok, sizeof(writeok));</span><br><span class="line">      delay_ms(50);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (key == KEY0_pressed)    /* 如果KEY0被按下 */</span><br><span class="line">    &#123;</span><br><span class="line">      at24cxx_read(0, rxbuf, sizeof(txbuf));</span><br><span class="line">      //sprintf(readok, &quot;result is %d\n&quot;, rxbuf[0]);</span><br><span class="line">      HAL_UART_Transmit_IT(&amp;huart1, rxbuf, sizeof(rxbuf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    led_green(1);</span><br><span class="line">    delay_ms(10);</span><br><span class="line">  &#125;</span><br><span class="line">  /* USER CODE END 3 */</span><br></pre></td></tr></table></figure>
<p><img src="/images/arm/24c026.png" alt="串口打印结果"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/AkiChen891/STM32F429-24C02-EEPROM-TEST">Github项目地址</a></p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>总的来说，通过I2C操作EEPROM时的要点有：</p>
<ul>
<li>写入时：先写入设备地址+写操作指示符，然后写入目标内存地址，最后写入待写入数据</li>
<li>读出时：起始信号，先写入设备地址+写操作指示符，从机ACK后写入目标内存地址；然后重新发出起始信号（<strong>因为需要从写模式切换到读模式</strong>），写入设备地址+读操作指示符，从机ACK后读出待读数据。读取完毕后，主机发送NACK，提示从机读取结束</li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#i2c%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text"> I2C简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#i2c%E6%97%B6%E5%BA%8F%E5%92%8C%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text"> I2C时序和读写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.1.</span> <span class="toc-text"> 时序信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text"> 写操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text"> 读操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24c02%E6%97%B6%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text"> 24C02时序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24c02%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text"> 24C02读写操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9Fi2c"><span class="toc-number">5.</span> <span class="toc-text"> 软件模拟I2C</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#custom_i2ch%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text"> custom_i2c.h（头文件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#custom_i2cc"><span class="toc-number">5.2.</span> <span class="toc-text"> custom_i2c.c</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.2.1.</span> <span class="toc-text"> 初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6"><span class="toc-number">5.2.2.</span> <span class="toc-text"> 延时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%B7%E5%A7%8B%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%81%9C%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.2.3.</span> <span class="toc-text"> 起始信号与停止信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%AD%97%E8%8A%82"><span class="toc-number">5.2.4.</span> <span class="toc-text"> 发送字节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%AD%97%E8%8A%82"><span class="toc-number">5.2.5.</span> <span class="toc-text"> 读取字节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%AD%94%E4%BF%A1%E5%8F%B7ack"><span class="toc-number">5.2.6.</span> <span class="toc-text"> 应答信号（ACK）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24cxx-eeprom-%E9%A9%B1%E5%8A%A8"><span class="toc-number">6.</span> <span class="toc-text"> 24CXX EEPROM 驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C-2"><span class="toc-number">6.1.</span> <span class="toc-text"> 写操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C-2"><span class="toc-number">6.2.</span> <span class="toc-text"> 读操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81"><span class="toc-number">6.3.</span> <span class="toc-text"> 检测工作状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text"> 应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text"> 小结</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&text=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&title=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&is_video=false&description=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=STM32中的I2C通信【24CXX EEPROM】&body=Check out this article: http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&title=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&title=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&title=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&title=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&name=STM32中的I2C通信【24CXX EEPROM】&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://akichen891.github.io/2024/12/07/STM32%E4%B8%AD%E7%9A%84I2C%E9%80%9A%E4%BF%A1%E3%80%9024CXX%20EEPROM%E3%80%91/&t=STM32中的I2C通信【24CXX EEPROM】"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    Aki
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
